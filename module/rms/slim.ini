#
# slim.ini $Revision: #153 $:
#   the .ini file for slim-specific preferences.
#
#   Available commands:
#	SetPref name value
#	LockPref name value
#	LoadExtension class filename
#   
#   In addition, you can use standard safe-tcl commands
#   to perform calculations and substitutions.  We also
#   provide the following procs:
#	RATGetDir $dir - returns the path to a rat subdir:
#   	    $dir can be lib, etc, resource, home
#	GetPref name - returns the current value of a pref.
#	LogMsg code msg - logs a message at a level indicated
#	    by code which should be one of:
#		COPIOUS, INFO, NOTICE, WARNING, ERROR
#
#
# Slim Extensions

namespace eval ::Slim {}; #create the ::Slim namespace for globals

# source registration/menu procedures used below
source [file join [RATGetDir etc] SlimInit.tcl]

set templates [file join [RATGetDir lib] slim]

# TemplateSearchPaths is a tcl list of directories
SetPref TemplateSearchPaths [list $templates]

# require slim extensions  .............................................
# extensions of type slim are loaded at startup. We recommend
# that all customui, macros, visualizers and converters be "pre-loaded".
#
LoadExtension slim [file join $templates floatsplineui.slim] customui
LoadExtension slim [file join $templates splineui.slim] customui
LoadExtension slim [file join $templates layerui.slim] customui
LoadExtension slim [file join $templates layerui2.slim] customui
LoadExtension slim [file join $templates adaptorui.slim] customui
LoadExtension slim [file join $templates addparamui.slim] customui
LoadExtension slim [file join $templates bigstringui.slim] customui
LoadExtension slim [file join $templates combineui.slim] customui
LoadExtension slim [file join $templates customui.slim] customui
LoadExtension slim [file join $templates customcmd.slim] customcmd
LoadExtension slim [file join $templates noiseui.slim] customui
LoadExtension slim [file join $templates listui.slim] customui
LoadExtension slim [file join $templates visui.slim] customui

# these extensions are required for basic slim operation.
LoadExtension slim [file join $templates aovmacros.slim] customui
LoadExtension slim [file join $templates macros.slim] customui
LoadExtension slim [file join $templates conversion.slim] slim
LoadExtension slim [file join $templates visualizers.slim] slim
LoadExtension tcl [file join [RATGetDir etc] SlimClientExpression.tcl]
LoadExtension tcl [file join [RATGetDir etc] SlimExpression.tcl]
LoadExtension tcl [file join [RATGetDir etc] SlimBuildShaderMetadata.tcl]

# type used by the "multiple" visualizer
# any nodes with multiple outputs will need their types
# to be able to convert to this type
SetPref MultipleVisualizerInputType shadingmodel

# preferences for automatic type conversion
# these define the template that will convert
# from the first type to the second
# entries marked as "hidden" are only used by the "multiple" visualizer
SetPref TypeConversionTemplate(float,color) \
	pixar,ConvertFloatToColor
SetPref TypeConversionTemplate(color,float) \
	pixar,ConvertColorToFloat
SetPref TypeConversionTemplate(vector,normal) \
	pixar,ConvertVectorToNormal
SetPref TypeConversionTemplate(normal,vector) \
	pixar,ConvertNormalToVector
SetPref TypeConversionTemplate(shadingcomponent,color) \
	pixar,ConvertSCToColor
SetPref TypeConversionTemplate(color,shadingcomponent) \
	pixar,ConvertColorToSC
SetPref TypeConversionTemplate(shadingmodel,color) \
	pixar,ConvertSMToColor
SetPref TypeConversionTemplate(color,shadingmodel) \
	pixar,ConvertColorToSM
SetPref TypeConversionTemplate(shadingmodel,shadingmodel_aov) \
	pixar,ConvertSMToSMaov
SetPref TypeConversionTemplate(shadingmodel_aov,shadingmodel) \
	pixar,ConvertSMaovToSM

# these are only useful for the "multiple" visualizer
SetPref TypeConversionTemplate(float,shadingmodel) \
	{pixar,ConvertFloatToSM hidden}
SetPref TypeConversionTemplate(point,shadingmodel) \
	{pixar,ConvertPointToSM hidden}
SetPref TypeConversionTemplate(vector,shadingmodel) \
	{pixar,ConvertVectorToSM hidden}
SetPref TypeConversionTemplate(normal,shadingmodel) \
	{pixar,ConvertNormalToSM hidden}
SetPref TypeConversionTemplate(manifold,shadingmodel) \
	{pixar,ConvertManifoldToSM hidden}

# URLs for the Help menu
SetPref HelpURLs(slim) {
    "Slim Documentation" %RATDOCROOT/slim/
}

# interface preferences
SetPref RaiseSlim 1
SetPref InstanceStructure hierachical; # hierarchical, flat, grouped
SetPref ColorGain 1
SetPref ColorGamma 1 
SetPref ExpertMenus 0

SetPref RenderInstancesWhenUpdating 1
SetPref BrowseIconSize 20
SetPref CreateIconSize 20
SetPref ShowAppearanceNotes 0
SetPref ShowAppearanceTags 0
SetPref ValueSetColor "#000044"
SetPref ValueUnsetColor "#444444"
SetPref CascadeMenuSize 16
SetPref DefaultSliderPrecision 0.01
SetPref ShowPathInAppEditorTitle 1
SetPref SlimWindowViewStyle threecolumn

# A time interval in milliseconds every which to check for read-only status on
# disk-based palettes. Use 0 to never check, values under 200 are clamped to 200
SetPref StatPalettes 1000

# Enable delayed loading of palettes
SetPref LazyPaletteLoad 1

# Whether library palettes should be removed and reloaded in a
# slim Clear operation
SetPref ClearLibraryPalettes 0

# Create a new palette if there are no palettes in Slim
SetPref CreateDefaultPalette 1

# Allow for the ability to drag an appearance into another appearance
# to create node collections
SetPref EnableAppearanceHierarchies 1

# Put up a message box error for each time a template has two properties
# with the same name
SetPref LoudDuplicateNamingError    0

# preview preferences

# rendering
# to plug in your own renderer, place your rendering command
# here.  Note that %f and %i are substituted by the RIB
# filename and the slim internal image name.  To cause
# send your pixels to slim, invoke sho -dspy slim -dspyfile %i %i
#
#     LockPref PreviewRenderer "render %f"
#
SetPref PreviewRenderer internal
SetPref PreviewResolution 120
SetPref PreviewShadingRate 1
SetPref PreviewProcsUsed all
SetPref PreviewBucketsPerRow 4
SetPref PreviewPixelSamples {3 3}
SetPref PreviewPixelFilter {"catmull-rom" 3 3}
SetPref CustomDisplay ""

# object
SetPref PreviewObjectSize  1
SetPref PreviewObjectShape Sphere
SetPref PreviewObjectArchive ""
SetPref PreviewFrameVisible 0

# lights
SetPref PreviewSimpleLights 1
SetPref KeyLight {.8 .8 .8}
SetPref FillLight {.2 .2 .2}
SetPref AmbientLight {.05 .05 .05}
SetPref PreviewLightArchive ""

# environment light
SetPref PreviewEnvLight 0
SetPref PreviewEnvMap textures/ratEnv.tex
SetPref PreviewEnvKd 1
SetPref PreviewEnvDiffuseBlur 0.2
SetPref PreviewEnvKs 1

# scene
SetPref PreviewUpAxis Y
SetPref PreviewBackgroundTexture "textures/ratGrid.tex"
SetPref PreviewSceneSphere 1
SetPref PreviewSceneSphereTexture textures/ratEnv.tex

SetPref FlipbookFrameCount 32
SetPref FlipbookResolution 128
#SetPref FlipbookRenderer render
#SetPref FlipbookRenderer netrender 
SetPref FlipbookRenderer internal
#SetPref TextureRenderer "alfred -n 6 -rm %f"
#SetPref TextureRenderer "prman %f"
SetPref TextureRenderer "internal"
SetPref TextureResolution 512
SetPref SeqBegin 1
SetPref SeqEnd 100

# file preferences
SetPref SaveIcons attachable
SetPref SavedIconResolution 60
SetPref PreferFullPaths 0
SetPref DereferenceMasterDirectory 0
SetPref CheckpointQueueSize 0

# shader generation / compile settings
SetPref ShaderHeader {}
SetPref ShaderCompiler "default"
SetPref ShaderCompiler2 ""

# network view / graph preferences
SetPref ShowNetworkView 1
# keep nodes from separate networks in non-overlapping zones
SetPref ClusterNodes 1
# edge coloring by type
# first is the master switch:
SetPref GraphColorEdges 1
# then color preferences:
# (the first color is the normal color, the second is the highlight color)
SetPref GraphEdgeColors(surface) {#6688aa #88aaff}
SetPref GraphEdgeColors(shadingmodel) {#6688aa #88aaff}
SetPref GraphEdgeColors(shadingmodel_aov) {#6688aa #88aaff}
SetPref GraphEdgeColors(displacement) {#8888aa #aaaaff}
SetPref GraphEdgeColors(volume) {#8888aa #aaaaff}
SetPref GraphEdgeColors(light) {#aaaa88 #ffffaa}
SetPref GraphEdgeColors(color) {#aa8888 #ffaaaa}
SetPref GraphEdgeColors(manifold) {#88aa88 #aaffaa}

# Available node colors, make sure the three lists have the same number of
# elements
SetPref NodeColors {
    name     { None Red     Yellow  Green   Violet  Blue    }
    normal   { ""   #b03060 #cd853f #8fbc8f #9370db #3a5fcd }
    selected { ""   #db7093 #f4a460 #3cb371 #8a2be2 #0000cd }
}

# animated focus, relayout
# this is how long a change takes. set to zero to disable animation
SetPref GraphFocusDuration 400
SetPref GraphLayoutDuration 400

# if you want to see warnings from shader compiles, set this to your
# desired loglevel, e.g. WARNING
SetPref CompilerWarningLogLevel ""

# embed slim info as meta info inside of slim shaders
# this is recommended when using Slim with RenderMan for Maya
SetPref EmbedSlimData 1

# deprecated preferences
SetPref OrganizeByVendor 0
SetPref PreferVSlider 0
SetPref ShowHub 0
SetPref GenerateSli 0; # 1 -> glimpse compatibility.
# Use workspace Globalize to find an output path instead of
# writing (and creating) the directory specified in the workspace.
# Old, potentially dangerous and deprecated, don't enable unless you
# really know you want this
SetPref OldOutputPathLogic 0

LockPref RManCtls 1

if {[::Slim::GetClientMode] == "mtor"} {
    # TOR.ini will have been loaded, so we have available
    # all the WSSubdir.tor* directories here
    #
    # controls default master reference for functions that can
    # be attached to scene objects. If you have lots of users
    # working in the same area, you might uncomment the following:
    #SetPref DefaultMasterRef {$::torShaders/$::USER/$::INSTANCENAME}
    #
    # You may wish to include the unique instance id in your shader name.
    # This will prevent any shader name conflicts between appearances, and
    # can be done by uncommenting the following:
    #SetPref DefaultMasterRef {$::torShaders/${::INSTANCENAME}_$::INSTANCEID}
    #
    # These variables are predefined. You can define additional
	# variables within the SetInstanceExpressionContext procedure
    # (in SlimExpression.tcl). By default, this procedure defines
    # the PALETTENAME variable, which set to be the label of the
    # appearance's palette.

    SetPref DefaultMasterRef {$::torShaders/$::INSTANCENAME}
} else {
    # In this other case, instead, slim is running standalone
    # or is serving some non-MtoR client

    # File naming for sessions,
    # an appropriate filename extension will be added
    # Session filename
    SetPref SessionFileName {$STAGE}
    # Default session filename
    SetPref DefaultSessionFileName {default}
    # Session key filename
    SetPref SessionKeyName  {$FILEBASE}
    # Default session key filename
    SetPref DefaultSessionKeyName {untitled}

    ## WSSubdir. - each item matching WSSubdir.* is considered
    #   an abstract resource directory reference.  These
    #   references can be used in tcl scripts to refer to
    #   various RAT file types. As shipped, the values
    #   represent subdirectory references relative to the
    #   workspace root. If you prefer absolute references,
    #   prepend $WSRoot/ to the default values.
    #   (eg: rib -> {$WSRoot/rib} ).
    #

    SetPref WSSubdir.slimPalettes    {slim/palettes}
    SetPref WSSubdir.slimSessions    {slim/sessions}
    SetPref WSSubdir.slimSessionKeys {slim/sessions}
    SetPref WSSubdir.slimShaders     {renderman/$STAGE/slimshaders}
    SetPref WSSubdir.slimTextures    {renderman/textures}
    SetPref WSSubdir.slimTmps        {slim/tmp/$STAGE}

    # The use of bracket expressions here guarantees us that the $STAGE
    # variable above will be substituted appropriately to reflect the changes
    # of scene that might have been happening on the client side
    #
    
    #SetPref DefaultMasterRef {\$PROJ/$::slimShaders/$::USER/$::INSTANCENAME}
    #SetPref DefaultMasterRef {\$PROJ/$::slimShaders/${::INSTANCENAME}_$::INSTANCEID}
    SetPref DefaultMasterRef {\$PROJ/$::slimShaders/$::INSTANCENAME}
}

# This controls whether to make use of file references stored in template hints
# when loading a template that hasn't been registered
SetPref UseTemplateHintFileReferences 1

# These preferences control how Slim keeps appearance names unique.
# UniqueNameDomain describes how the scope in which names are unique.
# Valid options are:
#  - session : appearances in current session
#  - palette : appearances in a palette
#  - group   : appearances in a group
#  - history : all compiled appearances in the shading directory
#
# Names are initially unique, but are only continuously checked
# when MaintainUniqueNames is turned on.
#
# MaintainUniqueNames is only valid for UniqueNameDomains other than
# history.  For these domains, it is recommended that you include the
# instance id in the master name (see above).  The following settings 
# describe the behavior of previous slim releases:
#
# SetPref UniqueNameDomain history
# SetPref MaintainUniqueNames 0
#
# But we recommend using these settings:

SetPref UniqueNameDomain session
SetPref MaintainUniqueNames 1

# Default txmake settings
# These are classified by subtype (as referenced in template)
SetPref TxmakeArgs(environment) { -envlatl -smode black -tmode black -resize up}
SetPref TxmakeArgs(reflection) { -smode black -tmode black -resize up}
SetPref TxmakeArgs(shadow) { -shadow -smode black -tmode black -resize none}
SetPref TxmakeArgs(texture) { -smode periodic -tmode periodic -resize up-}

# this is the color for read-only palettes
LockPref ROColor #8080a0

# SlimAttachableMap:
#   describes the association between custom Slim template types
#   and known attachable appearance types:
#	surface, displacement, volume, light, ribbox, tclbox, 
#	ensemble, mapgen, dso, archiver
#   If you develop a new Slim template type that requires attachment
#   semantics, simply add a SlimAttachableMap entry of the form:
#
#	SetPref SlimAttachableMap(yourtype) systemtype
#
SetPref SlimAttachableMap(shadingmodel) surface
SetPref SlimAttachableMap(shadingmodel_aov) surface
SetPref SlimAttachableMap(visualizer) surface
SetPref SlimHiddenTemplateTypes visualizer

# Library Palettes
# These palettes are used to store a library of reusable shaders

# This controls if palettes should be forced read-only on load
SetPref ReadOnlyLibrary 0

# This preference specifies the list of "sets" of library palettes
# Sets will be loaded in the order you specify
#
SetPref LibraryPaletteSets { personal }

# start with a specification for a personal library palette
# stored within the preferences directory
#
set personalLibDir [file join [RATGetDir prefs] palettes]
if ![file exists $personalLibDir] {
    # create directory if it doesn't exist
    file mkdir $personalLibDir
}
SetPref LibraryPaletteDir(personal) $personalLibDir

# this specifies that a palette MyLibrary.splt will
# be used as a library palette, will operate in "copy" mode,
# and will be created for the user if it doesn't already exist:
#
SetPref LibraryPalettes(personal) {
    MyLibrary.splt {
	mode copy
	create 1
    }	
}

# this controls whether library palette members are shown
# with templates in the "Create" global smart palettes
#
SetPref IncludeLibraryInSmartPalettes 1

# Smart Palettes
# These smart palettes are always shown in the palette editor
# and are system-wide. The format is the same as what is saved
# in a palette file.
# 
set browseAttachablePalettes {
    smartpalette Attachable {
	criterion attachmenttype {isNot {}}
	state closed
	smartpalette Selected {
	    criterion clientSelected {isTrue}
	}
	smartpalette Surfaces {
	    criterion attachmenttype {is surface}
	}
	smartpalette Displacements {
	    criterion attachmenttype {is displacement}
	}
	smartpalette Lights {
	    criterion attachmenttype {is light}
	}
	smartpalette Volumes {
	    criterion attachmenttype {is volume}
	}
	smartpalette Other {
	    criterion attachmenttype {isNot surface}
	    criterion attachmenttype {isNot displacement}
	    criterion attachmenttype {isNot light}
	    criterion attachmenttype {isNot volume}
	}
    }
}    

set createAttachablePalettes {
    smartpalette Attachable {
	criterion attachmenttype {isNot {}}
	state closed
	smartpalette Surfaces {
	    criterion attachmenttype {is surface}
	}
	smartpalette Displacements {
	    criterion attachmenttype {is displacement}
	}
	smartpalette Lights {
	    criterion attachmenttype {is light}
	}
	smartpalette Volumes {
	    criterion attachmenttype {is volume}
	}
	smartpalette Other {
	    criterion attachmenttype {isNot surface}
	    criterion attachmenttype {isNot displacement}
	    criterion attachmenttype {isNot light}
	    criterion attachmenttype {isNot volume}
	}
    }
}    

set subordinatePalettes {
    smartpalette Subordinate {
	criterion attachmenttype {is ""}
	state closed
	smartpalette Floats {
	    criterion outputtypes {include float}
	    state closed
	    smartpalette Maps {
		criterion tags {include map}
	    }
	    smartpalette Pattern {
		criterion tags {include pattern}
	    }
	    smartpalette Trace {
		criterion tags {include trace}
	    }
	    smartpalette Insertable {
		criterion tags {include insertable}
	    }
	    smartpalette Utility {
		criterion tags {include utility}
	    }
	}
	smartpalette Colors {
	    criterion outputtypes {include color}
	    state closed
	    smartpalette Maps {
		criterion tags {include map}
	    }
	    smartpalette Pattern {
		criterion tags {include pattern}
	    }
	    smartpalette Trace {
		criterion tags {include trace}
	    }
	    smartpalette Insertable {
		criterion tags {include insertable}
	    }
	    smartpalette Utility {
		criterion tags {include utility}
	    }
	}
	smartpalette "Shading Components" {
	    criterion outputtypes {include shadingcomponent}
	}
	smartpalette Manifolds {
	    count any
	    criterion outputtypes {include manifold}
	    criterion outputtypes {include manifoldn}
	}
	smartpalette Geometry {
	    count any
	    criterion outputtypes {include point}
	    criterion outputtypes {include normal}
	    criterion outputtypes {include vector}
	}
    }
}

SetPref SmartPalettes(browse) "$browseAttachablePalettes $subordinatePalettes"
SetPref SmartPalettes(create) "$createAttachablePalettes $subordinatePalettes"


# These preferences declare the Smart Palette (referenced by label) to use
# when browsing appearances for connections by type (e.g. in the property menu)
# This is only necessary if you want to see nested smart palettes in the
# connection menu for the given type. Any types not specified here will
# display a menu without any nested smart palettes.
# 
SetPref SmartPaletteForType(color) Colors
SetPref SmartPaletteForType(float) Floats
	
# optional/replaceable slim templates ...................................
# extensions of type slimtmplt are loaded when needed/used
# we suggest that you adopt a particular level of granularity for
# your custom templates with these considerations in mind:
#   - slim supports multiple templates per file
#   - versioning and lazy loading is most efficient when a
#     single template (and possible all its versions) live
#     in a single file.
#   - lots of files can be an organizational burden
#   - some templates change frequently, others never.
#
# variable lazyTemplateList
#   here we construct a list to pass to ::Slim::RegisterLazyTemplates
#   the structure of the lazyTemplateList is a list of pairs:
#	1. slim file containing one or more template definitions
#	2. a list of lists, each decribing an individual template:
#	    1. templateID 2. template type  3. menu label 4. tags 5. icons
#
#   The template type can specified in two formats: either a single word
#   specifying the type of the single output of a template or the description of
#   a template interface: a template interface specifies the type of templates
#   with multiple output types, like this:
#     {outputs {float color}}
#   It can also specify the types for inputs flagged as defaultinput 1 in the
#   template description, so that these templates will appear in the Insert
#   menus in Slim. Here is an example:
#     {outputs {float} input {floats}}
#   which would be appropriate for the Float Remap node.
#   Tags can be used as a criterion in smart palettes, we do this in the smart
#   palettes specified above
#   The format for the icons is a list of pairs, the first specifying the output
#   property the icon refers to and the second specifying the icon itself.
#   The most common case is the following
#   {{} {file myIcon.gif}}
#   this means: all outputs use the icon stored in the file to be found in the
#   resource directories (specified in the ResourceDirs preference)
#
set lazyTemplateList {

  shadingmodels_delux.slim {
    { pixar,DeluxSM#1		shadingmodel_aov Delux		    shader }
  }

  shadingmodels.slim {
    { pixar,Blinn#2		shadingmodel_aov Blinn		    {} }
    { pixar,Glass#1		shadingmodel_aov Glass		    {} }
    { pixar,Gooch#1		shadingmodel_aov Gooch		    {} }
    { pixar,Matte#1		shadingmodel_aov Matte	            {} }
    { pixar,Plastic#1		shadingmodel_aov Plastic            {} }
    { pixar,Skin#3		shadingmodel_aov Skin		    {} }
    { pixar,Velvet#2		shadingmodel_aov Velvet		    {} }
  }

  shadingmodels_layering.slim {
    { pixar,Layer#3		shadingmodel_aov "Layer General"    layer }
    { pixar,LayerUltimo#1	shadingmodel_aov "Layer"	    layer }
  }

  shadingmodels_simple.slim {
    { pixar,AdditiveFX#1	shadingmodel	"Additive FX"       utility }
    { pixar,Constant#0		shadingmodel	Constant	    utility }
    { pixar,Default#0		shadingmodel	Default		    utility }
    { pixar,Mix#0		shadingmodel	Mix		    utility }
  }

  components.slim {
    { pixar,CombineSC#1		     shadingcomponent Combine		utility }
    { pixar,AmbientSC#0		     shadingcomponent Ambient		{} }
    { pixar,DiffuseSC#0		     shadingcomponent Diffuse		{} }
    { pixar,SpecularSC#0	     shadingcomponent Specular		{} }
    { pixar,AnisotropicSC#0	     shadingcomponent Anisotropic	{} }
    { pixar,FresnelSC#0	             shadingcomponent Fresnel	        utility }
    { pixar,ReflectionSC#0	     shadingcomponent Reflection	{} }
    { pixar,RefractionSC#0	     shadingcomponent Refraction	{} }
    { pixar,BackScatteringSC#0	     shadingcomponent "Back Scattering"	{} }
    { pixar,ThinTranslucenceSC#0     shadingcomponent "Thin Translucence" {} }
    { pixar,RimSC#0    		     shadingcomponent Rim		{} }
    { pixar,IncandescenceSC#0        shadingcomponent Incandescence	{} }
    { pixar,SubsurfaceScatteringSC#1 shadingcomponent "Subsurface Scattering" {} }
  }

  colors.slim {
    { pixar,SurfaceColor#0	  color	"Surface Color"		    utility }
    { pixar,SurfaceOpacity#0	  color	"Surface Opacity"	    utility }
    { pixar,FloatToColor#0	  {inputs {float} outputs {color}} "Float To Color" utility }
    { pixar,MixColors#0		  {inputs {color} outputs {color}} "Mix Colors"     utility }
    { pixar,CombineColors#0	  {inputs {color} outputs {color}} "Combine Colors" utility }
    { pixar,CRemap#0		  {inputs {color} outputs {color}} Remap            utility }
    { pixar,Marble#0		  color	Marble			    pattern }
    { pixar,ColorRamp#0		  color	Ramp			    pattern }
    { pixar,ColorAdjust#0	  {inputs {color} outputs {color}} Adjust  utility }
    { pixar,ColorCorrect#0	  {inputs {color} outputs {color}} Correct utility }
    { pixar,ColorInvert#0	  {inputs {color} outputs {color}} Invert  utility }
    { pixar,ShadingModelToColor#0 {inputs {shadingmodel} outputs {color}} "Shading Model To Color" utility }
    { pixar,ColorBuild#0	  {inputs {float} outputs {color}}	  "Build a Color"	   utility }
    { pixar,RSLVarsF#0		  float	"RSL State Variables"	    utility }
    { pixar,RSLVarsC#0		  color	"RSL State Variables"	    utility }
  }

  floats.slim {
    { pixar,SplineF#0		{inputs {float} outputs {float}} Spline          pattern }
    { pixar,F_Combine#0		{inputs {float} outputs {float}} Combine         utility }
    { pixar,Waves1D#0		float                            Waves1D         pattern }
    { pixar,Shapes#0		float                            Shapes          pattern }
    { pixar,ColorToGray#0	{inputs {color} outputs {float}} "Color To Gray" utility }
    { pixar,RemapF#0		{inputs {float} outputs {float}} Remap           utility }
    { pixar,Worley#0		float	Worley			    pattern }
    { pixar,Distance#0		float	Distance		    pattern }
    { pixar,Time#0		float	Time			    pattern }
    { pixar,FacingForward#1	float	"Facing Forward"	    pattern }
    { pixar,FacingDirection#0	float	"Facing Direction"	    pattern }
    { pixar,FRandomTiler#0	float	"Random Tiler"		    pattern }
    { pixar,VectorLength#0	float	Length			    pattern }
  }

  fractals.slim {
    { pixar,F_WaveletNoise#0	float   "Wavelet Noise"             pattern }
    { pixar,F_Fractal#0		float	Fractal			    pattern }
    { pixar,C_Fractal#0		color	Fractal			    pattern }
    { pixar,V_Fractal#0		vector	Fractal			    pattern }
  }

  environments.slim {
    { pixar,Blobby#1		environment Blobby		    {} }
    { pixar,EnvMap#4		environment "Environment Map"	    {} }
  }

  displacements.slim {
    { pixar,SimpleDisplacement#0 displacement	Simple		    {} }
    { pixar,CombineDisplacements#1 displacement	Combine		    {} }
  }

  lgNaa.slim {
    { pixar,Brownian#0		float		Brownian	    pattern }
    { pixar,VBrownian#0		vector		Brownian	    pattern }
    { pixar,Turbulence#0	float		Turbulence	    pattern }
    { pixar,OakGrainColor#0	{outputs {float color}}	OakGrain	    pattern }
  }

  lists.slim {
    { pixar,CombineFloatList#0	{inputs {float} outputs {float}} "Combine Float List"  utility }
    { pixar,CombineColorList#0	{inputs {color} outputs {color}} "Combine Color List"  utility }
  }

  manifolds.slim {
    { pixar,SurfacePoint#0	manifold	"Surface Pt"	    {} }
    { pixar,WorldPoint#0	manifold	"World Pt"	    {} }
    { pixar,CurrentPoint#0	manifold	"Current Pt"	    {} }
    { pixar,MScale#0		{inputs {manifold} outputs {manifold}} Scale {} }
    { pixar,ST#0		manifold	ST		    {} }
    { pixar,Tile#0		{inputs {manifold} outputs {manifold}}	Tile		    {} }
    { pixar,Warp#0		{inputs {manifold} outputs {manifold}} Warp  {} }
    { pixar,Shear#0		{inputs {manifold} outputs {manifold}} Shear {} }
    { pixar,Projection#2	manifold	Projection	    {} }
    { pixar,SurfacePointN#0	manifoldn	"Surface Pt N"	    {} }
  }

  noises.slim {
    { pixar,FNoise#0		float		Noise		    pattern }
    { pixar,VNoise#0		vector		Noise		    pattern }
    { pixar,CNoise#0		color		Noise		    pattern }
    { pixar,GrayCells#0		float		"Gray Cells"	    pattern }
    { pixar,ColorCells#0	color		"Color Cells"	    pattern }
  }

  raytrace.slim {
    { pixar,RayTrace#0		color		Trace		     trace }
    { pixar,RayTraceHitTest#0	float		"Hit Test"	     trace }
    { pixar,RayTraceShadow#0	color		"Trace Shadow"	     trace }
    { pixar,RayTraceGetValuecolor#0 color	"Trace Color Value"  trace }
    { pixar,RayTraceGetValuepoint#0 point	"Trace Point Value"  trace }
    { pixar,RayTraceGetValuefloat#0 float	"Trace Float Value"  trace }
    { pixar,RayTraceGetValuenormal#0 normal	"Trace Normal Value" trace }
    { pixar,PseudoArea#0	light		"Pseudo Area"	     trace }
    { pixar,IndirectIllum#1	color		"Indirect Illum"     trace }
    { pixar,Occlusion#1		float		Occlusion	     trace }
  }

  reflections.slim {
    { pixar,ReflectionMap#1	color		"Reflection Map"      map }
    { pixar,EnvironmentMap#2	color		"Environment Map"     map }
    { pixar,CollectReflections#0  color		"Collect Reflections" trace }
    { pixar,CollectRefractions#0  color		"Collect Refractions" trace }
  }
  
  ristate.slim {
      {pixar,AOVcolor#1		color		"Color AOV"         ristate }
      {pixar,AOVfloat#1		float		"Float AOV"         ristate }
      {pixar,AOVpoint#1		point		"Point AOV"         ristate }
      {pixar,AOVnormal#1	normal		"Normal AOV"        ristate }
      {pixar,AOVvector#1	vector		"Vector AOV"	    ristate }
      
      {pixar,PVcolor#0		color		"Color PrimVar"	    ristate }
      {pixar,PVfloat#0		float		"Float PrimVar"	    ristate }
      {pixar,PVpoint#0		point		"Point PrimVar"	    ristate }
      {pixar,PVnormal#0		normal		"Normal PrimVar"    ristate }
      {pixar,PVvector#0		vector		"Vector PrimVar"    ristate }
	
      {pixar,color_Attribute#0	color		"Color Attribute"   ristate }
      {pixar,float_Attribute#0	float		"Float Attribute"   ristate }
      {pixar,point_Attribute#0	point		"Point Attribute"   ristate }
      {pixar,normal_Attribute#0	normal		"Normal Attribute"  ristate }
      {pixar,vector_Attribute#0	vector		"Vector Attribute"  ristate }
	
      {pixar,color_Option#0	color		"Color Option"	    ristate }
      {pixar,float_Option#0	float		"Float Option"	    ristate }
      {pixar,point_Option#0	point		"Point Option"	    ristate }
      {pixar,normal_Option#0	normal		"Normal Option"	    ristate }
      {pixar,vector_Option#0	vector		"Vector Option"	    ristate }
  }

  slbox.slim {
    { pixar,F_SLBox#0		float		"SL Box"    utility }
    { pixar,C_SLBox#0		color		"SL Box"    utility }
    { pixar,V_SLBox#0		vector		"SL Box"    utility }
    { pixar,M_SLBox#0		manifold	"SL Box"    {} }
    { pixar,S_SLBox#0		shadingmodel	"SL Box"    utility }
  }

  spline.slim {
    { pixar,ColorSpline#0	color		Spline	    pattern }
  }

  textures.slim {
    { pixar,F_ImageFile#1	float		"Image File"	    map }
    { pixar,SMImageFile#2	shadingmodel	"Image File"	    utility }
    { pixar,ImageFile#2		color		"Image File"	    map }
  }

  trivial.slim {
    { pixar,SharedFloat#0	 {inputs {float}  outputs {float}}		"Shared Float"	    utility }
    { pixar,SharedColor#0	 {inputs {color}  outputs {color}}		"Shared Color"	    utility }
    { pixar,SharedPoint#0	 {inputs {point}  outputs {point}}		"Shared Point"	    utility }
    { pixar,SharedVector#0	 {inputs {vector} outputs {vector}}		"Shared Vector"	    utility }
    { pixar,SharedNormal#0	 {inputs {normal} outputs {normal}}		"Shared Normal"	    utility }
    { pixar,SharedManifold#0	 {inputs {mainfold} outputs {manifold}}	        "Shared Manifold"   utility }
    { pixar,SharedShadingModel#0 {inputs {shadingmodel} outputs {shadingmodel}}	"Shared Shading Model"	utility }
  }

  vectors.slim {
    { pixar,IncidentDirection#0	vector		"Incident Direction"	{} }
    { pixar,ViewDirection#0	vector		"View Direction"    	{} }
    { pixar,UDirection#0	vector		"U Direction"    	{} }
    { pixar,VDirection#0	vector		"V Direction"    	{} }
    { pixar,SurfaceNormal#0	normal		"Surface Normal"	{} }
    { pixar,SurfaceNormalF#0	normal		"Surface Normal (fwd)"	{} }
    { pixar,SurfaceNormalV#0	vector		"Surface Normal Direction" {} }
    { pixar,SurfaceNormalFV#0	vector		"Surface Normal Direction (fwd)" {} }
    { pixar,ShadingNormal#0	normal		"Shading Normal"	{} }
    { pixar,ReflectionDirection#0 vector	"Reflection Direction"	{} }
    { pixar,RefractionDirection#0 vector	"Refraction Direction"	{} }
    { pixar,ArbitraryDirection#0  vector	"Arbitrary Direction"	{} }
    { pixar,ShadingDirection#0	vector		"Shading Direction" {} }
  }

  volumes.slim {
    { pixar,Fog#0		volume		Fog		    {} }
    { pixar,Smoke#0		volume		Smoke		    {} }
  }

  bake.slim {
    { pixar,BakeableFloat#0 {inputs {float}  outputs {float}} "Bakeable" utility }
    { pixar,BakeableColor#0 {inputs {color}  outputs {color}} "Bakeable" utility }
  }

  mtor/foundation.slim {
    { pixar,Archiver#0        archiver        Archiver        {} }
    { pixar,Ensemble#0        ensemble        Ensemble        ensemble }
    { pixar,EnsembleAdaptor#0 ensemble        EnsembleAdaptor adaptor }
    { pixar,SurfaceAdaptor#0  surface         SurfaceAdaptor  adaptor }
    { pixar,LightAdaptor#0    light           LightAdaptor    adaptor } 
    { pixar,RIBBox#0          ribbox          RIBBox          {} }
    { pixar,RIBBoxAdaptor#0   ribbox          RIBBoxAdaptor   adaptor }
    { pixar,Bake#0            mapgen          Bake            bake }
    { pixar,Depth#0           mapgen          Depth           depth }
    { pixar,DepthMask#0       mapgen          DepthMask       depth }
    { pixar,Environment#0     mapgen          Environment     environment }
    { pixar,OcclusionMapGen#0 mapgen          OcclusionMapGen occlusion }
    { pixar,PhotonMap#0       mapgen          PhotonMap       photon }
    { pixar,PointShadow#0     mapgen          PointShadow     shadow }
    { pixar,Reference#0       mapgen          Reference       reference }
    { pixar,Reflection#0      mapgen          Reflection      {} }
    { pixar,Shadow#0          mapgen          Shadow          shadow }
    { pixar,SoftShadow#0      mapgen          SoftShadow      shadow }
    { pixar,TCLBox#0          tclbox          TCLBox          {} }
  }

  mtor/lights.slim {
    { pixar,Point#2		light		Point		    {} }
    { pixar,Distant#2		light		Distant		    {} }
    { pixar,Spot#3		light		Spot		    {} }
    { pixar,EnvironmentLight#1	light		Environment	    {} }
    { pixar,Ambient#0		light		Ambient		    {} }
  }

  mtor/maps.slim {
    { pixar,CShadowMap#0	color		"Shadow Map"	     map }
    { pixar,CShadowMapPointlight#0 color	"Point Shadow Map"   map }
    { pixar,CSoftShadowMap#0	color		"Soft Shadow Map"    map }
    { pixar,ShadowMap#1		float		"Shadow Map"	     map }
    { pixar,SoftShadowMap#1	float		"Soft Shadow Map"    map }
    { pixar,PhotonMapCaustic#0	color		"Caustic Photon Map" map }
    { pixar,PhotonMapGlobal#0	color		"Global Photon Map"  map }
    { pixar,OcclusionMap#1	color		"Occlusion Map"	     map }
  }  

  mtor/maya.slim {
    { pixar,AgeNormPP#0		float		"Maya Particle Age" utility }
    { pixar,MayaUV#0		manifold	"Maya UV"	    maya }
    { pixar,MayaUVSet#0		manifold	"Maya UV Set"	    maya }
    { pixar,MayaProj#0		manifold	"Maya Projection"   maya }
  }

  rfm/ensemble_rfm.slim {
    { pixar,RFMEnsemble#0       ensemble        Ensemble            ensemble }
  }

  rfm/manifolds_rfm.slim {
    { pixar,MayaPlace2d#0       manifold        MayaPlace2d         maya }
  }

  rfm/maps.slim {
    { pixar,RFMShadowMap#0        color     "Shadow Map"         map }
    { pixar,RFMShadowMapPointlight#0 color  "Point Shadow Map"   map }
    { pixar,RFMSoftShadowMap#0    color     "Soft Shadow Map"    map }
  }

  rfm/mayatextures.slim {
    { pixar,F_MayaImageFile#1	float		"Maya Image File"    map }
    { pixar,SMMayaImageFile#2	shadingmodel	"Maya Image File"    utility }
    { pixar,MayaImageFile#2	color		"Maya Image File"    map }
  }
  
  legacy/shadingmodels_arman.slim {
    { pixar,BrushedMetal#0	shadingmodel	"Brushed Metal"	    legacy }
    { pixar,Cel#0		shadingmodel	Cel		    legacy }
    { pixar,Ceramic#0		shadingmodel	Ceramic		    legacy }
    { pixar,Clay#0		shadingmodel	Clay		    legacy }
    { pixar,ThinPlastic#0	shadingmodel	"Thin Plastic"	    legacy }
  }

  legacy/rat60.slim {
    { pixar,CombineDisplacements#0  displacement "Combine Displacements" {} }
  }

  legacy/rat65.slim {
    { pixar,Diffuse#1		color		"Diffuse"	    legacy }
    { pixar,Specular#1		color		"Specular"	    legacy }
    { pixar,Blobby#0		environment	"Blobby"	    legacy }
    { pixar,EnvMap#2		environment	"Environment Map"   legacy }
    { pixar,EnvironmentLight#0	light		"Environment Light" legacy }
    { pixar,Point#1		light		Point		    legacy }
    { pixar,Distant#1		light		Distant		    legacy }
    { pixar,Spot#2		light		Spot 		    legacy }
    { pixar,SubsurfaceScatteringSC#0 shadingcomponent "Subsurface Scattering" legacy }
  }

  legacy/rat65-shadingmodels.slim {
    { pixar,Layer#1		shadingmodel	Layer		    legacy }
    { pixar,LayerOptimo#0	surface		"Layer Optimo"	    legacy }
    { pixar,IBI#1		shadingmodel	IBI		    legacy }
    { pixar,Matte#0		shadingmodel	Matte		    legacy }
    { pixar,Plastic#0		shadingmodel	Plastic	            legacy }
    { pixar,Metal#0		shadingmodel	"Simple Metal"	    legacy }
    { pixar,FresnelPlastic#0	shadingmodel	"Fresnel Plastic"   legacy }
    { pixar,Jewel#0		shadingmodel	Jewel		    legacy }
    { pixar,Blinn#1		shadingmodel	Blinn		    legacy }
    { pixar,Skin#2		shadingmodel	Skin	            legacy }
    { pixar,Gooch#0		shadingmodel	Gooch	            legacy }
    { pixar,Velvet#1		shadingmodel	Velvet	            legacy }
    { pixar,SwissArmy#1		shadingmodel	"Swiss Army"	    legacy }
    { pixar,Glass#0		shadingmodel	Glass	            legacy }
    { pixar,DIY#0		shadingmodel	DIY	    	    legacy }
  }

  legacy/slim70.slim {
    { pixar,CombineSC#0		shadingcomponent Combine            legacy }
    { pixar,DeluxSM#0		shadingmodel_aov Delux              legacy }
    { pixar,Layer#2		shadingmodel_aov "Layer General"    legacy }
    { pixar,LayerUltimo#0	shadingmodel_aov Layer              legacy }
    { pixar,EnvMap#3		environment "Environment Map"	    legacy }
    { pixar,Projection#1	manifold        Projection	    legacy }
    { pixar,IndirectLight#0	light		Indirect	    legacy }
    { pixar,OakGrain#0		float		OakGrain	    legacy }
  }

  legacy/textures.slim {
    { pixar,OcclusionMap#0	color		"Occlusion Map"	    legacy }
  }

  legacy/floats.slim {
    { pixar,Combine#0		float		"Combine"	    legacy }
    { pixar,FacingForward#0	float		"Facing Forward"    legacy }
    { pixar,F_ImageFile#0	float		"Image File"	    legacy }
    { pixar,ShadowMap#0		float		"Shadow Map"	    legacy }
    { pixar,SoftShadowMap#0	float		"Soft Shadow Map"   legacy }
  }

  legacy/colors.slim {
    { pixar,ImageFile#0		color		"Image File"	    legacy }
    { pixar,ImageFile#1		color		"Image File"	    legacy }
    { pixar,TraceReflections#0	color		"Trace Reflections" legacy }
    { pixar,TraceRefractions#0	color		"Trace Refractions" legacy }
    { pixar,ReflectionMap#0	color		"Reflection Map"    legacy }
    { pixar,EnvironmentMap#0	color		"Environment Map"   legacy }
    { pixar,EnvironmentMap#1	color		"Environment Map"   legacy }
    { pixar,EnvironmentMapPlus#0 color		"Environment Map Plus"	legacy }
    { pixar,Diffuse#0		color		"Diffuse"	    legacy }
    { pixar,Specular#0		color		"Specular"	    legacy }
  }

  legacy/shadingmodels.slim {
    { pixar,AddEnvMap#0		shadingmodel	"Add Env Map"	    legacy }
    { pixar,AddReflection#0	shadingmodel	"Add Reflection"    legacy }
    { pixar,AddRefraction#0	shadingmodel	"Add Refraction"    legacy }
    { pixar,AddRaytrace#0	shadingmodel	"Add Ray Trace"	    legacy }
    { pixar,IBI#0		shadingmodel	"IBI"		    legacy }
    { pixar,Skin#0		shadingmodel	"Skin"		    legacy }
    { pixar,Skin#1		shadingmodel	"Skin"		    legacy }
    { pixar,SMImageFile#0	shadingmodel	"Image File"	    legacy }
    { pixar,SMImageFile#1	shadingmodel	"Image File"	    legacy }
    { pixar,Layer#0		surface 	"Layer"		    legacy }
    { pixar,AdditiveFX#0	shadingmodel	"Additive FX"	    legacy }
    { pixar,Blinn#0		shadingmodel	"Blinn"		    legacy }
    { pixar,Velvet#0		shadingmodel	"Velvet"	    legacy }
  }

  legacy/raytrace.slim {
    { pixar,SwissArmy#0		shadingmodel	"Swiss Army"	    legacy }
    { pixar,IndirectIllum#0	color		"Indirect Illum"    legacy }
    { pixar,Occlusion#0		float		Occlusion           legacy }
  }

  legacy/misc.slim {
    { pixar,Projection#0	manifold	"Projection"	    legacy }
    { pixar,SurfPtLight#0	manifold	"Surface Pt Light"  legacy }
    { pixar,Spot#0		light		"Spot"		    legacy }
    { pixar,Spot#1		light		"Spot"		    legacy }
    { pixar,Distant#0		light		"Distant"	    legacy }
    { pixar,Point#0		light		"Point"		    legacy }
    { pixar,EnvMap#0		environment	"Env Map"	    legacy }
  }

}; # end of lazyTemplateList


# Invoke the lazy registration. You can call this same procedure
# from downstream slim.ini files to register your own templates
#
set legacyPattern "legacy*"
set mode [::Slim::GetClientMode]

if {$mode != "mtor"} {
    # mark all mtor-related templates as legacy
    lappend legacyPattern "mtor*"
}

if {$mode != "RenderMan_for_Maya"} {
    # mark rfm-related templates as legacy
    lappend legacyPattern "rfm*"
}

::Slim::RegisterLazyTemplates $lazyTemplateList -legacyPattern $legacyPattern


# Imported shaders
# This is only used in combination with MTOR
#
if {$mode == "mtor"} {
    # This table is used to register shaders and procedurals
    # and configure the "Import Appearance" menu (below)
    #
    set externalAppearanceList {
	{ ratCollector.slo           surface  "RAT Collector"  /Surface/Utility }
	{ Mondo.slo                  surface  "Mondo"          /Surface }
	{ smokeNfire.slo             surface  "Smoke and Fire" /Surface }
	{ magicSurf.slo              surface  "Magic Surface"  /Surface }
	{ cmarble.slo                surface  "CMarble"        /Surface }
	{ shinymetal.slo             surface  "Shiny Metal"    /Surface }
	{ spatter.slo                surface  "Spatter"        /Surface }
	{ stippled.slo               surface  "Stippled"       /Surface }
	{ stone.slo                  surface  "Stone"          /Surface }
	{ null.slo                   surface  "Null"           /Surface/Utility }
	{ defaultsurface.slo         surface  "Default"        /Surface/Utility }
	{ constant.slo               surface  "Constant"       /Surface/Utility }
	{ matte.slo                  surface  "Matte"          /Surface }
	{ plastic.slo                surface  "Plastic"        /Surface }
	{ glassrefr.slo              surface  "Traced Glass"   /Surface }
	{ aachrome.slo               surface  "Chrome"         /Surface }
	{ carpet.slo                 surface  "Carpet"         /Surface }
	{ wood.slo                   surface  "Wood"           /Surface }

	{ ratUberlight.slo           light    "UberLight"      /Light }
	{ mtorSpotLight.slo          light    "Spot"           /Light }
	{ mtorDirectionalLight.slo   light    "Directional"    /Light }
	{ ratBarnDoor.slo            light    "Barn Door"      /Light }
	{ ratEnvironment.slo         light    "Environment"    /Light }
	{ volumeSpot.slo             light    "Volume Spot"    /Light }
	{ magicLight.slo             light    "Magic Light"    /Light }
	{ disklight.slo              light    "Disk"           /Light }
	{ cylinderlight.slo          light    "Cylinder"       /Light }
	{ rectanglelight.slo         light    "Rectangle"      /Light }
	{ spherelight.slo            light    "Sphere"         /Light }
	{ linearlight.slo            light    "Linear"         /Light }
	{ indirectlight.slo          light    "Indirect"       /Light }
	{ causticlight.slo           light    "Caustic"        /Light }

	{ fog.slo                    volume   "Fog"            /Volume }
	{ depthcue.slo               volume   "Depth Cue"      /Volume }
	{ volumeSmoke.slo            volume   "Smoke"          /Volume }
	{ ratmosphere.slo            volume   "RATmosphere"    /Volume }

	{ plugins/mtorUltraFur.slim  RIBGen   "UltraFur"       /RIBGen }
	{ plugins/mtorFur.slim       RIBGen   "Fur"            /RIBGen }
	{ plugins/mtorFuzz.slim      RIBGen   "Fuzz"           /RIBGen }
	{ plugins/quadrics.slim      RIBGen   "Quadrics"       /RIBGen }
    }


    #
    #  "Import Appearance" menu initialization
    #

    # clear import menu
    ::Slim::ClearImportMenuDescriptions
    # register the external appearances listed above
    ::Slim::RegisterImportedAppearances $externalAppearanceList


    # This preference defines the structure of the "Import Appearance" menu
    # The contents (referenced using the "_menuDesc" macro) are defined above.
    # When referring to _menuDesc macros for this menu, you must use
    # the "Import" prefix.
    #
    SetPref ImportAppearanceMenu {
	{   _cascade Surface {
	    {_menuDesc Import/Surface}
	}
	}
	{   _cascade Light {
	    {_menuDesc Import/Light}
	}
	}
	{   _cascade Volume {
	    {_menuDesc Import/Volume}
	}
	}
	{   _cascade RIBGen {
	    {_menuDesc Import/RIBGen}
	}
	}
    }
} else {
    SetPref ImportAppearanceMenu {}
}

