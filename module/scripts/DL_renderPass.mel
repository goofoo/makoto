/*
	Copyright (c) 2006 soho vfx inc.
	Copyright (c) 2006 The 3Delight Team.
*/

/*
  Global variables
*/

/* The arrays returned by DL_getGeoTypeData. Updated before each render. */

global string $g_DL_geoTypes[];
global string $g_DL_geoPluginRequirements[];
global string $g_DL_geoCacheCommands[];
global string $g_DL_geoOutputCommands[];

// store name of camera for output geo
global string $ZHANG_curcamera;

// ----------------------------------------------------------------------------
// Utility procedures
//

/*
  getShadingGroups

  Returns the shading groups applied to the given shape.
*/
proc string[]
getShadingGroups( string $geo )
{
  string $groups[];

  /*
    We check connections on instObjGroups instead of just the shape as
    otherwise maya will return all the shaders for all the instances of the
    shape.
  */
  $groups = `listConnections
               -destination true
               -type "shadingEngine"
               ($geo + ".instObjGroups")`;

  if( size($groups) == 0 )
  {
    /*
      The above code doesn't work with per-face shader assignment. The good way
      to deal with those seems to be to find the instance number and then check
      for connections on .instObjGroups[$instanceNumber].objectGroups. However,
      finding the instance number seems O(N) (at least in mel, haven't checked
      the speed of the C API) and we don't currently export correct geometry
      for anything but the first instance if they don't use the same shaders.
      For these reason, we just assume an instance number of 0 here.
    */
    $groups = `listConnections
                 -destination true
                 -type "shadingEngine"
                 ($geo + ".instObjGroups[0].objectGroups")`;

    $groups = DL_stringArrayRemoveDuplicates( $groups );
  }

  return $groups;
}

/*
  Converts a material name into a shader name.
*/
proc string
materialShaderName( string $material )
{
  return DL_legalizeString($material);
}

proc string
shadingGroupsShaderName( string $shading_groups[], string $shader_type )
{
  string $name = "";
  int $has_shader = 0;

  int $i;
  for( $i = 0; $i < size($shading_groups); ++$i )
  {
    if( size($shading_groups) > 1 )
    {
      $name += "_" + $i + "_";
    }

    string $connections[] =
      `listConnections
        -source true
        ($shading_groups[$i] + "." + $shader_type + "Shader")`;

    if( size($connections) != 0 )
    {
      $name += materialShaderName( $connections[0] );
      
      if ($shader_type == "displacement")
      {
        $name += ("_" + $shader_type);
      }
      
      $has_shader = 1;
    }
  }

  if( !$has_shader )
    return "";

  /* Protect against very long file names which not all OS can handle. */
  if( size($name) > 192 )
  {
    string $end = substring( $name, 181, size($name) );
    string $hashed = `delightHash -hs $end`;
    $name = substring( $name, 1, 180 ) + $hashed;
  }

  return $name;
}

global proc int
buildShader(string $shader_name,
            string $shading_groups[], 
            string $shader_type, 
            string $shaderdl_opts, 
            string $sl_path, 
            string $sdl_path,
            int $write_to_disk )
{
  if ($sdl_path == "")
  {
    error("No shader output path specified\n");
    return -1;
  }

  string $sl_file_path = $sl_path + "/" + $shader_name + ".sl";
  string $sdl_file_path = $sdl_path + "/" + $shader_name + ".sdl";

  // See if we couldn't just skip recompilation.
  if( `delightNodeWatch -isclean $shader_name` &&
      `filetest -r $sdl_file_path` )
  {
    return 0;
  }
  
  // Attempt to generate shader

  if( $shader_name == "" )
    return -1;

  string $sl_code = DL_translateMayaToSl(
    $shader_name, $shading_groups, $shader_type );

  if (size($sl_code) == 0)
    return 0;

  if( !$write_to_disk )
    return 0;

  // Create .sl file
  int $file_id = fopen($sl_file_path, "w");
  
  if ($file_id == 0)
  {
    error("Could not create shader file:\"" + $sl_file_path + "\"\n");
    return -1;
  }

  fprint($file_id, $sl_code);
  fclose($file_id);

  // Now compile the shader
  string $sdl_output;
  string $cmd;
  
  $cmd = "shaderdl ";
  $cmd += $shaderdl_opts;
  $cmd += " -DSHADER_TYPE_" + $shader_type;

  string $incl_paths[] = DL_getSLincludePath();
  for( $incl_path in $incl_paths )
  {
    $cmd += " -I \"" + $incl_path + "\"";
  }

  $cmd += " -o \"";
  $cmd += $sdl_file_path;
  $cmd += "\" \"";
  $cmd += $sl_file_path;
  $cmd += "\" 2>&1\n";
  
  print ("Compiling shader for " + $shading_groups[0] + " :");
  print $cmd;

  $sdl_output = DL_system($cmd);
  if ($sdl_output != "")
  {
    error(  "compilation of " 
          + $shader_type 
          + " shader of shading group \"" 
          + $shading_groups[0] 
          + "\" failed: "
          + $sdl_output
          + "\n");

    return -1;
  }    

  return 0;
}

proc string
getTranslatedMayaShaderName(string $geo_name, string $shader_type)
{
  string  $shader_name;

  if ($shader_type == "surface" ||
      $shader_type == "displacement" ||
      $shader_type == "miMaterial")
  {
    string  $shading_groups[];

    $shading_groups = getShadingGroups( $geo_name );

    if (size($shading_groups) != 0)
    {
      $shader_name = shadingGroupsShaderName( $shading_groups, $shader_type );
    }
    else
      $shader_name = "";
  }
  else
    $shader_name = "";

  return $shader_name;
}

global proc
outputTranslatedMayaShader(
  string $sdl_name,
  string $shader_type,
  string $extra_command_args )
{
  // from DL_translateMayaToSL.mel
  global string $g_shaders_with_params_name[];
  global string $g_shaders_with_params_flags[];

  string $sdl_path = DL_getExpandedAbsoluteOutputPath(
    DL_getShadersPath(), 
    "",
    "");

  $sdl_path = DL_createDir($sdl_path + "/OBJ");  

  string $shader_command;

  switch($shader_type)
  {
    case "surface":
    case "miMaterial":
      $shader_command = "RiSurface ";
      break;

    case "displacement":
      $shader_command = "RiDisplacement ";
     break;

    case "light":
      $shader_command = "RiLightSource ";
      break;

    case "arealight":
      $shader_command = "RiAreaLightSource ";
      break;

    default:
      // unknown shader type
      return;
  }

  $shader_command += ("-n \"" + $sdl_path + "/" + $sdl_name +"\"");
  $shader_command += $extra_command_args;

  // See if this shader has extra parameters which need to be fetched.
  int $shader_idx =
    DL_stringArrayIndexOf( $sdl_name, $g_shaders_with_params_name );

  if( $shader_idx != -1 )
  {
    string $shader_params = $g_shaders_with_params_flags[$shader_idx];
    
    if( match("#insertcompositeattrib#", $shader_params) != "")
    {
      $shader_params = substitute("#insertcompositeattrib#", $shader_params, "");
      $shader_command = 
        "RiAttribute -n \"hider\" -p \"composite\" \"int\" \"0\"; " +
        $shader_command;
    }
      
    $shader_command += $shader_params;
  }
  
  eval($shader_command);
}

proc float
convertUIunitsToCM(float $value)
{
  string  $value_string;
  string  $result_string;

  $value_string = $value;

  $result_string = `convertUnit -toUnit "cm" $value_string`;

  // depending on the units set in the user's preferences there may or may not
  // be a "cm" at the end of the result.  If there is then trim it off.
  if (endsWith($result_string, "cm"))
  {
    $result_string = startString($result_string, size($result_string)-2);
  }

  return $result_string;
}

proc
getLayersContaining(string $geo_name, string $geo_layers[])
{
  string $parent[];
  $parent = `listRelatives -parent $geo_name`;
  
  if (size($parent) != 0)
  {
    string $layers[];
    $layers = `listConnections ($parent[0] + ".renderLayerInfo")`;
    
    $geo_layers = stringArrayCatenate($geo_layers, $layers);
    getLayersContaining($parent[0], $geo_layers);
  }
}

proc string
getDepthMapFilename(string $light_name)
{
  string $file = DL_getShadowMapsPath() + "/";
  int $first_append;
  $first_append = 1;
  
  if (attributeExists("dmapName", $light_name))
  {
    $file += getAttr($light_name + ".dmapName");
    $first_append = 0;    
  }
  
  if (attributeExists("dmapSceneName", $light_name))
  {
    if (getAttr($light_name + ".dmapSceneName") == 1)
    {
      if ($first_append == 1)
      {
        $first_append = 0;
      }
      else
      {
        $file += "_";
      }
      
      $file += "<scene>";
    }
  }
  
  if (attributeExists("dmapLightName", $light_name))
  {
    if (getAttr($light_name + ".dmapLightName") == 1)
    {
      if ($first_append == 1)
      {
        $first_append = 0;
      }

      $file += "<shape_name>";
    }
  }

  if (attributeExists("dmapFrameExt", $light_name))
  {
    if (getAttr($light_name + ".dmapFrameExt") == 1)
    {
      if ($first_append == 1)
      {
        $first_append = 0;
      }
      else
      {
        $file += "_";
      }      

      $file += "#";
    }
  }
  
  $file += ".<ext>";
  $file = DL_getExpandedFilename($file, $light_name, "", "shadowmap");
  
  return $file;
}

proc string
createAreaLightPlane()
{
  string $area_light_plane = "";

  if (size(`ls -type "areaLight"`) > 0)
  {
    string $cur_selection[] = `ls -sl`;

    string $plane_nodes[] = 
      `nurbsPlane -ch off -axis 0 0 1 -width 2 -name "delightAreaLightPlane"`;

    setAttr ($plane_nodes[0] + ".visibility") 0;

    // The above returns the transform, but we need the shape...
    string $children[] = `listRelatives -children -fullPath $plane_nodes[0]`;
    if (size($children) > 0)
      $area_light_plane = $children[0];

    select -r $cur_selection;
  }

  return $area_light_plane;
}

proc string[]
getDefaultLightSetShapes(int $long_names)
{
  string $default_light_set_members[] = 
    DL_getFlattenedSetMembers("defaultLightSet");
  
  int $i;
  int $num_default_lights = size($default_light_set_members);
  for ($i = 0; $i < $num_default_lights; $i++)
  {
    string $shape = DL_getShapeFromTransform($default_light_set_members[$i]);
    
    if ($long_names)
    {
      string $long_names[] = `ls -l $shape`;
      $shape = $long_names[0];
    }
    
    $default_light_set_members[$i] = $shape;
  }
  
  return $default_light_set_members;
}

global proc
DRP_saveAsTemplate(string $render_pass)
{
  string $cur_sel[] = `ls -sl`;
  string $output_dir = DL_getExpandedAbsoluteOutputPath(
    DL_getTemplatesPath(), 
    "", 
    $render_pass);
    
  $output_dir = DL_createDir($output_dir);
  
  string $template_file = `file 
    -op "v=0" 
    -pr 
    -ch false 
    -chn false 
    -con false 
    -exp true
    -sh false 
    -exportSelected 
    -type "mayaAscii"
    ($output_dir + "/" + $render_pass + "_rpt.ma")`;
    
  // We need to add the connections to the exported file
  string $connections[];
  $connections = `listConnections -s true -d true -p true -c true $render_pass`;
  
  int $file = `fopen $template_file "a"`;
  
  if ($file == 0)
  {
    error("Cannot write to template file:" + $file);
    return;
  }
  
  int $i;
  for($i = 0; $i < size($connections) - 1; $i += 2)
  {
    string $dest_node = plugNode($connections[$i + 1]);
    
    if (   $dest_node != "defaultResolution"
        && match("_pixelRatioExpr$", $dest_node) == "")
    {
      if (DL_getPlugType($connections[$i]) == "message")
      {
        // Assume that connections on message plugs of the render pass are
        // made by us
        fprint $file ("DL_connectNodeToMessagePlug(\":" + $dest_node + "\", \"" +
          $connections[$i] + "\");\n");
      }
      else
      {
        fprint $file ("connectAttr \":" + $connections[$i + 1] + "\" \"" + 
          $connections[$i] + "\";\n");
      }
    }
  }
  
  fclose $file;
  
  select $cur_sel;
}

global proc
DRP_createFromTemplate(string $template)
{
  string $render_passes[] = `ls -type delightRenderPass`;
  
  string $templates_dir = DL_getExpandedAbsoluteOutputPath(
    DL_getTemplatesPath(), 
    "", 
    $template);
  
  string $new_nodes[] = `file -i -rnn ($templates_dir + "/" + $template + "_rpt.ma")`;
  string $new_pass;
  
  for($node in $new_nodes)
  {
    if (match(($template + "_rpt_"), $node) != "")
    {
      string $new_name = substring($node, size($template + "_rpt_") + 1, size($node));
      $new_name = `rename $node $new_name`;
      
      if (nodeType($new_name) == "delightRenderPass")
      {
        $new_pass = $new_name;
      }
    }
    else if (nodeType($node) == "delightRenderPass")
    {
      $new_pass = $node;
    }
  }
  
  select $new_pass;
}

// ----------------------------------------------------------------------------
// Procedures which access attributes of a render pass node
//


global proc int
DRP_isRIBRenderMode(string $render_pass)
{
  return int(getAttr($render_pass + ".renderMode")) >= 1;
}

global proc int
DRP_isImmediateRenderMode(string $render_pass)
{
  return !DRP_isRIBRenderMode($render_pass);
}

global proc int
DRP_isRIBArchivingMode(string $render_pass)
{
  return int(getAttr($render_pass + ".renderMode")) == 2;
}

global proc int
DRP_isBackgroundRenderMode(string $render_pass)
{
	return int(getAttr($render_pass + ".renderMode")) == 3;
}

global proc int
DRP_isRenderMode(string $render_pass)
{
  return
    DRP_isImmediateRenderMode($render_pass) ||
    DRP_isBackgroundRenderMode($render_pass);
}

global proc int
DRP_getAnimation(string $render_pass)
{
  return getAttr($render_pass + ".animation"); 
}

global proc float
DRP_getStartFrame(string $render_pass)
{
  return float(getAttr($render_pass + ".startFrame"));
}

global proc float
DRP_getEndFrame(string $render_pass)
{
  return float(getAttr($render_pass + ".endFrame"));
}

global proc float
DRP_getIncrement(string $render_pass)
{
  return float(getAttr($render_pass + ".increment"));
}

global proc int
DRP_getCameraBlur(string $render_pass)
{
  return getAttr($render_pass + ".cameraBlur");
}

global proc int
DRP_getDeformationBlur(string $render_pass)
{
  return getAttr($render_pass + ".deformationBlur");
}

global proc int
DRP_getTransformationBlur(string $render_pass)
{
  return getAttr($render_pass + ".transformationBlur");
}

global proc int
DRP_getNumCameraBlurSamples(string $render_pass)
{
  return getAttr($render_pass + ".cameraBlurSamples");
}

global proc int
DRP_getNumTransformBlurSamples(string $render_pass)
{
  return getAttr($render_pass + ".transformationSamples");
}

global proc int
DRP_getNumDeformBlurSamples(string $render_pass)
{
  return getAttr($render_pass + ".deformationSamples");
}

global proc string
DRP_getMotionBlurPosition(string $render_pass)
{
  return getAttr("-asString", $render_pass + ".motionBlurPosition");
}

global proc float[]
DRP_getSampleOffsets(string $render_pass,
                     float $shutter_angle,
                     int $num_samples)
{
  string $motion_blur_position;
  float  $sample_offsets[];
  float  $sample_delta;  // amount of time between samples
  float  $shutter_interval;
  float  $shutter_open_offset;

  $shutter_interval = $shutter_angle/360;

  $sample_delta = $shutter_interval/($num_samples-1);

  $motion_blur_position = DRP_getMotionBlurPosition($render_pass);

  switch ($motion_blur_position)
  {
    case "centred on frame":
      $shutter_open_offset = -$shutter_interval/2;
      break;

    case "end on frame":
      $shutter_open_offset = -$shutter_interval;
      break;

    case "start on frame":
      $shutter_open_offset = 0;
      break;

    default:
      $shutter_open_offset = -$shutter_interval/2;
      break;
  }

  for ($i = 0; $i < $num_samples; $i++)
  {
    $sample_offsets[$i] = $shutter_open_offset + $sample_delta * $i;
  }
  
  return $sample_offsets;
}

global proc string[]
DRP_getAllDisplayDrivers()
{
  string $all_drivers[];

  $all_drivers[0] = "framebuffer";
  $all_drivers[1] = "idisplay";
  $all_drivers[2] = "maya_render_view";
  $all_drivers[3] = "tiff";
  $all_drivers[4] = "iff";
  $all_drivers[5] = "exr";
  $all_drivers[6] = "cineon";
  $all_drivers[7] = "zfile";
  $all_drivers[8] = "bmp";
  $all_drivers[9] = "eps";
  $all_drivers[10] = "psd";
  $all_drivers[11] = "radiance";
  $all_drivers[12] = "null";
  $all_drivers[13] = "shadowmap";
  $all_drivers[14] = "texture";
  $all_drivers[15] = "dsm";
  return $all_drivers;
}

global proc string
DRP_getAllDisplayDriversForEnum()
{
  string  $all_drivers[];

  $all_drivers = DRP_getAllDisplayDrivers();

  return DG_stringArrayToEnumString($all_drivers);
}

global proc string[]
DRP_getAllDisplayAOVs()
{
  string $all_AOVs[];

  // NOTE: The first entry must remain "(user specified)".
  $all_AOVs[0] = "(user specified)";
  $all_AOVs[1] = "z (depth)";
  $all_AOVs[2] = "rgb (color)";
  $all_AOVs[3] = "a (alpha channel)";
  $all_AOVs[4] = "Oi (3-channel alpha)";
  $all_AOVs[5] = "rgba (color + alpha)";
  $all_AOVs[6] = "ambient";
  $all_AOVs[7] = "diffuse";
  $all_AOVs[8] = "specular";
  $all_AOVs[9] = "reflection";
  $all_AOVs[10] = "refraction";
  $all_AOVs[11] = "shadow";
  $all_AOVs[12] = "incandescence";
  $all_AOVs[13] = "translucence";
  $all_AOVs[14] = "diffuse no shadow";
  $all_AOVs[15] = "diffuse intensity";
  $all_AOVs[16] = "diffuse intensity no shadow";
  $all_AOVs[17] = "key lights diffuse intensity";
  $all_AOVs[18] = "key lights diffuse intensity no shadow";
  $all_AOVs[19] = "luminance depth";
  $all_AOVs[20] = "specular no shadow";
  $all_AOVs[21] = "specular intensity";
  $all_AOVs[22] = "specular intensity no shadow";
  $all_AOVs[23] = "key lights specular intensity";
  $all_AOVs[24] = "key lights specular intensity no shadow";
  $all_AOVs[25] = "color no shadow";
  $all_AOVs[26] = "raytraced reflection";
  $all_AOVs[27] = "environment reflection";
  $all_AOVs[28] = "surface color";
  $all_AOVs[29] = "occlusion";
  $all_AOVs[30] = "ambient no shadow";
	
  return $all_AOVs;
}

global proc string[]
DRP_getAllDisplayAOVDeclarations()
{
  string $all_AOVDeclarations[];

  $all_AOVDeclarations[0] = "";
  $all_AOVDeclarations[1] = "z";
  $all_AOVDeclarations[2] = "rgb";
  $all_AOVDeclarations[3] = "a";
  $all_AOVDeclarations[4] = "Oi";
  $all_AOVDeclarations[5] = "rgba";
  $all_AOVDeclarations[6] = "color aov_ambient";
  $all_AOVDeclarations[7] = "color aov_diffuse";
  $all_AOVDeclarations[8] = "color aov_specular";
  $all_AOVDeclarations[9] = "color aov_reflection";
  $all_AOVDeclarations[10] = "color aov_refraction";
  $all_AOVDeclarations[11] = "color unused, float aov_shadow";
  $all_AOVDeclarations[12] = "color aov_incandescence";
  $all_AOVDeclarations[13] = "color aov_translucence";
  $all_AOVDeclarations[14] = "color aov_diffuse_no_shadow";
  $all_AOVDeclarations[15] = "color aov_diffuse_intensity";
  $all_AOVDeclarations[16] = "color aov_diffuse_intensity_no_shadow";
  $all_AOVDeclarations[17] = "color aov_key_lights_diffuse_intensity";
  $all_AOVDeclarations[18] = "color aov_key_lights_diffuse_intensity_no_shadow";
  $all_AOVDeclarations[19] = "color aov_luminance_depth";
  $all_AOVDeclarations[20] = "color aov_specular_no_shadow";
  $all_AOVDeclarations[21] = "color aov_specular_intensity";
  $all_AOVDeclarations[22] = "color aov_specular_intensity_no_shadow";
  $all_AOVDeclarations[23] = "color aov_key_lights_specular_intensity";
  $all_AOVDeclarations[24] = "color aov_key_lights_specular_intensity_no_shadow";
  $all_AOVDeclarations[25] = "color aov_color_no_shadow";
  $all_AOVDeclarations[26] = "color aov_rt_reflection, float aov_rt_reflection_alpha";
  $all_AOVDeclarations[27] = "color aov_env_reflection";
  $all_AOVDeclarations[28] = "color aov_surface_color";
  $all_AOVDeclarations[29] = "color aov_occlusion";
  $all_AOVDeclarations[30] = "color aov_ambient_no_shadow";

  return $all_AOVDeclarations;
}

global proc string
DRP_getRenderCamera(string $render_pass)
{
  return DG_getAttachedShape($render_pass + ".camera");
}

global proc string
DRP_getShaderCollection(string $render_pass)
{
  return DL_getSourceNode($render_pass + ".shaderCollection");
}

global proc string
DRP_getObjectsToRenderSet(string $render_pass)
{
  return DG_getAttachedShape($render_pass + ".objectsToRender");
}

global proc string
DRP_getLightsToRenderSet(string $render_pass)
{
  return DG_getAttachedShape($render_pass + ".lightsToRender");
}

global proc string
DRP_getClippingPlanesToRenderSet(string $render_pass)
{
  return DG_getAttachedShape($render_pass + ".clippingPlanesToRender");
}

global proc string
DRP_getLayerToRender(string $render_pass)
{
  string $layer_to_render = DG_getAttachedShape($render_pass + ".layerToRender");
  
  // We can't set a referenced default render layer as the current one, so in
  // that case use this scene's default render layer.
  if (match(":defaultRenderLayer$", $layer_to_render) != "")
  {
    $layer_to_render = "defaultRenderLayer";
  }

  return $layer_to_render;
}

global proc string
DRP_getDisplayDriver(string $render_pass)
{
  return getAttr("-asString", $render_pass + ".displayDriver");
}

global proc string
DRP_getBucketOrder(string $render_pass)
{
  return getAttr("-asString", $render_pass + ".bucketOrder");
}

global proc int
DRP_getRenderSecondaryDisplays(string $render_pass)
{
  return getAttr($render_pass + ".renderSecondaryDisplays");
}

global proc int
DRP_getRenderPrimaryDisplay(string $render_pass)
{
  return getAttr($render_pass + ".renderPrimaryDisplay");
}

global proc int
DRP_getRenderShadowMaps(string $render_pass)
{
  return getAttr($render_pass + ".renderShadowMaps");
}

global proc int
DRP_renderPhotonMaps(string $render_pass)
{
  // TODO: The following check exists because some scenes at SohoVFX existed
  // prior to the introduction of the renderPhotonMaps attribute. Once SohoVFX
  // scenes have been updated to include this attribute, the check will no
  // longer be necessary.
  //
  if (`objExists($render_pass + ".renderPhotonMaps")`)
  {
    return getAttr($render_pass + ".renderPhotonMaps");
  }
  else
  {
    return false;
  }
}

global proc int
DRP_getNumberOfPhotons(string $render_pass)
{
  return getAttr($render_pass + ".numberOfPhotons");
}

global proc string
DRP_getGlobalPhotonMap(string $render_pass)
{
  string $map_file = getAttr($render_pass + ".globalMap");
  return DL_getExpandedFilename($map_file, "", $render_pass, "photonmap");
}

global proc string
DRP_getCausticPhotonMap(string $render_pass)
{
  string $map_file = getAttr($render_pass + ".causticMap");
  return DL_getExpandedFilename($map_file, "", $render_pass, "photonmap");
}

global proc int
DRP_getWritePhotonMaps(string $render_pass)
{
  return `getAttr($render_pass + ".writePhotonMaps")`;
}

global proc int[]
DRP_getSecondaryDisplayIndices(string $render_pass)
{
  return getMultiAttribElementIndices($render_pass + ".secondaryFilenames");
}

global proc string
DRP_getSecondaryDisplayFilename(string $render_pass, int $which_display)
{
  return getMultiAttributeStringValue(
    $render_pass + "." + "secondaryFilenames",
    $which_display);
}

global proc int
DRP_getSecondaryOverridePixelFilter(string $render_pass, int $which_display)
{
  return getMultiAttributeIntValue(
    $render_pass + ".secondaryOverridePixelFilters", 
    $which_display);
}

global proc string
DRP_getSecondaryDisplayDriver(string $render_pass, int $which_display)
{
  return getMultiAttributeStringValue(
    $render_pass + "." + "secondaryDisplayDrivers", 
    $which_display);
}

global proc string
DRP_getSecondaryDisplayMode(string $render_pass, int $which_display)
{
  return getMultiAttributeStringValue(
    $render_pass + "." + "secondaryDisplayModes", 
    $which_display);
}

global proc string
DRP_getSecondaryDisplayPixelFilter(string $render_pass, int $which_display)
{
  return getMultiAttributeStringValue(
    $render_pass + "." + "secondaryPixelFilters", 
    $which_display);
}

global proc float
DRP_getSecondaryDisplayFilterWidthX(string $render_pass, int $which_display)
{
  return getMultiAttributeFloatValue(
    $render_pass + "." + "secondaryFilterWidthsX", 
    $which_display);
}

global proc float
DRP_getSecondaryDisplayFilterWidthY(string $render_pass, int $which_display)
{
  return getMultiAttributeFloatValue(
    $render_pass + "." + "secondaryFilterWidthsY", 
    $which_display);
}

global proc float
DRP_getSecondaryDisplayQuantizeDither(string $render_pass, int $which_display)
{
  return getMultiAttributeFloatValue(
    $render_pass + "." + "secondaryQuantizeDithers", 
    $which_display);
}

global proc string
DRP_getSecondaryDisplayQuantizeString(string $render_pass, int $which_display)
{
  string  $quantize_string;
  string  $bit_depth;

  $bit_depth = getMultiAttributeStringValue(
    $render_pass + ".secondaryBitDepths", 
    $which_display);

  switch ($bit_depth)
  {
    case "8 bit integer":
      $quantize_string = "0 255 0 255";
      break;
    case "16 bit integer":
      $quantize_string = "0 65535 0 65535";
      break;
    case "32 bit float":
      $quantize_string = "0 0 0 0";
      break;
    case "Custom Quantize":
    {
      int $quantize_zero;
      int $quantize_one;
      int $quantize_min;
      int $quantize_max;

      $quantize_zero = 
        getMultiAttributeIntValue(
          $render_pass + ".secondaryQuantizeZeros", 
          $which_display);
      $quantize_one = 
        getMultiAttributeIntValue(
          $render_pass + ".secondaryQuantizeOnes", 
          $which_display);
      $quantize_min = 
        getMultiAttributeIntValue(
          $render_pass + ".secondaryQuantizeMins", 
          $which_display);
      $quantize_max = 
        getMultiAttributeIntValue(
          $render_pass + ".secondaryQuantizeMaxes", 
          $which_display);

      $quantize_string = $quantize_zero + " "
                       + $quantize_one + " "
                       + $quantize_min + " "
                       + $quantize_max;

      break;
    }
    default:
    {
      $quantize_string = "0 255 0 255";
      break;
    }
  }

  return $quantize_string;
}

global proc float
DRP_getSecondaryDisplayGain(string $render_pass, int $which_display)
{
  return getMultiAttributeFloatValue(
    $render_pass + "." + "secondaryGains", 
    $which_display);
}

global proc float
DRP_getSecondaryDisplayGamma(string $render_pass, int $which_display)
{
  return getMultiAttributeFloatValue(
    $render_pass + "." + "secondaryGammas", 
    $which_display);
}

global proc int
DRP_getSecondaryDisplayMatte(
  string $render_pass, int $which_display )
{
  return getMultiAttributeFloatValue(
    $render_pass + ".secondaryMatte", $which_display);
}

global proc int
DRP_getSecondaryDisplayExclusive(
  string $render_pass, int $which_display )
{
  return getMultiAttributeFloatValue(
    $render_pass + ".secondaryExclusive", $which_display);
}

global proc int
DRP_getSecondaryDisplayAssociateAlpha(
  string $render_pass, int $which_display )
{
  return getMultiAttributeFloatValue(
    $render_pass + ".secondaryAssociateAlpha", $which_display);
}

global proc int
DRP_getSecondaryDisplayComputeAlpha(
  string $render_pass, int $which_display )
{
  return getMultiAttributeFloatValue(
    $render_pass + ".secondaryComputeAlpha", $which_display);
}

global proc string
DRP_getSecondaryDisplayEdgeDetectionString(
  string $render_pass, int $which_display)
{
  int $edge_enable;
  string $edge_varname;
  float $edge_threshold;
  float $edge_color[];
  float $edge_filterwidth;
  int $edge_filterwidth_interp;
  int $edge_depth_enable;
  float $edge_depth_zmin;
  float $edge_depth_zmax;
  float $edge_depth_minfilter;

  $edge_enable = getMultiAttributeIntValue(
    $render_pass + ".secondaryEdgeEnables", $which_display );

  if( !$edge_enable )
    return "";

  $edge_varname = getMultiAttributeStringValue(
    $render_pass + ".secondaryEdgeVarNames", $which_display);

  $edge_color = `getAttr ($render_pass + ".secondaryEdgeColors[" + $which_display + "]")`;

  $edge_threshold = getMultiAttributeFloatValue(
    $render_pass + ".secondaryEdgeThresholds", $which_display);

  $edge_filterwidth = getMultiAttributeFloatValue(
    $render_pass + ".secondaryEdgeFilterWidths", $which_display);

  $edge_filterwidth_interp = getMultiAttributeIntValue(
    $render_pass + ".secondaryEdgeFilterWidthInterps", $which_display);

  string $edge_filter_param = "\"edgefilterwidth\"";
  if ($edge_filterwidth_interp != 0)
  {
    $edge_filter_param = "\"edgewidth\"";
    $edge_filterwidth /= 100;
  }
  
  $edge_depth_enable = getMultiAttributeIntValue(
    $render_pass + ".secondaryEdgeDepthEnables", $which_display);
  
  $edge_depth_zmin = getMultiAttributeFloatValue(
    $render_pass + ".secondaryEdgeDepthZMins", $which_display);

  $edge_depth_zmax = getMultiAttributeFloatValue(
    $render_pass + ".secondaryEdgeDepthZMaxs", $which_display);

  $edge_depth_minfilter = getMultiAttributeFloatValue(
    $render_pass + ".secondaryEdgeDepthMinFilters", $which_display);

  string $edgestring =
    " -p \"edgevariables\" \"string\" \"" + $edge_varname + "\"" +
    " -p \"edgethreshold\" \"float\" " + $edge_threshold +
    " -p \"edgecolor\" \"color\" \"" + floatArrayToString($edge_color) + "\"" +
    " -p " + $edge_filter_param + " \"float\" " + $edge_filterwidth;

  if( $edge_depth_enable )
  {
    $edgestring +=
      " -p \"edgefadeout\" \"float[3]\" \""
        + $edge_depth_zmin + " "
        + $edge_depth_zmax + " "
        + $edge_depth_minfilter + "\"";
  }

  return $edgestring;
}


global proc string
DRP_getSecondaryDisplaySubset(
  string $render_pass, int $which_display)
{
  string $subset;
  
  int $subset_type = getAttr($render_pass 
    + ".secondarySubsetTypes[" 
    + $which_display 
    + "]");
  
  string $sets_attr = "secondarySubsetSets_" + $which_display;

  if ($subset_type != 0 && `attributeExists $sets_attr $render_pass` != 0 )
  {
    string $connected_sets[] = 
      `listConnections ($render_pass + "." + $sets_attr)`;
    
    $subset = stringArrayToString($connected_sets, ",");
    
    if ($subset_type == 2)
    {
      $subset = "-" + $subset;
    }
  
    $subset = " -p \"subset\" \"string\" \"" + $subset + "\"";
  }
  
  return $subset;
}

global proc string
DRP_getQuantizeString(string $render_pass)
{
  string  $quantize_string;
  string  $bit_depth;

  $bit_depth = getAttr("-asString", $render_pass + ".bitDepth");

  switch ($bit_depth)
  {
    case "8 bit integer":
      $quantize_string = "0 255 0 255";
      break;
    case "16 bit integer":
      $quantize_string = "0 65535 0 65535";
      break;
    case "32 bit float":
      $quantize_string = "0 0 0 0";
      break;
    case "Custom Quantize":
    {
      int $quantize_zero;
      int $quantize_one;
      int $quantize_min;
      int $quantize_max;

      $quantize_zero = getAttr($render_pass + ".quantizeZero");
      $quantize_one = getAttr($render_pass + ".quantizeOne");
      $quantize_min = getAttr($render_pass + ".quantizeMin");
      $quantize_max = getAttr($render_pass + ".quantizeMax");

      $quantize_string = $quantize_zero + " "
                       + $quantize_one + " "
                       + $quantize_min + " "
                       + $quantize_max;

      break;
    }
    default:
    {
      $quantize_string = "0 255 0 255";
      break;
    }
  }

  return $quantize_string;
}

global proc string
DRP_getPixelFilter(string $render_pass)
{
  return getAttr("-asString", $render_pass + ".pixelFilter");
}

global proc float[]
DRP_getFilterWidth(string $render_pass)
{
  return getAttr($render_pass + ".filterWidth");
}

global proc float[]
DRP_getOpacityThreshold(string $render_pass)
{
  return getAttr($render_pass + ".opacityThreshold");
}

global proc float[]
DRP_getZthreshold(string $render_pass)
{
  return getAttr($render_pass + ".zThreshold");
}

global proc int
DRP_useImagerShaders(string $render_pass)
{
  return getAttr($render_pass + ".useImagerShaders");
}

global proc int
DRP_getUseDisplacementShadersInShadows(string $render_pass)
{
  return getAttr($render_pass + ".useDisplacementShadersInShadows");
}

global proc int
DRP_getUseSurfaceShadersInShadows(string $render_pass)
{
  return getAttr($render_pass + ".useSurfaceShadersInShadows");
}

global proc int
DRP_getUseAtmosphereShadersInShadows(string $render_pass)
{
  return getAttr($render_pass + ".useAtmosphereShadersInShadows");
}

global proc int
DRP_getUseInteriorShadersInShadows(string $render_pass)
{
  return getAttr($render_pass + ".useInteriorShadersInShadows");
}

global proc int
DRP_getTranslateMayaShaders(string $render_pass)
{
  return getAttr($render_pass + ".translateMayaShaders");
}

global proc int
DRP_getUseMayaShaders(string $render_pass)
{
  return getAttr($render_pass + ".useMayaShaders");
}

global proc int
DRP_getConcatenateGeoTransforms(string $render_pass)
{
  return getAttr($render_pass + ".concatenateGeoTransforms");
}

global proc int
DRP_getConcatenateLightTransforms(string $render_pass)
{
  return getAttr($render_pass + ".concatenateLightTransforms");
}

global proc string[]
DRP_getAllMotionBlurPositions()
{
  string $all_positions[];

  $all_positions[0] = "end on frame";
  $all_positions[1] = "centred on frame";
  $all_positions[2] = "start on frame";

  return $all_positions;
}

global proc string
DRP_getAllMotionBlurPositionsForEnum()
{
  string $array[];

  $array = DRP_getAllMotionBlurPositions();

  return DG_stringArrayToEnumString($array);
}

global proc
DRP_setCamera(string $render_pass, string $camera)
{
  string $camera_attr = $render_pass + ".camera";

  DL_disconnectNode($camera_attr);
  DL_connectNodeToMessagePlug($camera, $camera_attr);   
}

global proc string
DRP_getHider(string $render_pass)
{
  return getAttr("-asString", $render_pass + ".hider");
}

global proc string
DRP_getDepthFilter(string $render_pass)
{
  return getAttr("-asString", $render_pass + ".depthFilter");
}

global proc string
DRP_getVolumeInterpretation(string $render_pass)
{
  // getAttr -asString returns attrib name with capital letter...
  int $mode = getAttr($render_pass + ".volumeInterpretation");
  if ($mode == 0)
  {
    return "discrete";
  }
  else if ($mode == 1)
  {
    return "continuous";
  }

  return "deepprevdisttotal";
}

// ----------------------------------------------------------------------------
// Procedures which add attributes to a new render pass node
//

proc
addObjectSetAttributes( string $render_pass )
{
  if( !attributeExists( "lightsToRender", $render_pass ) )
  {
    addAttr 
      -longName lightsToRender 
      -attributeType message
      $render_pass;
  }

  if( !attributeExists( "objectsToRender", $render_pass ) )
  {
    addAttr 
      -longName objectsToRender 
      -attributeType message
      $render_pass;
  }

  if( !attributeExists( "clippingPlanesToRender", $render_pass ) )
  {
    addAttr 
      -longName clippingPlanesToRender 
      -attributeType message
      $render_pass;
  }
  else
  {
    string $clip = DRP_getClippingPlanesToRenderSet($render_pass);
    if ($clip != "" && !`objectType -isa "objectSet" $clip`)
    {
      string $new_set = `sets -n "clippingPlaneSet" $clip`;
      string $msg_plug = $render_pass + ".clippingPlanesToRender"; 

      DL_disconnectNode($msg_plug);
      DL_connectNodeToMessagePlug($new_set, $msg_plug);
    }
  }
}

proc
addFrameRangeAttributes( string $render_pass )
{
  if( !attributeExists( "animation", $render_pass ) )
  {
    addAttr 
      -longName animation 
      -attributeType bool
      $render_pass;
  }

  if( !attributeExists( "frameRange", $render_pass ) )
  {
    addAttr 
      -longName frameRange 
      -attributeType float2
      $render_pass;

      addAttr 
        -longName startFrame 
        -attributeType "float" 
        -defaultValue 1.0 
        -parent frameRange
        $render_pass;

      addAttr 
        -longName endFrame 
        -attributeType "float"
        -defaultValue 1.0 
        -parent frameRange
        $render_pass;
  }

  if( !attributeExists( "increment", $render_pass ) )
  {
    addAttr 
      -longName increment 
      -attributeType "float" 
      -defaultValue 1.0
      $render_pass;
  }
}

proc
addMotionBlurAttributes( string $render_pass )
{
  if( !attributeExists( "cameraBlur", $render_pass ) )
  {
    addAttr
      -longName cameraBlur
      -attributeType bool
      $render_pass;
  }

  if( !attributeExists( "transformationBlur", $render_pass ) )
  {
    addAttr 
      -longName transformationBlur 
      -attributeType bool
      $render_pass;
  }

  if( !attributeExists( "deformationBlur", $render_pass ) )
  {
    addAttr 
      -longName deformationBlur 
      -attributeType bool
      $render_pass;
  }

  if( !attributeExists( "cameraBlurSamples", $render_pass ) )
  {
    addAttr
      -longName cameraBlurSamples
      -attributeType long
      -defaultValue 2
      -min 2
      -max 20
      $render_pass;
  }

  if( !attributeExists( "transformationSamples", $render_pass ) )
  {
    addAttr 
      -longName transformationSamples 
      -attributeType long 
      -defaultValue 2 
      -min 2 
      -max 20
      $render_pass;
  }

  if( !attributeExists( "deformationSamples", $render_pass ) )
  {
    addAttr 
      -longName deformationSamples 
      -attributeType long 
      -defaultValue 2 
      -min 2 
      -max 20
      $render_pass;
  }

  string  $all_positions;

  $all_positions = DRP_getAllMotionBlurPositionsForEnum();

  if( !attributeExists( "motionBlurPosition", $render_pass ) )
  {
    addAttr 
      -longName motionBlurPosition
      -attributeType "enum" 
      -en $all_positions
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "shutterEfficiency", $render_pass ) )
  {
    addAttr 
      -longName shutterEfficiency 
      -attributeType float2
      $render_pass;

      addAttr 
        -longName shutterEfficiencyA 
        -attributeType "float"
        -min 0.0
        -max 1 
        -defaultValue 1 
        -parent shutterEfficiency
        $render_pass;

      addAttr 
        -longName shutterEfficiencyB 
        -attributeType "float"
        -min 0.0
        -max 1 
        -defaultValue 1 
        -parent shutterEfficiency
        $render_pass;
  }
}

proc
addRibOutputAttributes( string $render_pass )
{
  if( !attributeExists( "ribFilename", $render_pass ) )
  {
    addAttr 
      -longName ribFilename 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "binaryRib", $render_pass ) )
  {
    addAttr 
      -longName binaryRib 
      -attributeType bool
      $render_pass;
  }

  if( !attributeExists( "compressedRib", $render_pass ) )
  {
    addAttr 
      -longName compressedRib 
      -attributeType bool
      $render_pass;
  }
    
  if( !attributeExists( "generateRIBArchives", $render_pass ) )
  {
    addAttr
      -longName generateRIBArchives
      -attributeType bool
      -defaultValue true
      $render_pass;
  }
    
  if( !attributeExists( "ignoreArchivedObjects", $render_pass ) )
  {
    addAttr
      -longName ignoreArchivedObjects
      -attributeType bool
      -defaultValue true
      $render_pass;
  }

  if( !attributeExists( "archiveTransforms", $render_pass ) )
  {
    addAttr
      -longName archiveTransforms
      -attributeType bool
      -defaultValue true
      $render_pass;
  }
  
  if( !attributeExists( "archiveLighting", $render_pass ) )
  {
    addAttr
      -longName archiveLighting
      -attributeType "enum"
      -defaultValue 2
      -enumName "No Lighting:Light Linking:Light Sources & Light Linking"
      $render_pass;
  }
  
  if( !attributeExists( "archiveGeometryAttributes", $render_pass ) )
  {
    addAttr
      -longName archiveGeometryAttributes
      -attributeType "bool"
      -defaultValue true
      $render_pass;
  }

  if( !attributeExists( "archiveGeometryShaders", $render_pass ) )
  {
    addAttr
      -longName archiveGeometryShaders
      -attributeType "bool"
      -defaultValue true
      $render_pass;
  }  

  if (!attributeExists("archiveWriteMode", $render_pass))
  {
    addAttr
      -attributeType "enum"
      -longName "archiveWriteMode"
      -enumName "Reuse existing archive:Overwrite existing archive"
      -defaultValue 1
      $render_pass;
  }
  
  if (!attributeExists("backgroundRenderParams", $render_pass))
  {
    addAttr
      -dataType "string"
      -longName "backgroundRenderParams"
      $render_pass;
  }

  if (!attributeExists("renderLogFilename", $render_pass))
  {
    addAttr
      -dataType "string"
      -longName "renderLogFilename"
      $render_pass;
  }
}

proc
addMELscriptAttribs( string $render_pass )
{
  if( !attributeExists( "preRenderMEL", $render_pass ) )
  {
    addAttr 
      -longName preRenderMEL 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "postRenderMEL", $render_pass ) )
  {
    addAttr 
      -longName postRenderMEL 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "preFrameMEL", $render_pass ) )
  {
    addAttr 
      -longName preFrameMEL 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "postFrameMEL", $render_pass ) )
  {
    addAttr 
      -longName postFrameMEL 
      -dataType "string"
      $render_pass;
  }
}

proc
addNetCacheAttribs( string $render_pass )
{
  if( !attributeExists( "useNetCache", $render_pass ) )
  {
    addAttr 
      -longName useNetCache 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "netCacheDir", $render_pass ) )
  {
    addAttr 
      -longName netCacheDir 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "netCacheSize", $render_pass ) )
  {
    addAttr 
      -longName netCacheSize 
      -attributeType long 
      -min 100 
      -defaultValue 100
      $render_pass;
  }
}

proc
addPhotonMapAttribs( string $render_pass )
{
  if( !attributeExists( "renderPhotonMaps", $render_pass ) )
  {
    addAttr -longName renderPhotonMaps -at bool -dv 0 $render_pass;
  }

  if( !attributeExists( "writePhotonMaps", $render_pass ) )
  {
    addAttr -longName writePhotonMaps -at bool -dv 0 $render_pass;
  }

  if( !attributeExists( "numberOfPhotons", $render_pass ) )
  {
    addAttr -longName numberOfPhotons -at long -min 0 -dv 0 $render_pass;
  }

  if( !attributeExists( "globalMap", $render_pass ) )
  {
    addAttr -longName globalMap -dt "string" $render_pass;
    setAttr 
      -type "string" 
      ($render_pass + ".globalMap") 
      "3delight/<scene>/photonmaps/global.pmap";
  }

  if( !attributeExists( "causticMap", $render_pass ) )
  {
    addAttr -longName causticMap -dt "string" $render_pass;
    setAttr 
      -type "string" 
      ($render_pass + ".causticMap") 
      "3delight/<scene>/photonmaps/caustic.pmap";
  }
}

proc
addStatisticsAttribs( string $render_pass )
{
  if( !attributeExists( "statisticsLevel", $render_pass ) )
  {
    addAttr 
      -longName statisticsLevel 
      -attributeType long 
      -min 0 
      -max 3 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "statisticsFile", $render_pass ) )
  {
    addAttr 
      -longName statisticsFile 
      -dataType "string"
      $render_pass;
  }
  
  if( !attributeExists( "outputRenderProgress", $render_pass ) )
  {
    addAttr
      -longName outputRenderProgress
      -attributeType bool
      -defaultValue off
      $render_pass;
  }
}

proc
addSearchPathAttributes( string $render_pass )
{
  if( !attributeExists( "shaderPath", $render_pass ) )
  {
    addAttr 
      -longName shaderPath 
      -dataType "string"
      $render_pass;
    setAttr ($render_pass + ".shaderPath") -type "string" "@";
  }

  if( !attributeExists( "proceduralPath", $render_pass ) )
  {
    addAttr 
      -longName proceduralPath 
      -dataType "string"
      $render_pass;
    setAttr ($render_pass + ".proceduralPath") -type "string" "@";
  }

  if( !attributeExists( "texturePath", $render_pass ) )
  {
    addAttr 
      -longName texturePath 
      -dataType "string"
      $render_pass;
    setAttr ($render_pass + ".texturePath") -type "string" "@";
  }

  if( !attributeExists( "archivePath", $render_pass ) )
  {
    addAttr 
      -longName archivePath 
      -dataType "string"
      $render_pass;
    setAttr ($render_pass + ".archivePath") -type "string" "@";
  }
}

proc
addCommonMiscOptions( string $render_pass )
{
  if( !attributeExists( "gridSize", $render_pass ) )
  {
    addAttr 
      -longName gridSize 
      -attributeType long 
      -min 16 
      -defaultValue 256
      $render_pass;
  }

  if( !attributeExists( "textureMemory", $render_pass ) )
  {
    addAttr 
      -longName textureMemory 
      -attributeType long 
      -min 128 
      -defaultValue 32768
      $render_pass;
  }

  if( !attributeExists( "eyeSplits", $render_pass ) )
  {
    addAttr 
      -longName eyeSplits 
      -attributeType long 
      -min 0 
      -defaultValue 10
      $render_pass;
  }
}

global proc string
DL_createRenderPassNode()
{
  string  $new_node;
  string  $display_driver_enum;
  
  if (`getApplicationVersionAsFloat` >= 8.0)
  {
    $new_node = `createNode -skipSelect delightRenderPass`;
  }
  else
  {
    string $cur_selection[];
    $cur_selection = `ls -sl`;
    $new_node = `createNode delightRenderPass`;
    select -noExpand $cur_selection;
  }

  delightSetPluginVersion($new_node);

  // Add all the required attributes.
  DRP_init($new_node, 0);

  DRP_setCamera($new_node, "perspShape");

  // run the user's init command, if it exists
  if (exists("DL_userRenderPassInit"))
  {
    eval("DL_userRenderPassInit \"" + $new_node + "\"");
  }

  // Return the name of the newly created node.
  //
  return $new_node;
}

proc
updateEnumAttr(
  string $node, 
  string $attr, 
  string $enum_values,
  int $is_multi,
  int $default_value)
{
  // Check if the given enum attribute exists. If it exists, make sure its
  // range and enum values are up-to-date. If it does not exist, create it.
  //
  string $tokens[];
  tokenize($enum_values, ":", $tokens);

  int $multi_values[];
  int $multi_indices[];
  
  if( attributeExists( $attr, $node ) )
  {
    int $locked[] = `lockNode -q $node`;
    float $max[] = `attributeQuery -max -node $node $attr`;
    
    if ( $max[0] != (size($tokens) - 1) && $locked[0] == 0 )
    {
      if (`attributeQuery -multi -node $node $attr`)
      {
        $multi_indices = getMultiAttribElementIndices($node + "." + $attr);
      
        for ($i in $multi_indices)
        {
          $multi_values[$i] = getMultiAttributeIntValue(
            ($node + "." + $attr), 
            $i);
        }
      }
      else
      {
        $default_value = getAttr($node + "." + $attr);
      }
      
      deleteAttr -at $attr $node;
    }
  }

  if( !attributeExists( $attr, $node ) )
  {
    string $cmd = "addAttr ";
    if ($is_multi)
    {
      $cmd += "-multi ";
    }
    
    $cmd += "-longName \"" + $attr + "\" -attributeType \"enum\" ";
    $cmd += "-enumName \"" + $enum_values + "\"	-defaultValue " + $default_value;
    $cmd += " " + $node;

    eval($cmd);
    
    if ($is_multi)
    {
      for($i in $multi_indices)
      {
        setAttr ($node + "." + $attr + "[" + $i + "]") $multi_values[$i];
      }
    }
  }
}

global proc
DRP_init(string $render_pass, int $update_node)
{
  if( !attributeExists( "connectToRenderGlobals", $render_pass ) )
  {
    addAttr 
      -longName connectToRenderGlobals
      -attributeType bool
      -defaultValue ($update_node == 1 ? 0 : 1)
      $render_pass;
  }
  
  // Each render pass is associated with a single shader collection. 
  // A connection between delightShaderCollection.pass and 
  // delightRenderPass.shaderCollection indicates that the shader collection 
  // is associated with the pass.
  //

  if( !attributeExists( "shaderCollection", $render_pass ) )
  {
    addAttr
      -attributeType message
      -longName "shaderCollection"
      $render_pass;
  }

  $display_driver_enum = DRP_getAllDisplayDriversForEnum();

  addFrameRangeAttributes( $render_pass );
  addMotionBlurAttributes( $render_pass );

  if( !attributeExists( "camera", $render_pass ) )
  {
    addAttr 
      -longName camera 
      -attributeType message
      $render_pass;
  }

  if( !attributeExists( "resolution", $render_pass ) )
  {
    addAttr 
      -longName resolution 
      -attributeType long2
      $render_pass;

      addAttr 
        -longName resolutionX 
        -attributeType long 
        -min 0 
        -defaultValue 720 
        -parent resolution
        $render_pass;

      addAttr 
        -longName resolutionY 
        -attributeType long 
        -min 0 
        -defaultValue 486 
        -parent resolution
        $render_pass;
  }

  updateEnumAttr(
    $render_pass, 
    "resolutionMultiplier", 
    "Full:Half:Quarter:Eighth",
    0,
    0);
		
  if( !attributeExists( "pixelAspectRatio", $render_pass ) )
  {
    addAttr
      -longName pixelAspectRatio
      -attributeType "float"
      -defaultValue 1.0
      -minValue 0.01
      $render_pass;
  }
  
  if( !attributeExists( "gain",  $render_pass ) )
  {
    addAttr
      -longName "gain"
      -attributeType "float"
      -defaultValue 1.0
      $render_pass;
  }
  
  if( !attributeExists( "gamma",  $render_pass ) )
  {
    addAttr
      -longName "gamma"
      -attributeType "float"
      -defaultValue 1.0
      $render_pass;
  }

  if( !attributeExists( "imageFilename", $render_pass ) )
  {
    addAttr 
      -longName imageFilename 
      -dataType "string"
      $render_pass;
  }

  int $default_display_driver = 1;

  updateEnumAttr(
    $render_pass,
    "displayDriver",
    $display_driver_enum,
    0,
    $default_display_driver);
		
  if( !attributeExists( "displayMode", $render_pass ) )
  {
    addAttr 
      -longName displayMode
      -dataType "string"
      $render_pass;

    setAttr ($render_pass + ".displayMode") -type "string" "rgba";
  }

  addRibOutputAttributes( $render_pass );

  updateEnumAttr(
    $render_pass,
    "renderMode",
    "Render:Save RIB:RIB Archive:Background Render",
    0,
    0);

  if( !attributeExists( "pixelSamples", $render_pass ) )
  {
    addAttr 
      -longName pixelSamples 
      -attributeType long2
      $render_pass;

      addAttr 
        -longName pixelSamplesX 
        -attributeType long 
        -min 1 
        -defaultValue 3 
        -parent pixelSamples
        $render_pass;

      addAttr 
        -longName pixelSamplesY 
        -attributeType long 
        -min 1 
        -defaultValue 3 
        -parent pixelSamples
        $render_pass;
  }

  if( !attributeExists( "shadingRate", $render_pass ) )
  {
    addAttr 
      -longName shadingRate 
      -attributeType "float" 
      -min 0.001 
      -defaultValue 1
      $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "pixelFilter",
    "box:triangle:gaussian:catmull-rom:bessel:sinc:mitchell:zmin:zmax",
    0,
    5);
		
  if( !attributeExists( "filterWidth", $render_pass ) )
  {
    addAttr 
      -longName filterWidth
      -attributeType float2
      $render_pass;

      addAttr 
        -longName filterWidthX
        -attributeType "float" 
        -min 0.001 
        -defaultValue 4 
        -parent filterWidth
        $render_pass;

      addAttr 
        -longName filterWidthY
        -attributeType "float" 
        -min 0.001 
        -defaultValue 4 
        -parent filterWidth
        $render_pass;
  }

  if( !attributeExists( "bucketSize", $render_pass ) )
  {
    addAttr
      -longName bucketSize
      -attributeType long2
      $render_pass;

      addAttr 
        -longName bucketSizeX
        -attributeType long 
        -min 2 
        -defaultValue 16 
        -parent bucketSize
        $render_pass;

      addAttr   
        -longName bucketSizeY
        -attributeType long 
        -min 2 
        -defaultValue 16 
        -parent bucketSize
        $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "bitDepth",
    "8 bit integer:16 bit integer:32 bit float:Custom Quantize",
    0,
    0);
		
  if( !attributeExists( "quantizeZero", $render_pass ) )
  {
    addAttr 
      -longName quantizeZero 
      -attributeType long 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "quantizeOne", $render_pass ) )
  {
    addAttr 
      -longName quantizeOne 
      -attributeType long 
      -defaultValue 255
      $render_pass;
  }

  if( !attributeExists( "quantizeMin", $render_pass ) )
  {
    addAttr 
      -longName quantizeMin 
      -attributeType long 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "quantizeMax", $render_pass ) )
  {
    addAttr 
      -longName quantizeMax 
      -attributeType long 
      -defaultValue 255
      $render_pass;
  }

  if( !attributeExists( "quantizeDither", $render_pass ) )
  {
    addAttr 
      -longName quantizeDither 
      -attributeType "float" 
      -defaultValue 0.5
      $render_pass;
  }

  if( !attributeExists( "useCropWindow", $render_pass ) )
  {
    addAttr 
      -longName useCropWindow 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "cropMin", $render_pass ) )
  {
    addAttr 
      -longName cropMin 
      -attributeType float2
      $render_pass;

      addAttr 
        -longName cropMinX 
        -attributeType "float" 
        -min 0 
        -max 1 
        -defaultValue 0 
        -parent cropMin
        $render_pass;

      addAttr 
        -longName cropMinY 
        -attributeType "float" 
        -min 0 
        -max 1 
        -defaultValue 0 
        -parent cropMin
        $render_pass;
  }

  if( !attributeExists( "cropMax", $render_pass ) )
  {
    addAttr 
      -longName cropMax 
      -attributeType float2
      $render_pass;

      addAttr 
        -longName cropMaxX 
        -attributeType "float" 
        -min 0 
        -max 1 
        -defaultValue 1 
        -parent cropMax
        $render_pass;

      addAttr 
        -longName cropMaxY 
        -attributeType "float" 
        -min 0 
        -max 1 
        -defaultValue 1 
        -parent cropMax
        $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "bucketOrder",
    "horizontal:vertical:zigzag:spiral:circle",
    0,
    0);
		
  addMELscriptAttribs( $render_pass );

  if( !attributeExists( "layerToRender", $render_pass ) )
  {
    addAttr
      -attributeType message
      -longName "layerToRender"
      $render_pass;
      
    connectAttr -f ("defaultRenderLayer.message") ($render_pass + ".layerToRender");
  }

  if( !attributeExists( "postOptionMEL", $render_pass ) )
  {
    addAttr 
      -longName postOptionMEL 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "preWorldMEL", $render_pass ) )
  {
    addAttr 
      -longName preWorldMEL 
      -dataType "string"
      $render_pass;
  }

  addNetCacheAttribs( $render_pass );

  addPhotonMapAttribs( $render_pass );

  addStatisticsAttribs( $render_pass );

  addSearchPathAttributes( $render_pass );

  addCommonMiscOptions( $render_pass );

  if( !attributeExists( "useImagerShaders", $render_pass ) )
  {
    addAttr 
      -longName useImagerShaders 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "opacityThreshold", $render_pass ) )
  {
    addAttr 
      -longName opacityThreshold 
      -attributeType "float3"
      $render_pass;

      addAttr 
        -longName "opacityThresholdR" 
        -attributeType "float" 
        -defaultValue 0.99608 
        -p opacityThreshold
        $render_pass;

      addAttr 
        -longName "opacityThresholdG" 
        -attributeType "float" 
        -defaultValue 0.99608 
        -p opacityThreshold
        $render_pass;

      addAttr 
        -longName "opacityThresholdB" 
        -attributeType "float" 
        -defaultValue 0.99608 
        -p opacityThreshold
        $render_pass;
  }

  if( !attributeExists( "zThreshold", $render_pass ) )
  {
    addAttr 
      -longName zThreshold 
      -attributeType "float3"
      $render_pass;

      addAttr 
        -longName "zThresholdR" 
        -attributeType "float" 
        -defaultValue 1 
        -parent zThreshold
        $render_pass;

      addAttr 
        -longName "zThresholdG" 
        -attributeType "float" 
        -defaultValue 1 
        -parent zThreshold
        $render_pass;

      addAttr 
        -longName "zThresholdB" 
        -attributeType "float" 
        -defaultValue 1 
        -parent zThreshold
        $render_pass;
  }

  if( !attributeExists( "raytraceMaxDepth", $render_pass ) )
  {
    addAttr 
      -longName raytraceMaxDepth 
      -attributeType long 
      -min 0 
      -max 16 
      -defaultValue 1
      $render_pass;
  }

  addObjectSetAttributes( $render_pass );

  if( !attributeExists( "renderPrimaryDisplay", $render_pass ) )
  {
    addAttr 
      -longName renderPrimaryDisplay 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "renderSecondaryDisplays", $render_pass ) )
  {
    addAttr 
      -longName renderSecondaryDisplays 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "renderShadowMaps", $render_pass ) )
  {
    addAttr 
      -longName renderShadowMaps 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "secondaryFilenames", $render_pass ) )
  {
    addAttr 
      -longName secondaryFilenames 
      -multi 
      -dataType "string"
      $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "secondaryDisplayDrivers",
    $display_driver_enum,
    1,
    $default_display_driver);
    
  updateEnumAttr(
    $render_pass,
    "secondaryDisplayAOVs",
    `DG_stringArrayToEnumString( DRP_getAllDisplayAOVs() )`,
    1,
    0);

  if( !attributeExists( "secondaryDisplayModes", $render_pass ) )
  {
    addAttr 
      -longName secondaryDisplayModes 
      -multi 
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "secondaryOverridePixelFilters", $render_pass ) )
  {
    addAttr 
      -longName secondaryOverridePixelFilters
      -multi
      -attributeType bool
      -defaultValue 0
      $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "secondaryPixelFilters",
    "box:triangle:gaussian:catmull-rom:bessel:sinc:mitchell:zmin:zmax",
    1,
    5);
    
  if( !attributeExists( "secondaryFilterWidthsX", $render_pass ) )
  {
    addAttr 
      -longName secondaryFilterWidthsX
      -multi
      -attributeType "float"
      -min 0.001
      -defaultValue 4
      $render_pass;
  }

  if( !attributeExists( "secondaryFilterWidthsY", $render_pass ) )
  {
    addAttr 
      -longName secondaryFilterWidthsY
      -multi
      -attributeType "float"
      -min 0.001
      -defaultValue 4
      $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "secondaryBitDepths",
    "8 bit integer:16 bit integer:32 bit float:Custom Quantize",
    1,
    0);
    
  updateEnumAttr(
    $render_pass,
    "secondarySubsetTypes",
    "All objects:Objects in selected sets:Objects not in selected sets",
    1,
    0);

  if( !attributeExists( "numberOfCPUs", $render_pass ) )
  {
    addAttr 
      -longName numberOfCPUs 
      -attributeType long 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "secondaryQuantizeZeros", $render_pass ) )
  {
    addAttr 
      -longName secondaryQuantizeZeros 
      -multi 
      -attributeType long 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "secondaryQuantizeOnes", $render_pass ) )
  {
    addAttr 
      -longName secondaryQuantizeOnes 
      -multi 
      -attributeType long 
      -defaultValue 255
      $render_pass;
  }

  if( !attributeExists( "secondaryQuantizeMins", $render_pass ) )
  {
    addAttr 
      -longName secondaryQuantizeMins 
      -multi 
      -attributeType long 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "secondaryQuantizeMaxes", $render_pass ) )
  {
    addAttr 
      -longName secondaryQuantizeMaxes 
      -multi 
      -attributeType long 
      -defaultValue 255
      $render_pass;
  }

  if( !attributeExists( "secondaryQuantizeDithers", $render_pass ) )
  {
    addAttr 
      -longName secondaryQuantizeDithers 
      -multi 
      -attributeType "float" 
      -defaultValue 0.5
      $render_pass;
  }

  if( !attributeExists( "secondaryGains", $render_pass ) )
  {
    addAttr 
      -longName secondaryGains 
      -multi 
      -attributeType "float" 
      -defaultValue 1.0
      $render_pass;
  }

  if( !attributeExists( "secondaryGammas", $render_pass ) )
  {
    addAttr 
      -longName secondaryGammas
      -multi 
      -attributeType "float" 
      -defaultValue 1.0
      $render_pass;
  }

  if( !attributeExists( "secondaryMatte", $render_pass ) )
  {
    addAttr
      -longName secondaryMatte
      -multi
      -attributeType "float"
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "secondaryExclusive", $render_pass ) )
  {
    addAttr
      -longName secondaryExclusive
      -multi
      -attributeType "float"
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "secondaryAssociateAlpha", $render_pass ) )
  {
    addAttr
      -longName secondaryAssociateAlpha
      -multi
      -attributeType "float"
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "secondaryComputeAlpha", $render_pass ) )
  {
    addAttr
      -longName secondaryComputeAlpha
      -multi
      -attributeType "float"
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeEnables", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeEnables
      -multi
      -attributeType bool
      -defaultValue false
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeVarNames", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeVarNames
      -multi
      -dataType "string"
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeThresholds", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeThresholds
      -multi
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeColors", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeColors
      -multi
      -uac
      -dataType float3
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeFilterWidths", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeFilterWidths
      -multi
      $render_pass;
  }

  updateEnumAttr(
    $render_pass,
    "secondaryEdgeFilterWidthInterps",
    "Pixels:% Of Frame Width",
    1,
    0);
    
  if( !attributeExists( "secondaryEdgeDepthEnables", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeDepthEnables
      -multi
      -attributeType bool
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeDepthZMins", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeDepthZMins
      -multi
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeDepthZMaxs", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeDepthZMaxs
      -multi
      $render_pass;
  }

  if( !attributeExists( "secondaryEdgeDepthMinFilters", $render_pass ) )
  {
    addAttr
      -longName secondaryEdgeDepthMinFilters
      -multi
      $render_pass;
  }

  if( !attributeExists( "useDisplacementShadersInShadows", $render_pass ) )
  {
    addAttr 
      -longName useDisplacementShadersInShadows 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "useSurfaceShadersInShadows", $render_pass ) )
  {
    addAttr 
      -longName useSurfaceShadersInShadows 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "useAtmosphereShadersInShadows", $render_pass ) )
  {
    addAttr 
      -longName useAtmosphereShadersInShadows 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "useInteriorShadersInShadows", $render_pass ) )
  {
    addAttr 
      -longName useInteriorShadersInShadows 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "translateMayaShaders", $render_pass ) )
  {
    addAttr 
      -longName translateMayaShaders 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "useMayaShaders", $render_pass ) )
  {
    addAttr 
      -longName useMayaShaders 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "concatenateGeoTransforms", $render_pass ) )
  {
    addAttr 
      -longName concatenateGeoTransforms 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }

  if( !attributeExists( "concatenateLightTransforms", $render_pass ) )
  {
    addAttr 
      -longName concatenateLightTransforms 
      -attributeType bool 
      -defaultValue 1
      $render_pass;
  }
  
  if( !attributeExists( "standardAtmosphere", $render_pass ) )
  {
    addAttr 
      -longName standardAtmosphere 
      -attributeType bool 
      -defaultValue 0
      $render_pass;
  }

  if( !attributeExists( "hider", $render_pass ) )
  {
    addAttr 
      -longName "hider" 
      -attributeType "enum" 
      -en "hidden:raytrace" 
      -defaultValue 0 
      $render_pass;
  }

  if( !attributeExists( "translatedShadersAOVs", $render_pass ) )
  {
    addAttr 
      -longName "translatedShadersAOVs" 
      -attributeType "enum" 
      -en "Default AOVs for Render Mode:Defined AOVs Only:All AOVs" 
      -defaultValue 0 
      $render_pass;
  }
  
  if (!objExists($render_pass + ".depthFilter"))
  {
    addAttr -ln "depthFilter"
            -at "enum" 
            -en "min:max:average:midpoint"
            -dv 0
            $render_pass;
  }

  if (!objExists($render_pass + ".volumeInterpretation"))
  {
    addAttr 
      -ln "volumeInterpretation"
      -at "enum"
      -en "Discrete:Continuous:Distance Inside"
      -dv 0
      $render_pass;
  }

  DRP_checkConnectToRenderGlobals($render_pass);
}




// ----------------------------------------------------------------------------
// Procedures which execute pre and post MEL scripts
//

global proc
DRP_executePreRenderMelScript(string $render_pass)
{
  // TODO: handle scripts that are specified as a file
  string  $command;
  string  $mel_script;

  $mel_script = getAttr($render_pass + ".preRenderMEL");

  if ($mel_script != "")
  {
    $command  = "string $render_pass = \"" + $render_pass + "\"; ";
    $command += $mel_script;

    if(catch(eval($command)))
    {
      warning("error in Pre Render MEL Script in " + $render_pass + "\n");
    }
  }
}

global proc
DRP_executePostRenderMelScript(string $render_pass)
{
  // TODO: handle scripts that are specified as a file
  string  $command;
  string  $mel_script;

  $mel_script = getAttr($render_pass + ".postRenderMEL");

  if ($mel_script != "")
  {
    $command  = "string $render_pass = \"" + $render_pass + "\"; ";
    $command += $mel_script;

    if(catch(eval($command)))
    {
      warning("error in Post Render MEL Script in " + $render_pass + "\n");
    }
  }
}

proc
DRP_executePreFrameMelScript(string $render_pass)
{
  // TODO: handle scripts that are specified as a file
  string  $command;
  string  $mel_script;

  $mel_script = getAttr($render_pass + ".preFrameMEL");

  if ($mel_script != "")
  {
    string $curr_frame = `delightRenderState -qf`;

    $command  = "string $render_pass = \"" + $render_pass + "\"; ";
    $command += "float $curr_frame = \"" + $curr_frame + "\"; ";
    $command += $mel_script;

    if(catch(eval($command)))
    {
      warning("error in Pre Frame MEL Script in " + $render_pass + "\n");
    }
  }
}

proc
DRP_executePostFrameMelScript(string $render_pass)
{
  // TODO: handle scripts that are specified as a file
  string  $command;
  string  $mel_script;

  $mel_script = getAttr($render_pass + ".postFrameMEL");

  if ($mel_script != "")
  {
    string $curr_frame = `delightRenderState -qf`;

    $command  = "string $render_node = \"" + $render_pass + "\"; ";
    $command += "float $curr_frame = \"" + $curr_frame + "\"; ";
    $command += $mel_script;

    if(catch(eval($command)))
    {
      warning("error in Post Frame MEL Script in " + $render_pass + "\n");
    }
  }
}

proc
DRP_executePostOptionMelScript(string $render_pass)
{
  // TODO: handle scripts that are specified as a file
  string  $command;
  string  $mel_script;

  $mel_script = getAttr($render_pass + ".postOptionMEL");

  if ($mel_script != "")
  {
    string $curr_frame = `delightRenderState -qf`;

    $command  = "string $render_node = \"" + $render_pass + "\"; ";
    $command += "float $curr_frame = \"" + $curr_frame + "\"; ";
    $command += $mel_script;

    if(catch(eval($command)))
    {
      warning("error in Post Option MEL Script in " + $render_pass + "\n");
    }
  }
}

proc
DRP_executePreWorldMelScript(string $render_pass)
{
  // TODO: handle scripts that are specified as a file
  string  $command;
  string  $mel_script;

  $mel_script = getAttr($render_pass + ".preWorldMEL");

  if ($mel_script != "")
  {
    float $curr_frame = `delightRenderState -qf`;

    $command  = "string $render_node = \"" + $render_pass + "\"; ";
    $command += "float $curr_frame = \"" + $curr_frame + "\"; ";
    $command += $mel_script;

    if(catch(eval($command)))
    {
      warning("error in Pre World MEL Script in " + $render_pass + "\n");
    }
  }
}


// ----------------------------------------------------------------------------
// Procedures which interrogate the scene, used when rendering
//

proc string
getFullPath(string $path)
{
  string $full_path[];

  $full_path = `ls -long $path`;

  return $full_path[0];
}

// strip off everything but the shape name from the given path
proc string
shapeNameOnly(string $full_path)
{
  string $path_tokens[];

  tokenize($full_path, "|", $path_tokens);

  return $path_tokens[size($path_tokens)-1];
}

proc
setupInstancedInfoCache(string $all_shapes[])
{
  if (`delightTable -tableExists "is_instanced"`)
    delightTable -clearTable "is_instanced";
  else
    delightTable -addTable "is_instanced";

  if (`delightTable -tableExists "first_instance"`)
    delightTable -clearTable "first_instance";
  else
    delightTable -addTable "first_instance";

  string $all_parents[];

  for ($curr_shape in $all_shapes)
  {
    if (!`delightTable -keyExists "is_instanced" $curr_shape`)
    {
      $all_parents = `listRelatives -allParents -fullPath $curr_shape`;

      if (size($all_parents) > 1)
      {
        // it's instanced.. fill in the cache with the info about all the
        // sibling instances at the same time.
        string $curr_instance;
        string $first_instance;
        string $shape_name;

        $shape_name = shapeNameOnly($curr_shape);

        $first_instance = ($all_parents[0] + "|" + $shape_name);

        delightTable -setValueInt "is_instanced" $first_instance 1;
        delightTable -setValueString "first_instance"
                                     $first_instance
                                     $first_instance;

        for ($i = 1; $i < size($all_parents); $i++)
        {
          $curr_instance = ($all_parents[$i] + "|" + $shape_name);

          delightTable -setValueInt "is_instanced" $curr_instance 2;
          delightTable -setValueString "first_instance"
                                       $curr_instance
                                       $first_instance;
        }
      }
      else
      {
        delightTable -setValueInt "is_instanced" $curr_shape 0;
        delightTable -setValueString "first_instance" $curr_shape $curr_shape;
      }
    }
    // else we've already handled this object
  }
}

proc int
isInstanced(string $shape)
{
  return (`delightTable -getValueInt "is_instanced" $shape` > 0);
}

// returns 0 if the shape isn't instanced or is a secondary instance
proc int
isFirstInstance(string $shape)
{
  return (`delightTable -getValueInt "is_instanced" $shape` == 1);
}

proc int
isSecondaryInstance(string $shape)
{
  return (`delightTable -getValueInt "is_instanced" $shape` == 2);
}

proc string
getFirstInstance(string $shape)
{
  return (`delightTable -getValueString "first_instance" $shape`);
}

proc string[]
getAllFirstInstances(string $all_shapes[])
{
  string $first_instances[];

  for ($curr_shape in $all_shapes)
  {
    if (isFirstInstance($curr_shape))
    {
      $first_instances[size($first_instances)] = $curr_shape;
    }
  }

  return DL_stringArrayRemoveDuplicates($first_instances);
}

proc string[]
getAllSecondaryInstances(string $all_shapes[])
{
  string $secondary_instances[];

  for ($curr_shape in $all_shapes)
  {
    if (isSecondaryInstance($curr_shape))
    {
      $secondary_instances[size($secondary_instances)] = $curr_shape;
    }
  }

  return $secondary_instances;
}

proc string[]
getAllNonInstancedShapes(string $all_shapes[])
{
  string $non_instanced[];

  for ($curr_shape in $all_shapes)
  {
    if (!isInstanced($curr_shape))
    {
      $non_instanced[size($non_instanced)] = getFullPath($curr_shape);
    }
  }

  return $non_instanced;
}


proc int
isObjectVisible(string $object)
{
  int     $is_visible;

  $is_visible = getAttr($object + ".visibility");
  $is_visible *= getAttr($object + ".overrideVisibility");

  if ($is_visible)
  {
    string  $curr_parent;

    // we've already checked visibility of the current object... just pop it
    // off the path
    $curr_parent = popPath($object);

    // then we loop over all of the parents path of this object and check
    // their visibility (both the visibility and overrideVisibility attribs).
    // Stop when we find the first invisible parent
    while ($curr_parent != "")
    {
      $is_visible *= getAttr($curr_parent + ".visibility");
      $is_visible *= getAttr($curr_parent + ".overrideVisibility");

      if (!$is_visible)
        break;

      $curr_parent = popPath($curr_parent);
    }
  }

  return $is_visible;
}

proc string[]
getAllSetMemberships(string $object_name)
{
  //
  // Description: 
  //  Returns a list of the sets that the given shape and all of its parents 
  //  are a member of.  The specified name must be the full path of the shape.
  //
  return `delightListUserSets -containingShape $object_name`;
}

proc string[]
getAllDescendantShapes(string $parents[])
{
  string $descendant_shapes[];

  for( $parent in $parents )
  {
    if( `nodeType $parent` == "transform" )
    {
      string $children[] = `listRelatives -ni -path $parent`;
      DL_stringArrayAppend(
        $descendant_shapes, getAllDescendantShapes( $children ) );
    }
    else
    {
      $descendant_shapes[size($descendant_shapes)] = getFullPath( $parent );
    }
  }

  return $descendant_shapes;
}

proc string[]
getLinkedLights(string $geo_name,
                string $all_attribs_nodes[],
                string $visible_lights[])
{
  string  $linked_lights[];
  string  $attribs_node;
  string  $visible_linked_lights[];
  int     $use_light_linker;

  // We use the light linker unless a set was speicified in a prevaling geo
  // attribs node.
  //
  $attribs_node = DL_highestNodeWithAttrib(
    "illuminationFrom", 
    $all_attribs_nodes);

  $use_light_linker = 1;
  
  if ($attribs_node != "")
  {
    string $illumination_from_set = DGA_getIlluminationFromSet($attribs_node);

    if ($illumination_from_set != "")
    {
      $use_light_linker = 0;
    }
  }

  if ($use_light_linker)
  {
    string $obj_name;
    $obj_name = $geo_name;
    
    if (`nodeType $geo_name` == "FurFeedback")
    {
      // We need to output illuminate statements relevant for the attached 
      // geometry
      string $connections[];
      $connections = `listConnections -sh on ($geo_name + ".inputSurface")`;
      
      if (size($connections) == 0)
      {
        $connections = `listConnections -sh on ($geo_name + ".inputMesh")`;
        
        if (size($connections) != 0)
        {
          $obj_name = $connections[0];
        }
      }
      else
      {
        $obj_name = $connections[0];
      }
    }
    
    // Get a list of the lights linked to the given shape and to any sets it 
    // may be a member of.
    //
    $linked_lights = 
      `lightlink 
        -query 
        -transforms false 
        -sets false
        -object $obj_name`;
  }
  else
  {
    string  $set_members[];
    string  $illumination_from_set;
    
    $illumination_from_set = DGA_getIlluminationFromSet($attribs_node);

    string $curr_shape;

    $set_members = DL_getFlattenedSetMembers($illumination_from_set);

    // now that we've got the set members we need to get the light shapes
    for ($curr_member in $set_members)
    {
      $curr_shape = DL_getShapeFromTransform($curr_member);

      // we'll check visibility and validity (ie is it a light) later on
      $linked_lights[size($linked_lights)] = $curr_shape;
    }
  }

  $visible_linked_lights = DL_stringArrayIntersect(
    $linked_lights, 
    $visible_lights);

  return $visible_linked_lights;
}

global proc int
DL_nurbsCurveRenderableCallback( string $object )
{
  // make sure that nurbsCurves are only rendered if the
  // "outputCurves" option of the attribs node (if any) is on.
  string $shader_collection =
    DRP_getShaderCollection( `delightRenderState -qrn` );

  string $all_attribs_nodes[] =
    DL_getAllGeoAttribsNodesFromShape( $object, $shader_collection );

  string $attribs_node = 
    DL_highestNodeWithAttrib( "outputMayaCurves", $all_attribs_nodes );
  
  return DGA_outputMayaCurves( $object, $attribs_node );
}

global proc int
DL_nClothRenderableCallback( string $object )
{
  // Skip nCloth nodes if they do not have a "render as particles" attribute
  string $shader_collection =
    DRP_getShaderCollection( `delightRenderState -qrn` );

  string $all_attribs_nodes[] =
    DL_getAllGeoAttribsNodesFromShape( $object, $shader_collection );

  string $attribs_node = 
    DL_highestNodeWithAttrib( "renderNclothAsParticles", $all_attribs_nodes );

  return DGA_renderNclothAsParticles( $object, $attribs_node );
}

global proc
DL_getGeoTypeData(string $types[],
                  string $plugin_requirements[],
                  string $cache_commands[],
                  string $output_commands[])
{
  clear($types);
  clear($plugin_requirements);
  clear($cache_commands);
  clear($output_commands);

  $types[0] = "mesh";
  $plugin_requirements[0] = "";
  $cache_commands[0] = "delightCacheGeo";
  $output_commands[0] = "delightOutputGeo";

  $types[1] = "nurbsSurface";
  $plugin_requirements[1] = "";
  $cache_commands[1] = "delightCacheGeo";
  $output_commands[1] = "delightOutputGeo";

  $types[2] = "nurbsCurve";
  $plugin_requirements[2] = "DL_nurbsCurveRenderableCallback";
  $cache_commands[2] = "delightCacheGeo";
  $output_commands[2] = "delightOutputGeo";

  $types[3] = "stroke";
  $plugin_requirements[3] = "";
  $cache_commands[3] = "delightCacheGeo";
  $output_commands[3] = "delightOutputGeo";

  $types[4] = "pfxHair";
  $plugin_requirements[4] = "";
  $cache_commands[4] = "delightCacheGeo";
  $output_commands[4] = "delightOutputGeo";

  $types[5] = "particle";
  $plugin_requirements[5] = "";
  $cache_commands[5] = "delightCacheGeo";
  $output_commands[5] = "delightOutputGeo";

  $types[6] = "subdiv";
  $plugin_requirements[6] = "";
  $cache_commands[6] = "delightCacheGeo";
  $output_commands[6] = "delightOutputGeo";
  
  $types[7] = "FurFeedback";
  $plugin_requirements[7] = "Fur";
  $cache_commands[7] = "delightCacheFur";
  $output_commands[7] = "";

  $types[8] = "delightRibArchive";
  $plugin_requirements[8] = "";
  $cache_commands[8] = "delightCacheGeo";
  $output_commands[8] = "delightOutputGeo";

  $types[9] = "shaveHair";
  if( getApplicationVersionAsFloat() < 8.5 )
    $plugin_requirements[9] = "3dfm_shave8.0";
  else
    $plugin_requirements[9] = "3dfm_shave" + getApplicationVersionAsFloat();
  $cache_commands[9] = "delightCacheShave";
  $output_commands[9] = "";

  $types[10] = "instancer";
  $plugin_requirements[10] = "";
  $cache_commands[10] = "delightCacheInstancer";
  $output_commands[10] = "";

  $types[11] = "fluidShape";
  $plugin_requirements[11] = "";
  $cache_commands[11] = "delightCacheGeo";
  $output_commands[11] = "delightOutputGeo";
  
  $types[12] = "nCloth";
  $plugin_requirements[12] = "DL_nClothRenderableCallback";
  $cache_commands[12] = "delightCacheGeo";
  $output_commands[12] = "delightOutputGeo";

  $types[13] = "nParticle";
  $plugin_requirements[13] = "";
  $cache_commands[13] = "delightCacheGeo";
  $output_commands[13] = "delightOutputGeo";

  // now get user types.. if any
  if (exists("DL_userGetGeoTypeData"))
  {
    string $user_types[];
    string $user_plugin_requirements[];
    string $user_cache_commands[];
    string $user_output_commands[];

    DL_userGetGeoTypeData($user_types,
                          $user_plugin_requirements,
                          $user_cache_commands,
                          $user_output_commands);

    $types = stringArrayCatenate($types,
                                 $user_types);
    $plugin_requirements = stringArrayCatenate($plugin_requirements,
                                               $user_plugin_requirements);
    $cache_commands = stringArrayCatenate($cache_commands,
                                          $user_cache_commands);
    $output_commands = stringArrayCatenate($output_commands,
                                           $user_output_commands);
  }
}

/*
  DL_updateGeoTypeData

  Update the global arrays which describe supported geometry types by calling
  DL_getGeoTypeData.
*/
global proc 
DL_updateGeoTypeData()
{
  global string $g_DL_geoTypes[];
  global string $g_DL_geoPluginRequirements[];
  global string $g_DL_geoCacheCommands[];
  global string $g_DL_geoOutputCommands[];

  clear( $g_DL_geoTypes );
  clear( $g_DL_geoPluginRequirements );
  clear( $g_DL_geoCacheCommands );
  clear( $g_DL_geoOutputCommands );

  string $geoTypes[];
  string $geoPluginRequirements[];
  string $geoCacheCommands[];
  string $geoOutputCommands[];

  DL_getGeoTypeData(
    $geoTypes,
    $geoPluginRequirements,
    $geoCacheCommands,
    $geoOutputCommands );

  int $i;
  for( $i = 0; $i < size($geoTypes); $i++ )
  {
    string $req = $geoPluginRequirements[$i];

    if( $req != "" )
    {
      /*
        Check requirements which are a plugin name right now. These are
        obsolete, they should be checked by the functions which fill in the
        arrays (DL_getGeoTypeData and DL_userGetGeoTypeData).

        The new requirements are callbacks which take a single string argument:
        the shape to check. They should return 1 if the shape is to be rendered
        and 0 otherwise.
      */
      if( !exists( $req ) )
      {
        if( !`pluginInfo -query -loaded $req` )
          continue;

        $req = "";
      }
    }

    int $n = size($g_DL_geoTypes);
    $g_DL_geoTypes[$n] = $geoTypes[$i];
    $g_DL_geoPluginRequirements[$n] = $req;
    $g_DL_geoCacheCommands[$n] = $geoCacheCommands[$i];
    $g_DL_geoOutputCommands[$n] = $geoOutputCommands[$i];
  }
}

global proc
DL_getLightTypeData(
  string $types[],
  string $requirements_callbacks[],
  string $output_commands[],
  string $illuminate_commands[])
{
  clear($types);
  clear($requirements_callbacks);
  clear($output_commands);
  clear($illuminate_commands);

  if (exists("DL_userGetLightTypeData"))
  {
    string $user_types[];
    string $user_requirements_callbacks[];
    string $user_output_commands[];
    string $user_illuminate_commands[];

    DL_userGetLightTypeData(
      $user_types,
      $user_requirements_callbacks,
      $user_output_commands,
      $user_illuminate_commands);

    $types = stringArrayCatenate($types, $user_types);

    $requirements_callbacks = stringArrayCatenate(
      $requirements_callbacks,
      $user_requirements_callbacks);

    $output_commands = stringArrayCatenate(
      $output_commands,
      $user_output_commands);
      
    $illuminate_commands = stringArrayCatenate(
      $illuminate_commands,
      $user_illuminate_commands);
  }
}

global proc int
DL_nurbsSurfaceCanUseObjectInstance( string $geo )
{
  /*
    The trim curve on a trimmed nurbs is specified with an attribute.  Since
    Object Archives cannot contain statements changing the attribute stack
    (only geometry) we must use an inline archive for trimmed NURBS surfaces.
  */
  if( isTrimmedNURBS( $geo ) )
    return 0;

  return 1;
}

global proc int
DL_FurFeedbackCanUseObjectInstance( string $geo )
{
  return 0;
}

global proc int
DL_shaveHairCanUseObjectInstance( string $geo )
{
  return 0;
}

global proc int
DL_fluidShapeCanUseObjectInstance( string $geo )
{
  return 0;
}

/*
  canUseObjectInstance

  Calls a function based on the geo type to determine if the geo can be output
  as an object or if it needs to be put in an inline archive.

  That function needs not always exist but can be provided for user geo types.
  For example, to export geo of type funkyCurve in archives one would write a
  'global proc int DL_funkyCurveCanUseObjectInstance( string $geo )' function
  which always returns 0.

  3dfm defines a few such functions for its built-in types, see above.
*/
proc
int canUseObjectInstance( string $geo, string $geo_type )
{
  int $useObjectInstance = 1;

  string $func_name = "DL_" + $geo_type + "CanUseObjectInstance";
  if( exists($func_name) )
  {
    $useObjectInstance = eval( $func_name + "( \"" + $geo + "\" );" );
  }

  return $useObjectInstance;
}

proc string
getGeoCacheCommand(string $geo)
{
  global string $g_DL_geoTypes[];
  global string $g_DL_geoCacheCommands[];
  
  int $i;
  for ($i = 0; $i < size($g_DL_geoTypes); $i++)
  {
    if (`objectType -isType $g_DL_geoTypes[$i] $geo`)
    {
      return $g_DL_geoCacheCommands[$i];
    }
  }

  return "";
}

global proc string[]
getActiveCacheCommands()
{
  global string $g_DL_geoCacheCommands[];
  return DL_stringArrayRemoveDuplicates($g_DL_geoCacheCommands);
}

proc string
getLightOutputCommand(string $light)
{
  string $types[];
  string $requirements_callbacks[];
  string $output_commands[];
  string $illuminate_commands[];

  DL_getLightTypeData(
    $types, 
    $requirements_callbacks, 
    $output_commands, 
    $illuminate_commands);

  string $output_command = "";

  for ($i = 0; $i < size($types); $i++)
  {
    if (`objectType -isType $types[$i] $light`)
    {
      if (   $requirements_callbacks[$i] == ""
          || (   exists($requirements_callbacks[$i])
              && eval($requirements_callbacks[$i]) != 0))
      {      
        $output_command = $output_commands[$i];
        break;
      }
    }
  }

  return $output_command;
}

proc string
getLightIlluminateCommand(string $light)
{
  string $types[];
  string $requirements_callbacks[];
  string $output_commands[];
  string $illuminate_commands[];

  DL_getLightTypeData(
    $types, 
    $requirements_callbacks, 
    $output_commands, 
    $illuminate_commands);

  string $illuminate_command = "";

  for ($i = 0; $i < size($types); $i++)
  {
    if (`objectType -isType $types[$i] $light`)
    {
      if (   $requirements_callbacks[$i] == ""
          || (   exists($requirements_callbacks[$i])
              && eval($requirements_callbacks[$i]) != 0))
      {
        $illuminate_command = $illuminate_commands[$i];
        break;
      }
    }
  }

  return $illuminate_command;
}

proc int
isIntermediateObject(string $object)
{
  int $is_intermediate;
  
  if (objExists($object + ".intermediateObject"))
  {
    $is_intermediate =  getAttr($object + ".intermediateObject");
  }
  else
  {
    $is_intermediate = 0;
  }
  
  return $is_intermediate;
}
  
proc int
isMeshGeneratingSubdivObject(string $object)
{
  // Check if this is a polygonal mesh used to generate a subdiv
  if( objExists( $object + ".outMesh" ) )
  {
    $connected_objs = `listConnections ($object + ".outMesh")`;

    for( $i = 0; $i < size($connected_objs); $i++ )
    {
      if( nodeType( $connected_objs[$i] ) == "polyToSubdiv" )
      {
        return 1;
      }
    }
  }
  
  return 0;
}

proc int
isTextureReferenceObject(string $object)
{
  if (size(`ls -lights $object`) == 0 )
  {
    /*
      Check if this is a texture reference object. Those are not rendered by
      maya so we'll skip them as well. I couldn't find a cleaner way to figure
      that out, does anyone know?
    */
    string $obj_msg = $object + ".message";
    string $connected_objs[] = `listConnections -shapes true $obj_msg`;

    int $i;

    for( $i = 0; $i < size($connected_objs); $i++ )
    {
      if( objExists( $connected_objs[$i] + ".referenceObject" ) &&
          isConnected( $obj_msg, $connected_objs[$i] + ".referenceObject" ) )
      {
        return true;
      }
    }
  }
  
  return false;
}

proc int
isObjectRenderableType(string $object)
{
  global string $g_DL_geoTypes[];
  global string $g_DL_geoPluginRequirements[];

  int $is_renderable_type = 0;
  int $i;

  for ($i = 0; $i < size($g_DL_geoTypes); $i++)
  {
    $is_renderable_type = `objectType -isType $g_DL_geoTypes[$i] $object`;

    if ($is_renderable_type)
      break;
  }

  if( !$is_renderable_type )
    return 0;

  if( $g_DL_geoPluginRequirements[$i] != "" )
  {
    $is_renderable_type =
      eval( $g_DL_geoPluginRequirements[$i] + " " + $object );
  }

  if(    isIntermediateObject($object)
      || isTextureReferenceObject($object)
      || isMeshGeneratingSubdivObject($object) )
  {
    $is_renderable_type = 0;
  }
  
  return $is_renderable_type;
}

proc int
geoCastsShadows(string $geo)
{
  if( objExists( $geo + ".castsShadows" ) )
    return `getAttr ($geo + ".castsShadows")`;

  return 1;
}

proc string[]
getShadowCastingGeometry(string $light_name, 
                         string $all_geometry[], 
                         string $shader_collection)
{
  string  $linked_objects[];
  string  $attribs_node;
  string  $visible_linked_objects[];
  int     $use_light_linker = 1;

  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);

  string $attr = "shadowObjects";
  $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
  
  if ($node_with_attr != "")
  {
    string  $shadow_objects_set = DLA_getShadowObjectsSet($node_with_attr);

    if ($shadow_objects_set != "")
    {
      $use_light_linker = 0;

      string  $set_members[];
      string $curr_shape;

      $set_members = DL_getFlattenedSetMembers($shadow_objects_set);

      // Now that we've got the set members we need to get the geo shapes.
      // We'll check visibility and validity (ie is it a renderable type) later on
      $linked_objects = getAllDescendantShapes($set_members);
    }
  }

  if( $use_light_linker == 1 )
  {
    // No light attribs node or no object set specified, so we use the objects
    // linked to this light. We'll remove those with .castsShadows == 0 later.
    $linked_objects = `lightlink -q -transforms false -light $light_name`;
  }

  $linked_objects = DL_stringArrayRemoveDuplicates($linked_objects);

  // now we need to check if the linked objects are valid types and are visible
  string $object_type;

  for ($curr_object in $linked_objects)
  {
    if (   isObjectRenderableType($curr_object)
        && isObjectVisible($curr_object) )
    {
      if( !$use_light_linker || geoCastsShadows($curr_object) )
      {
        // we want the full path of the linked object
        $visible_linked_objects[size($visible_linked_objects)] = getFullPath($curr_object);
      }
      
      string $connected_fur_feedbacks[];
      $connected_fur_feedback = `listConnections -type FurFeedback -sh on $curr_object`;
      $connected_fur_feedback = DL_stringArrayRemoveDuplicates($connected_fur_feedback);
      for ($curr_fur in $connected_fur_feedback)
      {
        if (   isObjectRenderableType($curr_fur)
            && isObjectVisible($curr_fur)
            && (!$use_light_linker || geoCastsShadows($curr_fur)) )
        {
          $visible_linked_objects[size($visible_linked_objects)] = 
            getFullPath($curr_fur);
        }
      }
    }
  }

  return DL_stringArrayIntersect($visible_linked_objects, $all_geometry);
}

proc string[]
getAllShapesInScene()
{
  string  $shapes[];

  $shapes = `ls -allPaths -shapes -long -noIntermediate`;

  return $shapes;
}

proc string[]
getShapesInLayer(string $layer_name)
{
  string $shapes[];

  if ($layer_name == "defaultRenderLayer")
  {
    // this layer contains every objects of the scene
    $shapes = getAllShapesInScene();
  }
  else
  {
    string $layer_children[];

    if (attributeExists("layerChildren", $layer_name))
    {
      $layer_children = `listConnections ($layer_name + ".layerChildren")`;
    }

    if (size($layer_children) == 0)
    {
      string $layer_members[];

      $layer_members = `listConnections ($layer_name + ".renderInfo")`;

      $shapes = getAllDescendantShapes($layer_members);
    }
  }

  return $shapes;
}


proc string[]
getVisibleLights(string $light_set,
                 string $render_layer_shapes[])
{
  string  $listed_lights[];
  string  $visible_lights[];
  string $all_light_types[] = `listNodeTypes light`;
      
  if ($light_set != "")
  {
    string $set_members[] = DL_getFlattenedSetMembers($light_set);
    $set_members = getAllDescendantShapes($set_members);
    
    for ($curr_light in $set_members)
    {
      string $light_type = `objectType $curr_light`;

      if ( `stringArrayContains $light_type $all_light_types` )
      {
        $listed_lights[size($listed_lights)] = getFullPath($curr_light);
      }
    }
  }
  else
  {
    string $list_lights_cmd = DL_getListLightNodesCmd();
    $list_lights_cmd += "-l";
    $listed_lights = eval($list_lights_cmd);
  }

  for ($curr_light in $listed_lights)
  {
    if (isObjectVisible($curr_light))
      $visible_lights[size($visible_lights)] = $curr_light;
  }

  return DL_stringArrayIntersect($visible_lights, $render_layer_shapes);
}

proc string[]
removeArchivedLights(string $dra_nodes_to_consider[], string $lights[])
{
  // Remove the lights to render listed in render passes associated with each 
  // RIB Archive node in the list we receive.
  string $lights_to_remove[];
  clear($lights_to_remove);
  
  for ($curr_archive in $dra_nodes_to_consider)
  {
    // Find associated render passes and gather their lights
    string $connected_render_passes[];
    $connected_render_passes = `listConnections -d false -s true 
      -t "delightRenderPass" ($curr_archive + ".connectedRenderPass")`;

    for ($render_pass in $connected_render_passes)
    {
      if (   getAttr($render_pass + ".renderMode") == 2
          && getAttr($render_pass + ".archiveLighting") == 2)
      {
        string $lights_to_render_set;
        $lights_to_render_set = DRP_getLightsToRenderSet($render_pass);
        
        string $layer = DRP_getLayerToRender($render_pass);
        string $render_layer_shapes[] = getShapesInLayer($layer);
        
        string $visible_lights[];
        $visible_lights = getVisibleLights(
          $lights_to_render_set,
          $render_layer_shapes);

        $lights_to_remove = stringArrayCatenate($visible_lights, 
          $lights_to_remove);
      }
    }
  }
  
  return stringArrayRemove($lights_to_remove, $lights);
}

proc string[]
getVisibleClippingPlanes(string $clipping_plane_set)
{
  string  $listed_planes[];
  string  $visible_planes[];

  if ($clipping_plane_set != "")
  {
    string $set_members[] = DL_getFlattenedSetMembers($clipping_plane_set);

    for ($member in $set_members)
    {
      string $curr_shape = DL_getShapeFromTransform($member);

      if (`objectType $curr_shape` == "delightClippingPlane")
        $listed_planes[size($listed_planes)] = $curr_shape;
    }
  }
  // Default behavior is to not use clipping planes 
  // if there's no clipping plane set.

  for ($curr_plane in $listed_planes)
  {
    if (isObjectVisible($curr_plane))
      $visible_planes[size($visible_planes)] = $curr_plane;
  }

  return $visible_planes;
}

proc string[]
removeArchivedClippingPlanes(string $dra_nodes_to_consider[], 
                             string $clipping_planes[])
{
  // Remove the clipping planes in the render set of any render passes 
  // associated with each RIB Archive node in the list we receive.
  string $clippings_to_remove[];
  clear($clippings_to_remove);
  
  for ($curr_archive in $dra_nodes_to_consider)
  {
    // Find associated render passes and gather their clipping planes
    string $connected_render_passes[];
    $connected_render_passes = `listConnections -d false -s true 
      -t "delightRenderPass" ($curr_archive + ".connectedRenderPass")`;
      
    for ($render_pass in $connected_render_passes)
    {
      if (getAttr($render_pass + ".renderMode") == 2)
      {
        string $clipping_planes_to_render_set;
        $clipping_planes_to_render_set = 
          DRP_getClippingPlanesToRenderSet($render_pass);
        
        string $visible_clippings[];
        $visible_clippings = 
          getVisibleClippingPlanes($clipping_planes_to_render_set);
        
        $clippings_to_remove = stringArrayCatenate($visible_clippings, 
          $clippings_to_remove);
      }
    }
  }
  
  return stringArrayRemove($clippings_to_remove, $clipping_planes);
}

proc string[]
getVisibleCoordinateSystems(string $coordinate_system_set)
{
  string  $listed_systems[];
  string  $visible_systems[];

  if ($coordinate_system_set != "")
  {
    string $set_members[] = DL_getFlattenedSetMembers($coordinate_system_set);

    $listed_systems = `ls -type "delightCoordinateSystem" $set_members`;
  }
  else
  {
    $listed_systems = `ls -type "delightCoordinateSystem"`;
  }

  for ($curr_system in $listed_systems)
  {
    if (isObjectVisible($curr_system))
      $visible_systems[size($visible_systems)] = $curr_system;
  }

  return $visible_systems;
}

proc string[]
removeArchivedCoordinateSystems(string $dra_nodes_to_consider[], 
                                string $coordinate_systems[])
{
  // Remove the coordinate system listed in the render set of render passes 
  // associated with each RIB Archive node in the list we receive.
  string $coord_sys_to_remove[];
  clear($coord_sys_to_remove);
  
  for ($curr_archive in $dra_nodes_to_consider)
  {
    // Find associated render passes and gather their coordinate systems
    string $connected_render_passes[];
    $connected_render_passes = `listConnections -d false -s true 
      -t "delightRenderPass" ($curr_archive + ".connectedRenderPass")`;
      
    for ($render_pass in $connected_render_passes)
    {
      if (getAttr($render_pass + ".renderMode") == 2)
      {
        string $objects_to_render_set;
        $objects_to_render_set = 
          DRP_getObjectsToRenderSet($render_pass);

        string $visible_coord_sys[];
        $visible_coord_sys = getVisibleCoordinateSystems($objects_to_render_set);
        
        $coord_sys_to_remove = stringArrayCatenate($visible_coord_sys, 
          $coord_sys_to_remove);
      }
    }
  }
  
  return stringArrayRemove($coord_sys_to_remove, $coordinate_systems);
}

proc string[]
getGeometryInSet(string $object_set)
{
  string $shapes[];

  if ($object_set != "")
  {
    string $set_members[];

    $set_members = DL_getFlattenedSetMembers($object_set);

    $shapes = getAllDescendantShapes($set_members);
  }
  else
  {
    $shapes = getAllShapesInScene();
  }

  return $shapes;
}

proc string[]
getRenderableGeometry(string $object_set, string $render_layer_shapes[])
{
  // TODO: this needs work to handle as many cases as possible

  string  $layer_geometry[];
  string  $sets_geometry[];
  string  $renderable_geometry[];

  $sets_geometry = getGeometryInSet($object_set);
  $sets_geometry = DL_stringArrayIntersect($sets_geometry, $render_layer_shapes);
  
  for ($curr_geo in $sets_geometry)
  {
    if (isObjectRenderableType($curr_geo))
    {
      $renderable_geometry[size($renderable_geometry)] = $curr_geo;
    }
  }

  return $renderable_geometry;
}

proc string[]
getAllRenderableVisibleGeometry(string $object_set,
                                string $render_layer_shapes[])
{
  string $renderable_geometry[];
  string $visible_geometry[];

  $renderable_geometry = getRenderableGeometry($object_set,
                                               $render_layer_shapes);

  for ($curr_geo in $renderable_geometry)
  {
    if (isObjectVisible($curr_geo))
    {
      $visible_geometry[size($visible_geometry)] = $curr_geo;
    }
  }

  return $visible_geometry;
}

global proc string[]
getRenderableVisibleGeometry(string $object_set, string $layer)
{
  string $render_layer_shapes[] = getShapesInLayer($layer);
  
  return getAllRenderableVisibleGeometry(
           $object_set,
           $render_layer_shapes);
}

proc string []
removeArchivedGeometry(string $dra_nodes_to_consider[],
                       string $all_geometry[])
{
  // Remove all objects to render in render passes associated with each RIB
  // Archive nodes in the list we receive.
  string $geometry_to_remove[];
  clear($geometry_to_remove);

  for ($curr_archive in $dra_nodes_to_consider)
  {
    // Find associated render passes and gather their geometry
    string $connected_render_passes[];
    $connected_render_passes = `listConnections -d false -s true 
      -t "delightRenderPass" ($curr_archive + ".connectedRenderPass")`;
      
    for ($render_pass in $connected_render_passes)
    {
      if (getAttr($render_pass + ".renderMode") == 2)
      {
        string $objects_to_render_set;
        string $layer_to_render;
        
        $objects_to_render_set = DRP_getObjectsToRenderSet($render_pass);
        $layer_to_render = DRP_getLayerToRender($render_pass);
        
        string $render_layer_shapes[] = getShapesInLayer($layer_to_render);
        
        string $renderable_geo[];
        $renderable_geo = getAllRenderableVisibleGeometry(
          $objects_to_render_set,
          $render_layer_shapes);

        // The RIB Archive node connected to this render pass may be in its 
        // objects to render list, but we do not want to remove it 
        string $keep_curr_archive[];
        $keep_cur_archive[0] = $curr_archive;
        $renderable_geo = stringArrayRemove($keep_cur_archive, $renderable_geo);

        $geometry_to_remove = stringArrayCatenate($renderable_geo, 
          $geometry_to_remove);
      }
    }
  }
  
  return stringArrayRemove($geometry_to_remove, $all_geometry);
}      

proc int
isValidInstancerGeometry(string $object)
{
  int $is_valid_geo;

  $is_valid_geo = isObjectRenderableType($object);

  return $is_valid_geo;
}

proc string[]
getInstancersInSet(string $object_set)
{
  string $instancers[];

  if ($object_set != "")
  {
    string $set_members[];

    $set_members = DL_getFlattenedSetMembers($object_set);

    // TODO: should we handle instancers that are not necessarily in the set
    //       but whose ancestor transforms are?
    $instancers = `ls -long -type "instancer" $set_members`;
  }
  else
  {
    $instancers = `ls -allPaths -long -type "instancer"`;
  }

  return $instancers;
}

proc string[]
getInstancersInLayer(string $layer_name)
{
  string $instancers[];

  if ($layer_name == "defaultRenderLayer")
  {
    $instancers = `ls -allPaths -long -type "instancer"`;
  }
  else
  {
    string $layer_children[];

    if (attributeExists("layerChildren", $layer_name))
    {
      $layer_children = `listConnections ($layer_name + ".layerChildren")`;
    }

    if (size($layer_children) == 0)
    {
      string $layer_members[];

      $layer_members = `listConnections ($layer_name + ".renderInfo")`;

      // TODO: should we handle instancers that are not necessarily in the layer
      //       but whose ancestor transforms are?

      // Note: we need -allPaths here. When an instanced object is directly 
      //       in the layer, we can't tell which instance is actually in the 
      //       layer, so we treat all instances to be in the layer.
      $instancers = `ls -allPaths -long -type "instancer" $layer_members`;
    }
  }

  return $instancers;
}

proc string[]
getVisibleInstancers(string $object_set, 
                     string $layer, 
                     string $archived_instancers[], 
                     string $renderable_instancer_geo[],
                     string $render_layer_shapes[])
{
  string $instancers_in_set[];
  string $instancers_in_layer[];
  string $all_instancers[];
  string $visible_instancers[];

  clear $renderable_instancer_geo;

  $instancers_in_set = getInstancersInSet($object_set);
  $instancers_in_layer = getInstancersInLayer($layer);

  $all_instancers = DL_stringArrayIntersect($instancers_in_set, $instancers_in_layer);
  $all_instancers = stringArrayRemove($archived_instancers, $all_instancers);

  for ($instancer in $all_instancers)
  {
    if (isObjectVisible($instancer))
    {
      string $curr_instancer_geo[] = `delightCacheInstancer -listGeometry $instancer`;
      int $has_valid_geo = 0;

      // Filter out geo that is not in the rendered layer
      if (size($render_layer_shapes) != 0)
      {
        $curr_instancer_geo = DL_stringArrayIntersect(
          $curr_instancer_geo, 
          $render_layer_shapes);
      }
        
      for ($geo in $curr_instancer_geo)
      {
        int $is_valid_geo = 1;

        // The geo must be in the given set.
        if ($object_set != "")
        {
          string $sets_containing_geo[] = getAllSetMemberships($geo);
          $is_valid_geo = stringArrayContains($object_set, $sets_containing_geo);
        }

        if ($is_valid_geo)
          $is_valid_geo = isValidInstancerGeometry($geo);

        if ($is_valid_geo)
        {
          $has_valid_geo = 1;
          $renderable_instancer_geo[size($renderable_instancer_geo)] = $geo;
        }
      }

      if ($has_valid_geo)
        $visible_instancers[size($visible_instancers)] = $instancer;
    }
  }

  $renderable_instancer_geo = DL_stringArrayRemoveDuplicates($renderable_instancer_geo);

  return $visible_instancers;
}

proc string[]
getShadowCastingInstancers(string $light_name, 
                           string $particle_instancers[], 
                           string $shader_collection, 
                           string $shadow_casting_instancer_geo[])
{
  string $shadow_casting_instancers[];
  string $instancers_to_consider[];
  string $attribs_node;
  string $shadow_objects_set;
  int $use_light_linker;

  clear $shadow_casting_instancer_geo;

  $instancers_to_consider = $particle_instancers;

  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);

  $use_light_linker = 1;

  string $attr = "shadowCamera";
  string $node_with_attr = DLA_getNodeWithAttribute(
    $attr, 
    $attribs_node, 
    $light_name);

  if ($node_with_attr != "")
  {
    $shadow_objects_set = DLA_getShadowObjectsSet($node_with_attr);

    if ($shadow_objects_set != "")
    {
      $use_light_linker = 0;

      string $set_members[] = DL_getFlattenedSetMembers($shadow_objects_set);

      // TODO: should we handle instancers that are not necessarily in the set
      //       but whose ancestor transforms are?
      $instancers_to_consider = `ls -long -type "instancer" $set_members`;

      $instancers_to_consider = 
        DL_stringArrayIntersect($instancers_to_consider, $particle_instancers);
    }
  }

  for ($instancer in $instancers_to_consider)
  {
    string $curr_instancer_geo[] = `delightCacheInstancer -listGeometry -cached $instancer`;

    int $has_shadow_geo = 0;

    for ($geo in $curr_instancer_geo)
    {
      int $is_shadow_geo;
      string $obj_to_test = $geo;
      string $geo_type = `nodeType $geo`;

      // FurFeedback nodes are not directly linked to lights (i.e. 
      // they will not show up in a lightlink query), so we use 
      // the geometry connected to them.
      if ($geo_type == "FurFeedback")
      {
        string $connections[];
        $connections = `listConnections -sh on ($geo + ".inputSurface")`;

        if (size($connections) == 0)
        {
          $connections = `listConnections -sh on ($geo + ".inputMesh")`;
        }

        if (size($connections) != 0)
        {
          string $connected_obj = $connections[0];

          if (isValidInstancerGeometry($connected_obj))
            $obj_to_test = $connected_obj;
        }
      }

      if ($use_light_linker)
      {
        string $lights_linked_to_geo[] = 
          `lightlink -q -transforms false -sets false -object $obj_to_test`;

        $lights_linked_to_geo = `ls -long $lights_linked_to_geo`;

        $is_shadow_geo = stringArrayContains($light_name, $lights_linked_to_geo);
      }
      else
      {
        string $sets_containing_geo[] = getAllSetMemberships($geo);
        $is_shadow_geo = stringArrayContains($shadow_objects_set, $sets_containing_geo);

        // In getShadowCastingGeometry(), a FurFeedback can still be considered 
        // as long as its connected surface is in the shadow object set.
        // Using this behavior to be consistent (even though it may or 
        // may not be ideal).
        if (!$is_shadow_geo && $geo_type == "FurFeedback")
        {
          $sets_containing_geo = getAllSetMemberships($obj_to_test);
          $is_shadow_geo =  stringArrayContains($shadow_objects_set, $sets_containing_geo);
        }
      }

      if ($is_shadow_geo)
      {
        $has_shadow_geo = 1;
        $shadow_casting_instancer_geo[size($shadow_casting_instancer_geo)] = $geo;
      }
    }

    if ($has_shadow_geo)
      $shadow_casting_instancers[size($shadow_casting_instancers)] = $instancer;
  }

  $shadow_casting_instancer_geo = 
    DL_stringArrayRemoveDuplicates($shadow_casting_instancer_geo);

  return $shadow_casting_instancers;
}

proc string []
getArchivedInstancers(string $dra_nodes_to_consider[],
                      string $render_layer_shapes[])
{
  // Get instancers in render passes associated with each 
  // RIB Archive node in the list we receive.
  string $instancers_to_remove[];

  for ($curr_archive in $dra_nodes_to_consider)
  {
    // Find associated render passes and gather their instancers
    string $connected_render_passes[];
    $connected_render_passes = `listConnections -d false -s true 
      -t "delightRenderPass" ($curr_archive + ".connectedRenderPass")`;

    for ($render_pass in $connected_render_passes)
    {
      if (getAttr($render_pass + ".renderMode") == 2)
      {
        string $objects_to_render_set;
        string $layer_to_render;

        $objects_to_render_set = DRP_getObjectsToRenderSet($render_pass);
        $layer_to_render = DRP_getLayerToRender($render_pass);

        string $visible_instancers[];
        string $archived_instancers_placeholder[];
        string $instancer_geo_placeholder[];

        $visible_instancers = getVisibleInstancers(
          $objects_to_render_set,
          $layer_to_render,
          $archived_instancers_placeholder, 
          $instancer_geo_placeholder,
          $render_layer_shapes);

        $instancers_to_remove = 
          stringArrayCatenate($visible_instancers, $instancers_to_remove);
      }
    }
  }

  return $instancers_to_remove;
}

proc string[]
DRP_getShadowMappedLights(string $visible_lights[], 
                          string $shader_collection)
{
  string $shadow_mapped_lights[];

  string $curr_light;

  for ($curr_light in $visible_lights)
  {
    // Shadows not supported with area lights for now.
    if (`nodeType $curr_light` == "areaLight")
      continue;

    string $curr_attribs_node;

    $curr_attribs_node = 
      DL_getHighestLightAttribsNodeFromShape($curr_light, 
                                             $shader_collection);

    $attr = "generateShadowMaps";
    $node_with_attr = DLA_getNodeWithAttribute(
      $attr, 
      $curr_attribs_node, 
      $curr_light);

    if ($node_with_attr != "")
    {
      int $generate_shads;      
      $generate_shads = DLA_getGenerateShadowMaps($node_with_attr);

      if ($generate_shads)
      {
        $shadow_mapped_lights[size($shadow_mapped_lights)] = $curr_light;
      }
    }
    else
    {
      int $create_shadow_map_file;
      $create_shadow_map_file = 0;
      
      if (attributeExists("useDepthMapShadows", $curr_light))
      {
        if (getAttr($curr_light + ".useDepthMapShadows") == 1)
        {
          $create_shadow_map_file = 1;

          if (attributeExists("reuseDmap", $curr_light))
          {
            if (getAttr($curr_light + ".reuseDmap") == 1)
            {
              string $filename;
              $filename = getDepthMapFilename($curr_light);
              
              if (`filetest -r $filename` == 1)
              {
                $create_shadow_map_file = 0;
                print ("Reusing previously rendered shadow depth map file " + $filename + "\n");
              }
            }
          }
        }
      }
      
      if ($create_shadow_map_file == 1)
      {
        $shadow_mapped_lights[size($shadow_mapped_lights)] = $curr_light;
      }
    }
  }

  return $shadow_mapped_lights;
}


proc int
DRP_checkSceneForXformBlur(string $all_geos[], 
                           string $all_lights[], 
                           int $global_xform_blur, 
                           string $shader_collection)
{
  int     $is_blurring;
  string  $curr_attribs_nodes[];
  int     $curr_blur_state;

  $is_blurring = 0;

  // loop over all the geometry and stop once we hit any motion blurring geo
  for ($curr_geo in $all_geos)
  {
    $curr_attribs_nodes = 
      DL_getAllGeoAttribsNodesFromShape($curr_geo, $shader_collection);

    $curr_attribs_node = DL_highestNodeWithAttrib("transformationBlur",
                                                  $curr_attribs_nodes);

    if ($curr_attribs_node != "")
    {
      $curr_blur_state = DGA_isXformBlurring($curr_attribs_node,
                                             $global_xform_blur);
    }
    else if ( objExists($curr_geo + ".motionBlur") )
    {
      $curr_blur_state = 
        $global_xform_blur && getAttr($curr_geo + ".motionBlur");
    }
    else
      $curr_blur_state = $global_xform_blur;


    $is_blurring = $is_blurring || $curr_blur_state;

    if ($is_blurring)
      break;
  }

  // if no geo are blurring, try the lights
  if (!$is_blurring)
  {
    for ($curr_light in $all_lights)
    {
      $curr_attribs_nodes = 
        DL_getAllLightAttribsNodesFromShape($curr_light, $shader_collection);

      $curr_attribs_node = DL_highestNodeWithAttrib("transformationBlur",
                                                    $curr_attribs_nodes);

      if ($curr_attribs_node != "")
      {
        $curr_blur_state = DLA_isXformBlurring($curr_attribs_node,
                                               $global_xform_blur);
      }
      else
        $curr_blur_state = 0;

      $is_blurring = $is_blurring || $curr_blur_state;

      if ($is_blurring)
        break;
    }
  }

  return $is_blurring;
}

proc int
DRP_checkSceneForDeformBlur(string $all_geos[], 
                            int $global_deform_blur, 
                            string $shader_collection)
{
  int     $is_blurring;
  string  $curr_attribs_nodes[];
  int     $curr_blur_state;
  string  $all_geos[];

  $is_blurring = 0;

  // loop over all the geometry and stop once we hit any motion blurring geo
  for ($curr_geo in $all_geos)
  {
    $curr_attribs_nodes = 
      DL_getAllGeoAttribsNodesFromShape($curr_geo, $shader_collection);

    $curr_attribs_node = DL_highestNodeWithAttrib("deformationBlur",
                                                  $curr_attribs_nodes);

    if ($curr_attribs_node != "")
    {
      $curr_blur_state = DGA_isDeformBlurring($curr_attribs_node,
                                              $global_deform_blur);
    }
    else if ( objExists($curr_geo + ".motionBlur") )
    {
      $curr_blur_state = 
        $global_deform_blur && getAttr($curr_geo + ".motionBlur");
    }
    else 
      $curr_blur_state = $global_deform_blur;

    $is_blurring = $is_blurring || $curr_blur_state;

    if ($is_blurring)
      break;
  }

  return $is_blurring;
}

global proc
DRP_checkConnectToRenderGlobals(string $node_name)
{
  int $value = getAttr($node_name + ".connectToRenderGlobals");

  string $resolution_node[];
  $resolution_node = `listConnections -type "resolution" "defaultRenderGlobals"`;

  if ($value == 1)
  {
    DRP_connectToRenderGlobals($node_name);
  }
  else
  {
    DRP_disconnectFromRenderGlobals($node_name);
  }
}
 
global proc
DRP_connectToRenderGlobals(string $node_name)
{
  string $resolution_node[];
  $resolution_node = `listConnections -type "resolution" "defaultRenderGlobals"`;
  
  string $src_attrib;
  string $dest_attrib;
  
  $src_attrib = $resolution_node[0] + ".width";
  $dest_attrib = $node_name + ".resolutionX";
  if (!`isConnected $src_attrib $dest_attrib`)
  {
    connectAttr $src_attrib $dest_attrib;
  }
  
  $src_attrib = $resolution_node[0] + ".height";
  $dest_attrib = $node_name + ".resolutionY";
  if (!`isConnected $src_attrib $dest_attrib`)
  {
    connectAttr $src_attrib $dest_attrib;
  }
  
  string $connected_expr[];
  $dest_attrib = $node_name + ".pixelAspectRatio";

  $connected_expr = `listConnections -type "expression" $dest_attrib`; 
  if (size($connected_expr) == 0)
  {
    string $expr_node_name = ($node_name + "_pixelRatioExpr");
    
    if (objExists($expr_node_name))
    {
      connectAttr ($expr_node_name + ".output[0]") $dest_attrib;
    }
    else
    {
      expression 
        -name $expr_node_name 
        -alwaysEvaluate false 
        -s ($dest_attrib + 
         " = " + 
         $resolution_node[0] + 
         ".height / " +
         $resolution_node[0] +
         ".width * " +
         $resolution_node[0] + 
         ".deviceAspectRatio");
    }
  }
}

global proc
DRP_disconnectFromRenderGlobals(string $node_name)
{
  string $resolution_node[];
  $resolution_node = `listConnections -type "resolution" "defaultRenderGlobals"`;
  
  string $src_attrib;
  string $dest_attrib;
  
  $src_attrib = $resolution_node[0] + ".width";
  $dest_attrib = $node_name + ".resolutionX";
  if (`isConnected $src_attrib $dest_attrib`)
  {
    disconnectAttr $src_attrib $dest_attrib;
  }
  
  $src_attrib = $resolution_node[0] + ".height";
  $dest_attrib = $node_name + ".resolutionY";
  if (`isConnected $src_attrib $dest_attrib`)
  {
    disconnectAttr $src_attrib $dest_attrib;
  }
  
  string $connected_expr[];
  $dest_attrib = $node_name + ".pixelAspectRatio";
  $connected_expr = `listConnections -type "expression" $dest_attrib`; 
  
  if (size($connected_expr) != 0)
  {
    disconnectAttr ($connected_expr[0] + ".output[0]") $dest_attrib;
    
    if (`referenceQuery -isNodeReferenced $connected_expr[0]` == 0)
    {
      delete $connected_expr[0];
    }
  }
}

// ----------------------------------------------------------------------------
// Procedures which display and update the progress window
//

global string $g_progress_message;
global int $g_progress_value;
global int $g_progress_num_items;
global int $g_progress_current_item;
global int $g_progress_current_range;
global int $g_progress_current_range_start;
global float $g_progress_last_update;

proc
beginProgress( string $status, int $max )
{
  if (DL_haveMayaUI())
  {
    progressWindow -title "3Delight"
                   -isInterruptable true
                   -status $status
                   -minValue 0
                   -maxValue $max;
  }
  else
  {
    print($status + "\n");
  }

  global string $g_progress_message;
  global int $g_progress_value;
  global int $g_progress_current_range;
  global int $g_progress_current_range_start;
  global float $g_progress_last_update;

  $g_progress_message = $status;
  $g_progress_value = 0;
  $g_progress_current_range = 0;
  $g_progress_current_range_start = 0;
  $g_progress_last_update = `timerX`;
}

proc
beginProgressRange( int $percent_range, int $num_items )
{
  global int $g_progress_num_items;
  global int $g_progress_current_item;
  global int $g_progress_current_range;
  global int $g_progress_current_range_start;

  $g_progress_num_items = $num_items;
  $g_progress_current_item = 0;
  $g_progress_current_range_start += $g_progress_current_range;
  $g_progress_current_range = $percent_range;
}

proc
incProgress( int $increment, int $console_output )
{
  global string $g_progress_message;
  global int $g_progress_value;
  global int $g_progress_num_items;
  global int $g_progress_current_item;
  global int $g_progress_current_range;
  global int $g_progress_current_range_start;
  global float $g_progress_last_update;

  $g_progress_current_item += $increment;

  if( $g_progress_current_item > $g_progress_num_items )
    $g_progress_current_item = $g_progress_num_items;

  int $new_value =
    $g_progress_current_range * $g_progress_current_item
      / $g_progress_num_items;

  $new_value += $g_progress_current_range_start;

  if( $new_value > $g_progress_value )
  {
    if( DL_haveMayaUI() )
    {
      // Avoid UI updates more than once every 0.1s
      float $time = `timerX -startTime $g_progress_last_update`;
      if( $time > 0.1 )
      {
        progressWindow -edit -progress $new_value;
        if( $g_progress_message != "" )
        {
          int $pct = ($new_value - 1) % 100 + 1;
          progressWindow -edit -status ($g_progress_message + $pct + "%");
        }

        $g_progress_last_update = `timerX`;
        $g_progress_value = $new_value;
      }
    }
    else
    {
      if( $console_output )
      {
        int $i;
        for( $i = $g_progress_value; $i < $new_value; $i++ )
        { 
          if( $i % 2 )
          {
            print ".";
          }
        }

        if( $new_value == $g_progress_current_range )
        {
          print "\n";
        }
      }
      $g_progress_value = $new_value;
    }
  }
}

proc
setProgressMessage( string $status, int $console_output )
{
  global string $g_progress_message;
  $g_progress_message = $status;

  if (DL_haveMayaUI())
  {
    progressWindow -edit -status $status;
  }
  else if ($console_output)
  {
    print($status + "\n");
  }
}

proc
outputDisplayProgressMessage(string $render_pass, int $frame_number)
{
  string $progress_message;
  $progress_message = ("Frame " + $frame_number + ": rendering displays");
  
  setProgressMessage($progress_message, 0);

  if (!DL_haveMayaUI())
  {
    $progress_message += ": ";
    string $image_file;
    string $driver;
    
    if (DRP_getRenderPrimaryDisplay($render_pass))
    {
      $driver = getAttr($render_pass + ".displayDriver");

      $image_file = `getAttr($render_pass + ".imageFilename")`;
      $image_file = DL_getExpandedFilename(
        $image_file, 
        "", 
        $render_pass, 
        $driver);

      if ($image_file == "")
      {
        $image_file = "<" + DRP_getDisplayDriver($render_pass) + ">";
      }
      
      $progress_message += $image_file;
    }
    
    if (DRP_getRenderSecondaryDisplays($render_pass))
    {
      int $display_indices[];
      $display_indices = DRP_getSecondaryDisplayIndices($render_pass);
      
      for($i in $display_indices)
      {
        $driver = DRP_getSecondaryDisplayDriver($render_pass, $i);
        $image_file = DRP_getSecondaryDisplayFilename($render_pass, $i);
        $image_file = DL_getExpandedFilename(
          $image_file, 
          "", 
          $render_pass,
          $driver);

        if ($image_file == "")
        {
          $image_file = 
            "<" + DRP_getSecondaryDisplayDriver($render_pass, $i) + ">";
        }
        
        $progress_message += (" " + $image_file);
      }
    }
     
    print ($progress_message + "\n");
  }
}

proc int
isCancelled()
{
  if (DL_haveMayaUI())
  {
    return `progressWindow -query -isCancelled`;
  }
  else
  {
    return 0;
  }
}

global proc
endProgress()
{
  if (DL_haveMayaUI())
  {
    progressWindow -edit -endProgress;
  }
}

// ----------------------------------------------------------------------------
// Procedures which pop up the maya render view and add a 3Delight menu to it.
//

proc
popupMayaRenderViewWindow( string $render_pass )
{
  if( ! `control -exists renderView` ||
      `control -q -isObscured renderView` ||
      `panel -q -tearOff renderView` )
  {
    RenderViewWindow;
  }

  if (`menu -exists delightRenderViewWindowMenu`)
    deleteUI delightRenderViewWindowMenu;

  if (`menu -exists delightRenderViewPopupMenu`)
    deleteUI delightRenderViewPopupMenu;

  if( !`menuBarLayout -exists renderView` )
    return;

  menu -label "3Delight" -parent renderView delightRenderViewWindowMenu;

    menuItem -label "Render"
             -annotation "Render this window again"
             -command ("delightRenderViewRender(\"" + $render_pass + "\")");

    menuItem -label "Render region"
             -annotation "Render the selected region again"
             -command ("delightRenderViewRenderRegion \"" + $render_pass + "\"");

  menuItem -label "3Delight" -subMenu true -parent renderViewpopupMenu delightRenderViewPopupMenu;

    menuItem -label "Render"
             -annotation "Render this window again"
             -command ("delightRender(\"" + $render_pass + "\")");

    menuItem -label "Render region"
             -annotation "Render the selected region again"
             -command ("delightRenderViewRenderRegion \"" + $render_pass + "\"");
}

proc
mayaRenderWith3Delight()
{
  // We could call DRG_GUIrender directly but this would involve figuring out
  // which layer we have to render. Better leave this to Maya.

  string $curr_renderer_attr = "defaultRenderGlobals.currentRenderer";
  string $curr_renderer = getAttr($curr_renderer_attr);
  
  setAttr -type "string" $curr_renderer_attr "_3delight";
  RenderIntoNewWindow;
  setAttr -type "string" $curr_renderer_attr $curr_renderer;
}

global proc
delightRenderViewRender( string $render_pass )
{
  // The render pass node could have been deleted either by the user or because
  // the redering was invoked with the default render pass node from the 
  // 3delight render globals
  
  if (`objExists $render_pass`)
  {
    delightRender($render_pass);
  }
  else
  {
    mayaRenderWith3Delight();
  }
}

global proc
delightRenderViewRenderRegion( string $render_pass )
{
  global float $DRP_crop_window_override[];

  string $globals[] = `ls -renderGlobals`;

  int $left = `getAttr( $globals[0] + ".left" )`;
  int $right = `getAttr( $globals[0] + ".rght" )`;
  int $bottom = `getAttr( $globals[0] + ".bot" )`;
  int $top = `getAttr( $globals[0] + ".top" )`;

  // The render pass node could have been deleted either by the user or because
  // the redering was invoked with the default render pass node from the 
  // 3delight render globals
  int $render_pass_exists = `objExists $render_pass`;
  
  float $x_res;
  float $y_res;
  
  if ($render_pass_exists)
  {
    $x_res = getAttr( $render_pass + ".resolutionX" );
    $y_res = getAttr( $render_pass + ".resolutionY" );
  }
  else
  {
    string $resolution_node[];
    $resolution_node = `listConnections -type "resolution" "defaultRenderGlobals"`;

    $x_res = getAttr($resolution_node[0] + ".width");
    $y_res = getAttr($resolution_node[0] + ".height");
  }

  $DRP_crop_window_override =
  {
    $left / $x_res, 1.0 - ($top / $y_res),
    $right / $x_res, 1.0 - ($bottom / $y_res)
  };

  if ($render_pass_exists)
  {
    delightRender( $render_pass );
  }
  else
  {
    mayaRenderWith3Delight();
  }

  clear($DRP_crop_window_override);
}

// ----------------------------------------------------------------------------
// Procedures which output things to the RIB stream.
//

proc
outputTransform(string $shape_name,
                int $invert,
                int $concatenate,
                int $is_rib_archiving_mode)
{
  if( $is_rib_archiving_mode )
  {
    RiIfBegin -e 
      (   "!defined(user:_3dfm_filter_transform) " +
      "|| $user:_3dfm_filter_transform == 0");
  }

  if($invert)
  {
    if($concatenate)
      delightCacheXform -emit -i -c $shape_name;
    else
      delightCacheXform -emit -i $shape_name;
  }
  else
  {
    if($concatenate)
      delightCacheXform -emit -c $shape_name;
    else
      delightCacheXform -emit $shape_name;
  }
  
  if( $is_rib_archiving_mode )
    RiIfEnd;
}

/*
  cube_face can be used to point the camera at another face of a cube aligned
  with the camera's coordinate system. A value of 0 provides the normal
  behavior of looking forward.
*/
proc
outputCameraTransform(
  string $camera_name,
  int $cube_face )
{
  // RenderMan cameras look down +ve Z. Maya looks down -ve Z. So we
  // scale by -1
  RiScale 1 1 -1;

  /*
	Record a coordinate system without the scale by -1. This allows easy
	transformation to maya's camera coordinate system in shaders. As of now, it
	is used by the samplerInfo node.
  */
  RiCoordinateSystem -n "mayaCamera";

  // Cancel the scale if the camera is a light source
  string $list_lights_cmd = DL_getListLightNodesCmd();

  if (size(`eval($list_lights_cmd + $camera_name)`) != 0)
  {
    string $transform;
    $transform = firstParentOf($camera_name);
    float $scale[] = getAttr($transform + ".scale");
    
    if ($scale[0] != 1 || $scale[1] != 1 || $scale[2] != 1)
    {
      RiScale $scale[0] $scale[1] $scale[2];
    }
  }  

  // Should we look at another face of the cube?
  switch( $cube_face )
  {
    case 1:
      // left
      RiRotate -90 0 1 0;
      break;
    case 2:
      // right
      RiRotate 90 0 1 0;
      break;
    case 3:
      // above
      RiRotate -90 1 0 0;
      break;
    case 4:
      // below
      RiRotate 90 1 0 0;
      break;
    case 5:
      // behind
      RiRotate 180 0 1 0;
      break;
  }

  // invert and concatenate the transform
  outputTransform($camera_name, 1, 1, 0);
}

proc
outputRIBcomment(string $text)
{
  RiArchiveRecord -m "comment" -t (" " + $text);
}

proc
outputTimingComment(string $comment_base, float $start_time)
{
  global string $g_no_timing_comments;

  if( $g_no_timing_comments != "" )
    return;

  $comment = ( $comment_base + `timerX -startTime $start_time` + "s");
  outputRIBcomment($comment);
  outputRIBcomment("\n");
  print($comment + "\n");
}

proc
outputIlluminateStatements(
  string $geo_name,
  string $all_attribs_nodes[],
  string $visible_lights[],
  string $default_light_set_members[],
  float $is_rib_archiving_mode) 
{
  // TODO: do we want to output Illuminate statements for all of the lights
  // in the scene or just the ones we need to turn off?
  // TODO: we should handle the case where a set that this object belongs to
  // is linked/unlinked from a light...
  string  $linked_lights[];
  string  $non_linked_lights[];
  string  $handle;

  $linked_lights = getLinkedLights(
    $geo_name, 
    $all_attribs_nodes,
    $visible_lights);

  $non_linked_lights = DL_stringArrayDifference($visible_lights, $linked_lights);

  string $lights_to_turn_off[] = DL_stringArrayIntersect(
    $non_linked_lights,
    $default_light_set_members);
    
  string $lights_to_turn_on[] = DL_stringArrayDifference(
    $linked_lights,
    $default_light_set_members);

  // Todo: should we drop this define?
  if (size($non_linked_lights) > 0 && $is_rib_archiving_mode != 0)
  {
    RiIfBegin -e "!defined(IgnoreArchivedLighting)";
  }

  int $needs_illuminates = 0;
  
  if(size($lights_to_turn_off) > 0 || size($lights_to_turn_on) > 0)
  {
    $needs_illuminates = 1;
  }
  
  if ($needs_illuminates && $is_rib_archiving_mode)
  {
    RiIfBegin -e 
      (   "!defined(user:_3dfm_filter_illuminate) " +
       "|| $user:_3dfm_filter_illuminate == 0");
  }

  for ($curr_light in $lights_to_turn_on)
  {
    string $illuminate_cmd = getLightIlluminateCommand( $curr_light );
    if( $illuminate_cmd != "" )
    {
      string $shortest_path = DL_getShortestUniqueDAGpath( $curr_light );
      $illuminate_cmd += "(\"" + $shortest_path + "\", 1)";
      eval( $illuminate_cmd );
    }
    else
    {
      RiIlluminate -h $curr_light -s 1;
    }
  }

  for ($curr_light in $lights_to_turn_off)
  {
    string $illuminate_cmd = getLightIlluminateCommand( $curr_light );
    if( $illuminate_cmd != "" )
    {
      string $shortest_path = DL_getShortestUniqueDAGpath( $curr_light );
      $illuminate_cmd += "(\"" + $shortest_path + "\", 0)";
      eval( $illuminate_cmd );
    }
    else
    {
      RiIlluminate -h $curr_light -s 0;
    }
  }

  if ($needs_illuminates && $is_rib_archiving_mode)
  {
    RiIfEnd;
  }
  
  if (size($non_linked_lights) > 0 && $is_rib_archiving_mode != 0)
  {
    RiIfEnd;
  }
}

proc
outputDefaultLightShader(
  string $light_name, 
	string $attribs_node,
  string $shadowmap_name)
{
  string $paths[] = `ls $light_name`;
  string $common_params = " -p \"__handleid\" \"string\" \"";
  $common_params += ($paths[0] + "\"");

  string $light_type = `nodeType $light_name`;

  string $attr = "category";
  string $categories = "";
	
  string $node_with_attr = DLA_getNodeWithAttribute(
    $attr, 
    $attribs_node, 
    $light_name);
  
  if ($node_with_attr != "")
    $categories = DLA_getCategory($node_with_attr);

  if( $light_type != "ambientLight" )
  {
    if( getAttr($light_name + ".emitSpecular") == 1 )
    {
      if( $categories != "" )
        $categories += ",";
        
      $categories += "specular";
    }
    else
      $common_params += " -p \"__nonspecular\" \"float\" \"1\"";

    if( getAttr($light_name + ".emitDiffuse") == 1 )
    {
      if( $categories != "" )
        $categories += ",";
        
      $categories += "diffuse";
    }
    else
      $common_params += " -p \"__nondiffuse\" \"float\" \"1\"";

    if( $categories != "" )
    {
       $common_params += " -p \"__category\" \"string\" \"";
       $common_params += $categories;
       $common_params += "\"";
    }

    $common_params += " -p \"shadowmapname\" \"string\" \"";
    
	/*
		We must escape the backslashes in the shadowmap name because the
		command will be evaluated as mel. Note that the left "\\\\" translate
		into "\\" which is treated as a regexp which matches a single "\". So
		this command isn't as crazy as it looks.
	*/
    $common_params += DL_substituteAll( "\\\\", $shadowmap_name, "\\\\" );
    $common_params += "\"";
    
    $attr = "keyLight";
    int $key_light = 0;

    $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

    if ($node_with_attr != "")
      $key_light = DLA_isKeyLight($node_with_attr);

    if($key_light != 0)
      $common_params += " -p \"iskeylight\" \"float\" \"1\"";
  }

  string $shader_type;
  if ($light_type == "areaLight")
    $shader_type = "arealight";
  else
    $shader_type = "light";

  outputTranslatedMayaShader(
    materialShaderName( $paths[0] ), $shader_type, $common_params );

  return;

  /* This is the old code which uses the prebuilt shaders in the 3Delight
     package. */

  if (getAttr($light_name + ".useRayTraceShadows") == 1 && $shadowmap_name=="" )
  {
    $num_samples = getAttr($light_name + ".shadowRays");
    RiAttribute 
      -n "light" 
      -p "shadows" "string" "on"
      -p "samples" "integer" $num_samples;
  }

  $common_params += (" -p \"intensity\" \"float\" \"");
  $common_params += getAttr($light_name + ".intensity");
  $common_params += "\" -p \"lightcolor\" \"color\" \"";
  $common_params += floatArrayToString(getAttr($light_name + ".color"));
  $common_params += "\"";

  string $shader_command = "RiLightSource -n ";

  int $has_shadowmap = 1;
  
  if ($light_type == "ambientLight")
  {
    $shader_command += ("maya_ambientlight " + $common_params);
    $shader_command += " -p \"ambientShade\" \"float\" \"";
    $shader_command += getAttr( $light_name + ".ambientShade" );
    $shader_command += "\"";
    $has_shadowmap = 0;
  }
  else if ($light_type == "directionalLight")
  {
    $shader_command += ("maya_directionallight " + $common_params);
  }
  else if ($light_type == "pointLight")
  {
    $shader_command += ("maya_pointlight " + $common_params);

    $shader_command += " -p \"decay\" \"float\" \"";
    $shader_command += getAttr($light_name + ".decayRate");
    $shader_command += "\"";
  }
  else if ($light_type == "spotLight")
  {
    $shader_command += ("maya_spotlight " + $common_params); 
    $shader_command += " -p \"coneangle\" \"float\" \"";
    float $angle = getAttr($light_name + ".coneAngle");
    $shader_command += `deg_to_rad $angle`;
    $shader_command += "\" -p \"penumbraangle\" \"float\" \"";
    $angle = getAttr($light_name + ".penumbraAngle");
    $shader_command += `deg_to_rad $angle`;
    $shader_command += "\" -p \"decay\" \"float\" \"";
    $shader_command += getAttr($light_name + ".decayRate");
    $shader_command += "\" -p \"dropoff\" \"float\" \"";
    $shader_command += getAttr($light_name + ".dropoff");
    $shader_command += "\"";

    if( getAttr($light_name + ".barnDoors") == 1 )
    {
      $shader_command += " -p \"barnDoors\" \"float\" \"" + 1;
      $shader_command += "\" -p \"leftBarnDoor\" \"float\" \"";
      $angle = getAttr($light_name + ".leftBarnDoor");
      $shader_command += `deg_to_rad $angle`;
      $shader_command += "\" -p \"rightBarnDoor\" \"float\" \"";
      $angle = getAttr($light_name + ".rightBarnDoor");
      $shader_command += `deg_to_rad $angle`;
      $shader_command += "\" -p \"topBarnDoor\" \"float\" \"";
      $angle = getAttr($light_name + ".topBarnDoor");
      $shader_command += `deg_to_rad $angle`;
      $shader_command += "\" -p \"bottomBarnDoor\" \"float\" \"";
      $angle = getAttr($light_name + ".bottomBarnDoor");
      $shader_command += `deg_to_rad $angle`;
    }
  }
  else
  {
    // No current implemantation for that light type
    return;
  }

  if( $has_shadowmap )
  {
    $shader_command += " -p \"shadowmapname\" \"string\" \"";
	/*
		We must escape the backslashes in the shadowmap name because the
		command will be evaluated as mel. Note that the left "\\\\" translate
		into "\\" which is treated as a regexp which matches a single "\". So
		this command isn't as crazy as it looks.
	*/
    $shader_command += DL_substituteAll( "\\\\", $shadowmap_name, "\\\\" );
    $shader_command += "\"";
    $shader_command += " -p \"shadowcolor\" \"color\" \"";
    $shader_command +=
		floatArrayToString(getAttr($light_name + ".shadowColor"));
    $shader_command += "\"";
    $shader_command += " -p \"shadowBias\" \"float\" \"";
    $shader_command += getAttr($light_name + ".dmapBias");
    $shader_command += "\"";
    $shader_command += " -p \"shadowFilterSize\" \"float\" \"";
    $shader_command += getAttr($light_name + ".dmapFilterSize");
    $shader_command += "\"";
  }

  eval($shader_command);
}

proc
outputGroupMemberships(string $geo_name)
{
  string  $all_sets[];

  $all_sets = getAllSetMemberships($geo_name);

  if( size($all_sets) > 0 )
  {
  	string $membership = stringArrayToString( $all_sets, "," );
    RiAttribute -n "grouping" -p "membership" "string" ("+" + $membership);
  }

  /*
    Add objects not visible in refractions to a special group which will be
    excluded when tracing refractions. Same thing for objects not visible in
    reflections.
  */
  if( objExists( $geo_name + ".visibleInReflections" ) )
  {
    if( !`getAttr ($geo_name + ".visibleInReflections")` )
    {
      RiAttribute -n "grouping"
                  -p "membership" "string" "+_3dfm_not_visible_in_reflections";
    }
  }

  if( objExists( $geo_name + ".visibleInRefractions" ) )
  {
    if( !`getAttr ($geo_name + ".visibleInRefractions")` )
    {
      RiAttribute -n "grouping"
                  -p "membership" "string" "+_3dfm_not_visible_in_refractions";
    }
  }
}

proc
outputGeometryShaders(
  string $shape,
  float $is_shadow_render,
  string $collection,
  int $use_translated_shaders,
  int $use_surface_shaders_in_shadows,
  int $use_displacement_shaders_in_shadows,
  int $use_atmosphere_shaders_in_shadows,
  int $use_interior_shaders_in_shadows)
{
  //
  // Description:
  //  This procedure is called during the rendering process.
  //  This procedure outputs ReadArchive calls to read the archive of the
  //  shader assigned to the specified shape in the context of the specified
  //  pass. 
  //  If the render currently being performed is a shadow map render,
  //  this procedure respects the user's choices regarding what types of
  //  geometry shaders to use when rendering shadow maps. The user's choices
  //  are defined by settings of attributes on the render pass node.
  //

  string  $shader_collection;
  int     $use_translated_shaders;

  if( !$is_shadow_render || $use_surface_shaders_in_shadows )
  {
    RiIfBegin -e 
      "!defined(user:_3dfm_filter_surface) || $user:_3dfm_filter_surface == 0";
    
    string $surface_shader =
      DL_getHighestAttribsNodeFromShape($shape, "surface", $collection);

    if ($surface_shader == "")
    {
      int $used_maya_shader;

      if ($use_translated_shaders)
      {
        string $translated_shader;
        $translated_shader = getTranslatedMayaShaderName( $shape, "surface");
        
        if ($translated_shader == "")
        {
          $translated_shader = getTranslatedMayaShaderName( $shape, "miMaterial");
        }

        if ($translated_shader != "")
        {
          RiReadArchive -archiveName ($translated_shader + " surface");
          $used_maya_shader = 1;
        }
        else
          $used_maya_shader = 0;
      }
      else
        $used_maya_shader = 0;

      if( !$used_maya_shader && !$is_shadow_render )
      {
        // This shape does not have a surface shader assigned to it.
        // For fur, we want the maya_fur shader instead of defaultsurface as
        // that doesn't render as anything remotely interesting.
        //
        if(`nodeType $shape` == "FurFeedback")
        {
          RiSurface -n "maya_fur";
        }
      }
    }
    else
    {
      RiReadArchive -archiveName ($surface_shader + " surface");
    }

    RiIfEnd;
  }

  if( !$is_shadow_render || $use_displacement_shaders_in_shadows )
  {
    string $displacement_shader = 
      DL_getHighestAttribsNodeFromShape($shape, "displacement", $collection);

    if( $displacement_shader == "")
    {
      if ($use_translated_shaders)
      {
        string $translated_shader;

        $translated_shader = getTranslatedMayaShaderName($shape,"displacement");

        if ($translated_shader != "")
          $displacement_shader = $translated_shader;
      }
    }

    if ($displacement_shader != "")
    {
      RiIfBegin -e 
        (   "!defined(user:_3dfm_filter_displacement) " +
         "|| $user:_3dfm_filter_displacement == 0");
      
      RiReadArchive -archiveName ($displacement_shader + " displacement");
      
      RiIfEnd;
    }
  }

  if( !$is_shadow_render || $use_atmosphere_shaders_in_shadows )
  {
    string $atmosphere_shader = 
      DL_getHighestAttribsNodeFromShape($shape, "atmosphere", $collection);

    if ($atmosphere_shader != "")
    {
      RiIfBegin -e 
        (   "!defined(user:_3dfm_filter_atmosphere) " +
         "|| $user:_3dfm_filter_atmosphere == 0");

      RiReadArchive -archiveName ($atmosphere_shader + " atmosphere");

      RiIfEnd;
    }
  }

  if( !$is_shadow_render || $use_interior_shaders_in_shadows )
  {
    string $interior_shader = 
      DL_getHighestAttribsNodeFromShape($shape, "interior", $collection);

    if ($interior_shader != "")
    {
      RiIfBegin -e 
        (   "!defined(user:_3dfm_filter_interior) " +
         "|| $user:_3dfm_filter_interior == 0");

      RiReadArchive -archiveName ($interior_shader + " interior");

      RiIfEnd;
    }
  }
}

proc
outputInstancer(string $instancer, 
                string $renderable_instancer_geo[],
                string $render_pass, 
                string $visible_lights[],
                string $default_light_set_members[], 
                int $is_shadow_render)
{
  string $shader_collection;
  string $curr_instancer_geo[];

  int $output_geo_attribs;
  int $output_illuminate;
  int $is_rib_archiving_mode;

  $shader_collection = DRP_getShaderCollection($render_pass);

  $output_geo_attribs = 1;
  $output_illuminate = !$is_shadow_render;

  $is_rib_archiving_mode = DRP_isRIBArchivingMode($render_pass);

  if ($is_rib_archiving_mode)
  {
    $output_geo_attribs = getAttr($render_pass + ".archiveGeometryAttributes");
    $output_illuminate = getAttr($render_pass + ".archiveLighting") > 0;
  }

  $curr_instancer_geo = `delightCacheInstancer -listGeometry -cached $instancer`;

  // If we are rendering shadow maps, make sure we are only outputting geo
  // that are casting shadows in the current map.
  if ($is_shadow_render)
  {
    $curr_instancer_geo = 
      DL_stringArrayIntersect($curr_instancer_geo, $renderable_instancer_geo);
  }

  RiAttributeBegin;
    outputRIBcomment("Instancer: " + $instancer);

    for ($geo in $curr_instancer_geo)
    {
      RiAttributeBegin;

        string $all_attribs_nodes[] = 
          DL_getAllGeoAttribsNodesFromShape($geo, 
                                            $shader_collection);

        // we need to output these in reverse order so that the highest
        // attribs node is last
        if ($output_geo_attribs)
        {
          for ($i = size($all_attribs_nodes)-1; $i >= 0; $i--)
          {
            RiReadArchive -archiveName $all_attribs_nodes[$i];
          }
        }

        if (!$is_shadow_render && $output_illuminate)
        {
          outputIlluminateStatements(
            $geo,
            $all_attribs_nodes,
            $visible_lights,
            $default_light_set_members,
            $is_rib_archiving_mode);
        }

        if ($is_shadow_render && nodeType($geo) == "delightRibArchive")
        {
          RiAttribute -n "user" -p "IgnoreArchivedLighting" "float" "1";
        }

        RiReadArchive -archiveName ($instancer + " " + $geo);

      RiAttributeEnd;
    }

  RiAttributeEnd;
}


proc
outputGeometry(string $render_pass,
               string $all_renderable_geos[],
               string $visible_lights[],
               string $instancer_geometry[],
               int $is_shadow_render,
               int $progress_range)
{
// get current camera
	global string $ZHANG_curcamera;
// get fps (flim, pal, or ntsc)
	int $fps = 24;
	if(`currentUnit -q -time` == "pal") $fps = 25;
	if(`currentUnit -q -time` == "ntsc") $fps = 30;
	
  int $output_geo_shaders;
  int $output_geo_attribs;
  int $output_transforms;
  int $output_illuminate;
  int $concatenate_xforms;
  int $is_rib_archiving_mode;

  string $shader_collection;

  $output_geo_shaders = 1;
  $output_geo_attribs = 1;
  $output_transforms = 1;
  $concatenate_xforms = 0;
  $output_illuminate = !$is_shadow_render;
  
  $is_rib_archiving_mode = DRP_isRIBArchivingMode($render_pass);

  if ($is_rib_archiving_mode)
  {
    $output_geo_shaders = getAttr($render_pass + ".archiveGeometryShaders");
    $output_geo_attribs = getAttr($render_pass + ".archiveGeometryAttributes");    
    $output_transforms = getAttr($render_pass + ".archiveTransforms");        
    $output_illuminate = getAttr($render_pass + ".archiveLighting") > 0;

    $concatenate_xforms = DRP_getConcatenateGeoTransforms($render_pass);
  }

  $shader_collection = DRP_getShaderCollection($render_pass);

  string $default_light_set_members[] = getDefaultLightSetShapes(0);
  
  int $num_geos = size($all_renderable_geos);
  int $curr_geo_num = 0;
  int $prev_progress = 0;

  int $user_pre_geo_mel_exists = `exists("DL_userPreGeoMel")`;

  int $use_translated_shaders = `DRP_getUseMayaShaders($render_pass)`;
  int $use_surface_shaders_in_shadows = 
    `DRP_getUseSurfaceShadersInShadows($render_pass)`;

  int $use_displacement_shaders_in_shadows =
    `DRP_getUseDisplacementShadersInShadows($render_pass)`;

  int $use_atmosphere_shaders_in_shadows =
    `DRP_getUseAtmosphereShadersInShadows($render_pass)`;

  int $use_interior_shaders_in_shadows = 
    `DRP_getUseInteriorShadersInShadows($render_pass)`;

  
  for ($curr_geo in $all_renderable_geos)
  {
    string $all_attribs_nodes[] = 
      DL_getAllGeoAttribsNodesFromShape($curr_geo, 
                                        $shader_collection);

    // just to make sure that all object-related attributes are cleared
    // out after each object (specifically the RiIlluminate statements
    // used for light linking) we enclose each object in its own
    // sub-attribute block
    RiAttributeBegin;

    // we need to output these in reverse order so that the highest attribs
    // node is last
      if ($output_geo_attribs && size($all_attribs_nodes) > 0)
      {
        if( $is_rib_archiving_mode )
        {
          RiIfBegin -e 
            (   "!defined(user:_3dfm_filter_geo_attribs_node) " +
            "|| $user:_3dfm_filter_geo_attribs_node == 0");
        }

        for ($i = size($all_attribs_nodes)-1; $i >= 0; $i--)
        {
          RiReadArchive -archiveName $all_attribs_nodes[$i];
        }
        
        if( $is_rib_archiving_mode )
          RiIfEnd;
      }

      RiAttribute -n "identifier" -p "name" "string" $curr_geo;

      string $shortest_unique_names[] = `ls $curr_geo`;
      string $shortest_unique_name = 
        DL_substituteAllString($shortest_unique_names[0], "|", "#");

      RiAttribute 
        -n "user" 
        -p "delight_shortest_unique_name" "string" $shortest_unique_name;

      if ($output_transforms)
      {
        outputTransform(
          $curr_geo, 0, $concatenate_xforms, $is_rib_archiving_mode );
      }

      if ($output_geo_attribs)
      {
        outputGroupMemberships($curr_geo);
        delightOutputRenderStats $curr_geo $all_attribs_nodes;
      }

      string $highest_node;

      $highest_node = DL_highestNodeWithAttrib("preGeoMEL", $all_attribs_nodes);

      if ($highest_node != "")
        DGA_executePreGeoMelScript($highest_node, $curr_geo);

      if ($user_pre_geo_mel_exists)
      {
        DL_userPreGeoMel(
          $render_pass, 
          $curr_geo, 
          $visible_lights, 
          $is_shadow_render);
      }

      string $geo_type = `nodeType $curr_geo`;

      if ($output_geo_shaders && $geo_type != "instancer")
      {
        outputGeometryShaders(
          $curr_geo,
          $is_shadow_render,
          $shader_collection,
          $use_translated_shaders,
          $use_surface_shaders_in_shadows,
          $use_displacement_shaders_in_shadows,
          $use_atmosphere_shaders_in_shadows,
          $use_interior_shaders_in_shadows);
      }

      if (!$is_shadow_render && $output_illuminate && $geo_type != "instancer")
      {
        outputIlluminateStatements(
          $curr_geo,
          $all_attribs_nodes,
          $visible_lights,
          $default_light_set_members,
          $is_rib_archiving_mode);
      }
        
      $highest_node = DL_highestNodeWithAttrib("outputGeometry",
                                               $all_attribs_nodes);

      if (DGA_outputGeometry($curr_geo, $highest_node))
      {
        if ($geo_type == "delightRibArchive")
        {
          DRA_outputNode($curr_geo, $is_shadow_render, $render_pass);
        }
        else
        {
          string $geo_to_output = $curr_geo;

          if (isInstanced($curr_geo))
            $geo_to_output = getFirstInstance($curr_geo);

          if( !canUseObjectInstance( $curr_geo, $geo_type ) )
          {
// emit custom procedural instead read archive here
//            RiReadArchive -archiveName $geo_to_output;

		string $zh_cmd;
		
		$zh_cmd = $geo_type+"CacheGeo -emit \""+$curr_geo+" "+`delightRenderState -qrn`+" "+`delightRenderState -qf`+" "+`delightRenderState -qso`+" "+`delightRenderState -qsc`+" "+$is_shadow_render+" "+$fps+" "+$ZHANG_curcamera+"\"";
		outputRIBcomment($geo_type+"CacheGeo emits "+$curr_geo);
		eval($zh_cmd);
		
		//$zh_cmd = $geo_type+"CacheGeo -pass "+`delightRenderState -qrn`;
		//outputRIBcomment("calls "+$zh_cmd);
		//eval($zh_cmd);
		//print(`delightRenderState -qrn`+"\n");
		//print(`delightRenderState -qf`+"\n");
		//print(`delightRenderState -qso`+"\n");
		//print(`delightRenderState -qsc`+"\n");
          }
          else if ($geo_type == "instancer")
          {
            outputInstancer($geo_to_output, 
                            $instancer_geometry,
                            $render_pass, 
                            $visible_lights,
                            $default_light_set_members,
                            $is_shadow_render);
          }
          else
          {
            RiObjectInstance -name $geo_to_output;
          }
        }
      }
      else
      {
        $comment =   "Geo Attribs Node: "
                   + $highest_node
                   + " is set to not output geometry";

        outputRIBcomment($comment);
      }

      $highest_node = DL_highestNodeWithAttrib("postGeoMEL",$all_attribs_nodes);

      if ($highest_node != "")
        DGA_executePostGeoMelScript($highest_node, $curr_geo);

    RiAttributeEnd;
    
    if ($progress_range > 0)
    {
      int $progress = $progress_range * ++$curr_geo_num / $num_geos;
      incProgress( $progress - $prev_progress, 0 );
      $prev_progress = $progress;
    }
  }
}

/*
  outputCSGNodeObjects

  Outputs the objects for one of the groups of objects of a CSG node. Objects
  can be:
  - Transforms (all shapes under it are output as a single primitive).
  - Sets of objects (all objects are output as a single primitive).
  - Other CSG nodes.

  PARAMETERS

  csg_node_plug
    The plug to which the objects to output are connected.

  parent_csg_nodes
    Passed to and from outputCSGNode to detect cycles.

  o_used_geo
    [input/output] Any shape emitted for this CSG node or its descendants is
    appended to this array. The shape is only added once even if is used
    several times in the RIB.

  render_pass, all_renderable_geos, visible_lights, instancer_geometry,
  is_shadow_render
    Passed down to outputGeometry so it can do its work.
*/
proc
outputCSGNodeObjects(
  string $csg_node_plug,
  string $parent_csg_nodes[],
  string $o_used_geo[],
  string $render_pass,
  string $all_renderable_geos[],
  string $visible_lights[],
  string $instancer_geometry[],
  int $is_shadow_render )
{
  string $connections[] = `listConnections $csg_node_plug`;
  
  for( $conn in $connections )
  {
    string $type = `nodeType $conn`;

    if( $type == "delightCSG" )
    {
      outputCSGNode(
        $conn,
        $parent_csg_nodes,
        $o_used_geo,
        $render_pass,
        $all_renderable_geos,
        $visible_lights,
        $instancer_geometry,
        $is_shadow_render );

      continue;
    }

    /*
      Sets and groups (transforms) are output as a single primitive. This is
      why there's no "primitive" operation on our CSG node.
    */
    string $all_shapes[] = {};

    if( $type == "objectSet" )
    {
      $all_shapes = DL_getFlattenedSetMembers( $conn );
    }
    else
    {
      $all_shapes[0] = $conn;
    }

    $all_shapes = getAllDescendantShapes( $all_shapes );

    // Only output what's actually visible.
    $all_shapes = DL_stringArrayIntersect( $all_shapes, $all_renderable_geos );

    RiSolidBegin -op "primitive";

    outputGeometry(
      $render_pass,
      $all_shapes,
      $visible_lights,
      $instancer_geometry,
      $is_shadow_render,
      -1 );

    RiSolidEnd;

    // Record what we're outputting to remove it from the main output.
    DL_stringArrayAppend( $o_used_geo, $all_shapes );
  }

  DL_stringArrayRemoveDuplicates( $o_used_geo );
}

/*
  outputCSGNode

  Outputs the Solid blocks required for a given CSG node and all the objects
  that go inside it.

  PARAMETERS
  
  csg_node
    The node to output.

  parent_csg_nodes
    List of all the nodes above this one in the CSG tree. To prevent cycles.

  o_used_geo
    [input/output] Any shape emitted for this CSG node or its descendants is
    appended to this array. The shape is only added once even if is used
    several times in the RIB.

  render_pass, all_renderable_geos, visible_lights, instancer_geometry,
  is_shadow_render
    Passed down to outputGeometry so it can do its work.

  NOTES
  - This is only global to allow recursion. Don't call it from the outside.
*/
global proc
outputCSGNode(
  string $csg_node,
  string $parent_csg_nodes[],
  string $o_used_geo[],
  string $render_pass,
  string $all_renderable_geos[],
  string $visible_lights[],
  string $instancer_geometry[],
  int $is_shadow_render )
{
  if( -1 != DL_stringArrayIndexOf( $csg_node, $parent_csg_nodes ) )
  {
    warning( "3DFM: CSG node '" + $csg_node + "' creates a cycle." );
    return;
  }

  outputRIBcomment( "CSG node " + $csg_node );

  string $parents[] = $parent_csg_nodes;
  $parents[size($parents)] = $csg_node;

  int $operation = getAttr( $csg_node + ".operation" );

  switch( $operation )
  {
    case 0:
      RiSolidBegin -operation "union";

      outputCSGNodeObjects(
        $csg_node + ".primitivesGroup1",
        $parents,
        $o_used_geo,
        $render_pass,
        $all_renderable_geos,
        $visible_lights,
        $instancer_geometry,
        $is_shadow_render );
          
      RiSolidEnd;

      break;

    case 1:
      RiSolidBegin -operation "intersection";

      outputCSGNodeObjects(
        $csg_node + ".primitivesGroup1",
        $parents,
        $o_used_geo,
        $render_pass,
        $all_renderable_geos,
        $visible_lights,
        $instancer_geometry,
        $is_shadow_render );

      RiSolidEnd;

      break;

    case 2:
      RiSolidBegin -operation "difference";
      RiSolidBegin -operation "union";

      outputCSGNodeObjects(
        $csg_node + ".primitivesGroup1",
        $parents,
        $o_used_geo,
        $render_pass,
        $all_renderable_geos,
        $visible_lights,
        $instancer_geometry,
        $is_shadow_render );

      RiSolidEnd;

      outputCSGNodeObjects(
        $csg_node + ".primitivesGroup2",
        $parents,
        $o_used_geo,
        $render_pass,
        $all_renderable_geos,
        $visible_lights,
        $instancer_geometry,
        $is_shadow_render );

      RiSolidEnd;

      break;

    default:
      warning( "3DFM: invalid CSG node '" + $csg_node + "'\n" );
  }
}

/*
  outputGeometryAndCSG

  First outputs all the CSG nodes in the scene (and their geometry) and then
  any geometry which hasn't been used by the CSG nodes.

  Note that there is (for now) no way to control the visibility of CSG
  nodes. Instead, the visibility of the shapes which make up the solid should
  be used (with geo attribs, render sets, layers, etc). This is probably less
  confusing too as it avoids duplicating visibility control.
*/
proc
outputGeometryAndCSG(
  string $render_pass,
  string $all_renderable_geos[],
  string $visible_lights[],
  string $instancer_geometry[],
  int $is_shadow_render,
  int $progress_range )
{
  // outputIlluminate calls expect the lights to have their short names
  string $visible_lights_short_names[] = `ls $visible_lights`;
  
  outputRIBcomment("");
  outputRIBcomment("start geometry");

  string $all_csg_nodes[] = DCSG_getAllCSGNodes();

  string $all_csg_geos[] = {};

  for( $csg_node in $all_csg_nodes )
  {
    /* Use only top level nodes. So skip those used by another CSG node. */
    if( attributeExists( "usedBy3dfm", $csg_node ) )
    {
      string $used_by[] = `listConnections ($csg_node + ".usedBy3dfm")`;
      string $used_by_csg[] = `ls -type delightCSG $used_by`;

      if( size($used_by_csg) != 0 )
        continue;
    }

    string $parent_csg_nodes[] = {};

    outputCSGNode(
      $csg_node,
      $parent_csg_nodes,
      $all_csg_geos,
      $render_pass,
      $all_renderable_geos,
      $visible_lights_short_names,
      $instancer_geometry,
      $is_shadow_render );
  }

  /* Output the non-CSG geometry. */

  string $remaining_geos[] =
    DL_stringArrayDifference( $all_renderable_geos, $all_csg_geos );

  outputGeometry(
    $render_pass,
    $remaining_geos,
    $visible_lights_short_names,
    $instancer_geometry,
    $is_shadow_render,
    $progress_range );

  outputRIBcomment("");
  outputRIBcomment("end geometry");
}

/*
  DL_getDisplayExtraParameters

  This attempts to find extra parameters to pass to RiDisplay for a given
  display driver. It looks for those parameters in a drivernameDisplayParameter
  attribute on the render pass. For example, the tiff compression mode can be
  overriden with:

  addAttr -dt "string" -ln tiffDisplayParameters delightRenderPass1;
  setAttr "delightRenderPass1.tiffDisplayParameters" -type "string" "-p \"compression\" \"string\" \"deflate\"";

  NOTES
  - It is also possible to override this entire procedure with something more
    complex.
*/
global proc string
DL_getDisplayExtraParameters(
  string $render_pass,
  string $image_file,
  string $display_driver,
  string $display_mode )
{
  string $attr_name = $display_driver + "DisplayParameters";

  if( attributeExists( $attr_name, $render_pass ) )
  {
    return getAttr( $render_pass + "." + $attr_name );
  }

  return "";
}

proc
outputPrimaryDisplay(string $render_pass)
{
  if (DRP_getRenderPrimaryDisplay($render_pass))
  {
    string  $image_file;
    string  $display_driver;
    string  $display_mode;
    string  $pixel_filter;
    string  $quantize_string;
    float   $filter_width[];
    float   $filter_width_x;
    float   $filter_width_y;
    float   $quantize_dither;
    float   $gain;
    float   $gamma;
    
    string  $render_camera;
    $render_camera = DRP_getRenderCamera($render_pass);

    $display_driver = DRP_getDisplayDriver($render_pass);

    $image_file = getAttr($render_pass + ".imageFilename");
    $image_file = DL_getExpandedFilename(
      $image_file, 
      "", 
      $render_pass, 
      $display_driver);
    
    $display_mode = getAttr($render_pass + ".displayMode");

    $pixel_filter = DRP_getPixelFilter($render_pass);

    $filter_width = DRP_getFilterWidth($render_pass);

    $quantize_string = DRP_getQuantizeString($render_pass);
    $quantize_dither = getAttr($render_pass + ".quantizeDither");

    if( $display_driver == "maya_render_view" )
    {
      $quantize_string = "0 255 0 255";

      if( DRP_isImmediateRenderMode($render_pass) )
        popupMayaRenderViewWindow($render_pass);
    }

    $gain = getAttr($render_pass + ".gain");
    $gamma = getAttr($render_pass + ".gamma");
    
    string $display_cmd =
      "RiDisplay -n \"" + $image_file + "\""
          + " -t \"" + $display_driver + "\""
          + " -m \"" + $display_mode + "\""
          + " -p \"exposure\" \"float[2]\" \"" + $gain + " " + $gamma + "\""
          + " -p \"quantize\" \"float[4]\" \"" + $quantize_string + "\""
          + " -p \"dither\" \"float\" \"" + $quantize_dither + "\""
          + " -p \"filter\" \"string\" \"" + $pixel_filter + "\""
          + " -p \"filterwidth\" \"float[2]\" \""
            + $filter_width[0] + " " + $filter_width[1] + "\""
          + " -p \"cameraname\" \"string\" \"" + $render_camera + "\"";

    $display_cmd = $display_cmd + " " + DL_getDisplayExtraParameters(
      $render_pass, $image_file, $display_driver, $display_mode );

    if( $display_driver == "idisplay" &&
        DRP_isRenderMode( $render_pass ) )
    {
      $display_cmd += RCP_getIDisplayParameters( $render_pass );
    }

    if( $display_driver == "dsm")
    {
      $display_cmd += " -p \"volumeinterpretation\" \"string\" \"" +
        DRP_getVolumeInterpretation($render_pass) + "\"";
    }

    eval $display_cmd;
  }
}

proc
outputSecondaryDisplays(string $render_pass)
{
  if (DRP_getRenderSecondaryDisplays($render_pass))
  {
    int     $display_indices[];
    int     $override_pixel_filter;
    string  $image_file;
    string  $display_driver;
    string  $display_mode;
    string  $pixel_filter;
    string  $quantize_string;
    float   $filter_width[];
    float   $filter_width_x;
    float   $filter_width_y;
    float   $quantize_dither;
    float   $gain;
    float   $gamma;
    
    string  $render_camera;
    $render_camera = DRP_getRenderCamera($render_pass);

    $display_indices = DRP_getSecondaryDisplayIndices($render_pass);

    for ($i in $display_indices)
    {
      // TODO: issue a warning if the filename is empty and don't output the
      // display statement
      $display_driver = DRP_getSecondaryDisplayDriver($render_pass, $i);

      $image_file = DRP_getSecondaryDisplayFilename($render_pass, $i);
      $image_file = DL_getExpandedFilename(
        $image_file, 
        "", 
        $render_pass, 
        $display_driver);
      
      $display_mode = DRP_getSecondaryDisplayMode($render_pass, $i);

      $override_pixel_filter =
        DRP_getSecondaryOverridePixelFilter($render_pass, $i);

      if ($override_pixel_filter)
      {
        $pixel_filter = DRP_getSecondaryDisplayPixelFilter($render_pass, $i);

        $filter_width[0] = DRP_getSecondaryDisplayFilterWidthX($render_pass,$i);
        $filter_width[1] = DRP_getSecondaryDisplayFilterWidthY($render_pass,$i);
      }
      else
      {
        $pixel_filter = DRP_getPixelFilter($render_pass);

        $filter_width = DRP_getFilterWidth($render_pass);
      }

      $quantize_string = DRP_getSecondaryDisplayQuantizeString($render_pass, $i);
      $quantize_dither = DRP_getSecondaryDisplayQuantizeDither($render_pass, $i);

      $gain = DRP_getSecondaryDisplayGain($render_pass, $i);
      $gamma = DRP_getSecondaryDisplayGamma($render_pass, $i);
      
      int $matte = DRP_getSecondaryDisplayMatte($render_pass, $i);
      int $exclusive = DRP_getSecondaryDisplayExclusive($render_pass, $i);
      int $assocalpha = DRP_getSecondaryDisplayAssociateAlpha($render_pass, $i);
      int $computealpha = DRP_getSecondaryDisplayComputeAlpha($render_pass, $i);

      if( $computealpha )
      {
        $display_mode += ",alpha";
      }

      if( $display_driver == "maya_render_view" )
      {
        string $primary_display;
        $primary_display = DRP_getDisplayDriver($render_pass);

        if( $primary_display == $display_driver )
        {
          warning( "3DFM: cannot render twice to Maya's Render View\n" );
          return;
        }

        $quantize_string = "0 255 0 255";

        if( DRP_isImmediateRenderMode($render_pass) )
          popupMayaRenderViewWindow($render_pass);
      }

      string $display_cmd =
        "RiDisplay -n \"+" + $image_file + "\""
            + " -t \"" + $display_driver + "\""
            + " -m \"" + $display_mode + "\""
            + " -p \"exposure\" \"float[2]\" \"" + $gain + " " + $gamma + "\""
            + " -p \"quantize\" \"float[4]\" \"" + $quantize_string + "\""
            + " -p \"dither\" \"float\" " + $quantize_dither
            + " -p \"filter\" \"string\" \"" + $pixel_filter + "\""
            + " -p \"filterwidth\" \"float[2]\" \"" + $filter_width[0] + " " + $filter_width[1] + "\""
            + " -p \"matte\" \"integer\" " + $matte
            + " -p \"exclusive\" \"integer\" " + $exclusive
            + " -p \"associatealpha\" \"integer\" " + $assocalpha
            + " -p \"cameraname\" \"string\" \"" + $render_camera + "\"";

      $display_cmd = $display_cmd +
        DRP_getSecondaryDisplayEdgeDetectionString($render_pass, $i);

      $display_cmd = $display_cmd + 
        DRP_getSecondaryDisplaySubset($render_pass, $i);
      
      $display_cmd = $display_cmd + " " + DL_getDisplayExtraParameters(
        $render_pass, $image_file, $display_driver, $display_mode );

      if( $display_driver == "dsm")
      {
        $display_cmd += " -p \"volumeinterpretation\" \"string\" \"" +
          DRP_getVolumeInterpretation($render_pass) + "\"";
      }

      eval $display_cmd;
    }
  }
}

proc
outputImageFormat(string $render_pass)
{
  float   $x_res;
  float   $y_res;
  float   $resolution_scale;
  float   $pixelAspectRatio;
  
  $x_res = getAttr($render_pass + ".resolutionX");
  $y_res = getAttr($render_pass + ".resolutionY");

  $resolution_scale = pow(2.0,
                          (float)(`getAttr($render_pass + ".resolutionMultiplier")`));

  $x_res /= $resolution_scale;
  $y_res /= $resolution_scale;

  $pixelAspectRatio = getAttr($render_pass + ".pixelAspectRatio");

  RiFormat -r $x_res $y_res -pa $pixelAspectRatio;
}

proc
outputCameraProjection(string $camera_name, 
                       float $x_res, float $y_res, 
                       float $pixel_aspect_ratio)
{
  int $is_ortho;
  float $screen_window[];
  float $lens_squeeze_ratio;
  float $film_pre_scale;
  float $film_post_scale;
  
  $film_pre_scale = getAttr($camera_name + ".preScale");
  $film_post_scale = getAttr($camera_name + ".postScale");
  
  $is_ortho = getAttr($camera_name + ".orthographic");  

  $lens_squeeze_ratio = 1.0;
  
  if ($is_ortho)
  {
    float $aspect_ratio;
    float $screen_width;
    float $screen_height;

    $aspect_ratio = (float)($x_res)/$y_res;
    
    float $ortho_width;
    $ortho_width = getAttr($camera_name + ".orthographicWidth");
    
    $screen_width = convertUIunitsToCM($ortho_width);
    $screen_height = $screen_width/$aspect_ratio;

    RiProjection -o;
    $screen_window[0] = $screen_width / -2;
    $screen_window[1] = $screen_width / 2;
    $screen_window[2] = $screen_height / -2;
    $screen_window[3] = $screen_height / 2;
  }
  else
  {
    float $fov;
    float $horiz_film_aperture;
    float $vert_film_aperture;
    float $aperture_ratio;
    float $resoltuion_ratio;
    float $horiz_film_offset;
    float $vert_film_offset;
    int $film_fit;
    float $camera_scale;
        
    $horiz_film_aperture = getAttr($camera_name + ".horizontalFilmAperture");
    $vert_film_aperture = getAttr($camera_name + ".verticalFilmAperture");

    $horiz_film_offset = getAttr($camera_name + ".horizontalFilmOffset");
    $vert_film_offset = getAttr($camera_name + ".verticalFilmOffset");
    
    $horiz_film_offset = $horiz_film_offset * $film_pre_scale * $film_post_scale;
    $vert_film_offset = $vert_film_offset * $film_pre_scale * $film_post_scale;

    $aperture_ratio = $horiz_film_aperture / $vert_film_aperture;
    $resolution_ratio = $x_res / $y_res;

    $film_fit = getAttr($camera_name + ".filmFit");
    float $film_fit_offset = getAttr($camera_name + ".filmFitOffset");

    if ($film_fit == 0)
    {
      $film_fit_offset = 0;

      if ($aperture_ratio < $resolution_ratio)
      {
        $film_fit = 1;
      }
      else
      {
        $film_fit = 2;
      }
    }
    else if ($film_fit == 3)
    {
      $film_fit_offset = 0;

      if ($aperture_ratio > $resolution_ratio)
      {
        $film_fit = 1;
      }
      else
      {
        $film_fit = 2;
      }
    }

    if ($film_fit == 1)
    {
      $fov = `camera -q -hfv $camera_name`;

      $horiz_film_offset = 2 * $horiz_film_offset / $horiz_film_aperture;
      $vert_film_offset = 2 * $vert_film_offset / $horiz_film_aperture;

      float $ratio_diff = ((1 / $resolution_ratio) - (1 / $aperture_ratio));
      if( $ratio_diff < 0 )
        $ratio_diff = 0;

      $vert_film_offset -= $film_fit_offset * $ratio_diff;

      $screen_window[0] = -1 + $horiz_film_offset;
      $screen_window[1] = 1 + $horiz_film_offset;
      $screen_window[2] = -(1 / $resolution_ratio) + $vert_film_offset;
      $screen_window[3] = (1 / $resolution_ratio) + $vert_film_offset;   
      
      $lens_squeeze_ratio = getAttr($camera_name + ".lensSqueezeRatio");
    }
    else
    {
      $fov = `camera -q -vfv $camera_name`;

      $horiz_film_offset = 2 * $horiz_film_offset / $vert_film_aperture;
      $vert_film_offset = 2 * $vert_film_offset / $vert_film_aperture;

      float $ratio_diff = $resolution_ratio - $aperture_ratio;
      if( $ratio_diff < 0 )
        $ratio_diff = 0;

      $horiz_film_offset -= $film_fit_offset * $ratio_diff;

      $screen_window[0] = -$resolution_ratio + $horiz_film_offset;
      $screen_window[1] = $resolution_ratio + $horiz_film_offset;
      $screen_window[2] = -1 + $vert_film_offset;
      $screen_window[3] = 1 + $vert_film_offset;
    }

    RiProjection -p $fov;
  }

  $camera_scale = getAttr($camera_name + ".cameraScale");    
  $camera_scale = $camera_scale * $lens_squeeze_ratio;
  $camera_scale = $camera_scale / ($film_pre_scale * $film_post_scale);

  $screen_window[0] *= $camera_scale;
  $screen_window[1] *= $camera_scale;
  $screen_window[2] *= $camera_scale / $pixel_aspect_ratio;
  $screen_window[3] *= $camera_scale / $pixel_aspect_ratio;

  RiScreenWindow -w $screen_window[0] $screen_window[1]
                 -h $screen_window[2] $screen_window[3];
}

proc
outputProjection(string $render_pass, string $camera)
{
  float $x_res;
  float $y_res;
  float $pixel_aspect_ratio;
  
  $x_res = getAttr($render_pass + ".resolutionX");
  $y_res = getAttr($render_pass + ".resolutionY");

  $pixel_aspect_ratio = getAttr($render_pass + ".pixelAspectRatio");

  outputCameraProjection($camera, $x_res, $y_res, $pixel_aspect_ratio);
}

proc
outputClipping(string $render_pass)
{
  float   $near_clip;
  float   $far_clip;
  string  $render_camera;

  $render_camera = DRP_getRenderCamera($render_pass);

  $near_clip = convertUIunitsToCM(getAttr($render_camera + ".nearClipPlane"));
  $far_clip = convertUIunitsToCM(getAttr($render_camera + ".farClipPlane"));

  RiClipping -b $near_clip $far_clip;
	
  RiAttribute -n "user" -p "_3dfm_near_clipping_plane" "float" $near_clip;
  RiAttribute -n "user" -p "_3dfm_far_clipping_plane" "float" $far_clip;
}

proc
outputShutter(string $render_pass)
{
  float $curr_frame;
  float $shutter_open;
  float $shutter_close;

  $curr_frame = `delightRenderState -qf`;
  $shutter_open = `delightRenderState -qso`;
  $shutter_close = `delightRenderState -qsc`;

  RiShutter($curr_frame + $shutter_open, $curr_frame + $shutter_close);
}

proc
outputCropWindow(string $render_pass)
{
  global float $DRP_crop_window_override[];
  int     $use_crop_window;
  float   $crop_min_x;
  float   $crop_min_y;
  float   $crop_max_x;
  float   $crop_max_y;

  $use_crop_window = getAttr($render_pass + ".useCropWindow");

  if( `size($DRP_crop_window_override)` == 4 )
  {
    $crop_min_x = $DRP_crop_window_override[0];
    $crop_min_y = $DRP_crop_window_override[1];
    $crop_max_x = $DRP_crop_window_override[2];
    $crop_max_y = $DRP_crop_window_override[3];

    clear($DRP_crop_window_override);
  }
  else if ($use_crop_window)
  {
    $crop_min_x = getAttr($render_pass + ".cropMinX");
    $crop_min_y = getAttr($render_pass + ".cropMinY");
    $crop_max_x = getAttr($render_pass + ".cropMaxX");
    $crop_max_y = getAttr($render_pass + ".cropMaxY");
  }
  else
  {
    $crop_min_x = 0;
    $crop_min_y = 0;
    $crop_max_x = 1;
    $crop_max_y = 1;
  }

  RiCropWindow -x $crop_min_x $crop_max_x -y $crop_min_y $crop_max_y;
}

proc
outputShadingRate(string $render_pass)
{
  float   $shading_rate;

  $shading_rate = getAttr($render_pass + ".shadingRate");

  RiShadingRate -s $shading_rate;

  delightRenderState -sr $shading_rate;
}

proc
outputPixelSamples(string $render_pass)
{
  float   $pixel_samples_x;
  float   $pixel_samples_y;

  $pixel_samples_x = getAttr($render_pass + ".pixelSamplesX");
  $pixel_samples_y = getAttr($render_pass + ".pixelSamplesY");

  RiPixelSamples -s $pixel_samples_x $pixel_samples_y;
}

proc
outputShutterEfficiency( string $render_pass )
{
  float $efficiency[2];

  if( `attributeExists "shutterEfficiencyA" $render_pass` )
  {
    $efficiency[0] = getAttr( $render_pass + ".shutterEfficiencyA" );
    $efficiency[1] = getAttr( $render_pass + ".shutterEfficiencyB" );
    
    RiOption -n "shutter"
             -p "efficiency" "float[2]" ($efficiency[0] + " " + $efficiency[1]); 
  }
}

proc
outputShutterOffset()
{
  float $offset = `delightRenderState -qf`;
  RiOption -n "shutter" -p "offset" "float" $offset;
}

proc
outputShadowMapDisplay(
  string $render_pass,
  string $light_name,
  int $append_shadow )
{
  string  $shader_collection;
  string  $attribs_node;
  string  $shadow_map_type;
  string  $image_file;
  string  $display_driver;
  string  $display_mode;

  $shader_collection = DRP_getShaderCollection($render_pass);
  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);

  string $param_string;
  
  string $attr = "shadowMapType";
  string $node_with_attr = DLA_getNodeWithAttribute(
    $attr, 
    $attribs_node, 
    $light_name);
  
  if ($node_with_attr != "")
  {
    $shadow_map_type = DLA_getShadowMapType($node_with_attr);
  }
  else
  {
    $shadow_map_type = "normal";
    $param_string = "-p \"filter\" \"string\" \"box\"";
    $param_string += " -p \"filterwidth\" \"float[2]\" \"1 1\"";
  }
  
  $attr = "shadowMapName";
  $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
  
  if ($node_with_attr != "")
  {
    $image_file = DLA_getShadowMapFilename($node_with_attr);
  }

  if ($image_file != "")
  {
    $image_file = DL_getExpandedFilename(
      $image_file, 
      $light_name, 
      $render_pass,
      "shadowmap");
  }
  else
  {
    $image_file = getDepthMapFilename($light_name);
  }

  if ($shadow_map_type == "normal")
  {
    $display_driver = "shadow";
    $display_mode = "z";
  }
  else // deep shadows
  {
    $display_driver = "dsm";
    $display_mode = "rgba";
      
    $attr = "volumeInterpretation";
    $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
  
    if ($node_with_attr != "")
    {
      $param_string += " -p \"volumeinterpretation\" \"string\" \"" +
      DLA_getVolumeInterpretation($node_with_attr) + "\"";
    }
  }

  if ($append_shadow )
  {
    $param_string += " -p \"aggregate\" \"integer\" \"1\"";
  }
  
  string $cmd = "RiDisplay -n \"" + $image_file + "\" -t " + $display_driver 
    + "-m " + $display_mode + $param_string;

  eval($cmd);
}

proc
outputShadowMapHider(string $light_name, 
                     string $shader_collection)
{
  string $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);

  string $shadow_map_type = "normal";
  string $attr = "shadowMapType";
  string $node_with_attr = DLA_getNodeWithAttribute(
    $attr, 
    $attribs_node, 
    $light_name);
  
  if ($node_with_attr != "")
  {
    $shadow_map_type = DLA_getShadowMapType($node_with_attr);
  }
  
  string  $depth_filter = "min";
  $attr = "shadowDepthFilter";
  $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
  
  if ($node_with_attr != "")
  {
    $depth_filter = DLA_getShadowMapDepthFilter($node_with_attr);
  }
  else if (attributeExists("useMidDistDmap", $light_name) == 1)
  {
    if (getAttr($light_name + ".useMidDistDmap") == 1)
    {
      $depth_filter = "midpoint";
    }
  }

  if ($shadow_map_type == "normal")
  {
    RiHider
      -id false
      -n "hidden"
      -p "depthfilter" "string" $depth_filter
      -p "jitter" "integer" 0;
  }
  else // deep shadows
  {
    RiHider -n "hidden";
  }
}

proc int[]
outputShadowMapFormat(string $light_name, 
                      string $shader_collection)
{
  string  $attribs_node;
  int     $x_res = -1;
  int     $y_res = -1;

  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);

  string $attr = "shadowMapResolutionX";
  string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
  
  if ($node_with_attr != "")
  {
    $x_res = DLA_getShadowMapResolutionX($node_with_attr);
  }
  
  $attr = "shadowMapResolutionY";
  $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
  
  if ($node_with_attr != "")
  {
    $y_res = DLA_getShadowMapResolutionY($node_with_attr);
  }
  
  if ($x_res >= 0 && $y_res >= 0)
  {
    $attr = "shadowMapType";
    $node_with_attr = DLA_getNodeWithAttribute(
      $attr, 
      $attribs_node, 
      $light_name);
  
    if ($node_with_attr != "")
    {
      string $type;
      $type = DLA_getShadowMapType($node_with_attr);
      
      if ($type == "deep")
      {
        // Deep shadow maps are required to be square
        if ($x_res != $y_res)
        {
          if ($x_res < $y_res)
          {
            $x_res = $y_res;
          }
          else
          {
            $y_res = $x_res;
          }
          
          warning("Deep Shadow Maps are required to be square.  "
            + "Changing resolution of "
            + $attribs_node
            + " to: "
            + $x_res
            + "x"
            + $y_res
            + "\n");
        }
      }
    }
  }
  else
  {
    if (attributeExists("dmapResolution", $light_name) == 1)
    {
      $x_res = getAttr($light_name + ".dmapResolution");
      $y_res = $x_res;
    }
    else
    {
      $x_res = $y_res = 512;
    }
  }

  RiFormat -r $x_res $y_res -pa 1;

  int $res[2] = { $x_res, $y_res };
  return $res;
}

proc
outputShadowMapClipping(string $shadow_camera, 
                        string $shader_collection)
{
  string  $light_name;
  string  $attribs_node;
  float   $near_clip;
  float   $far_clip;

  if (`nodeType $shadow_camera` == "camera")
  {
    $near_clip = convertUIunitsToCM(getAttr($shadow_camera + ".nearClipPlane"));
    $far_clip = convertUIunitsToCM(getAttr($shadow_camera + ".farClipPlane"));
  }
  else
  {
    $light_name = $shadow_camera;
    $attribs_node = 
      DL_getHighestLightAttribsNodeFromShape($light_name, 
                                             $shader_collection);
  
    string $attr = "nearClipPlane";
    string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

    if ($node_with_attr != "")
    {
      $near_clip = convertUIunitsToCM(DLA_getNearClipPlane($node_with_attr));
    }
    else
    {
      $near_clip = 0.001;
    }
    
    $attr = "farClipPlane";
    $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

    if ($node_with_attr != "")
    {
      $far_clip = convertUIunitsToCM(DLA_getFarClipPlane($node_with_attr));
    }
    else
    {
      $far_clip = 10000.000;
    }
  }

  RiClipping -b $near_clip $far_clip;
}

proc
outputShadowMapShutter(string $render_pass, string $light_name)
{
  string  $shader_collection;
  string  $attribs_node;
  int     $gen_motion_blur;
  float   $curr_frame;
  float   $shutter_open;
  float   $shutter_close;

  $shader_collection = DRP_getShaderCollection($render_pass);
  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);
  
  string $attr = "generateWithMotionBlur";
  string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

  if ($node_with_attr != "")
  {
    $gen_motion_blur = DLA_generateWithMotionBlur($node_with_attr);
  }
  else
  {
    $gen_motion_blur = 0;
  }

  $curr_frame = `delightRenderState -qf`;

  $shutter_open = `delightRenderState -qso`;

  if( $gen_motion_blur )
    $shutter_close = `delightRenderState -qsc`;
  else
    $shutter_close = $shutter_open;

  RiShutter($curr_frame + $shutter_open, $curr_frame + $shutter_close);
}

proc
outputShadowMapShadingRate(string $light_name, 
                           string $shader_collection)
{
  string  $attribs_node;
  float   $shading_rate;

  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);

  string $attr = "shadowMapShadingRate";
  string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

  if ($node_with_attr != "")
  {
    $shading_rate = DLA_getShadowMapShadingRate($node_with_attr);
  }
  else
  {
    $shading_rate = "1";
  }

  RiShadingRate -s $shading_rate;

  delightRenderState -sr $shading_rate;
}

proc
outputShadowMapPixelSamples(string $light_name, 
                            string $shader_collection)
{
  string  $attribs_node;
  string  $shadow_map_type;
  float   $pixel_samples_x = 1;
  float   $pixel_samples_y = 1;

  $attribs_node = 
    DL_getHighestLightAttribsNodeFromShape($light_name, 
                                           $shader_collection);
  
  string $attr = "shadowMapShadingRate";
  string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

  if ($node_with_attr != "")
  {
    $shadow_map_type = DLA_getShadowMapType($node_with_attr);
  }
  else
  {
    $shadow_map_type = "normal";
  }

  if ($shadow_map_type == "normal")
  {
    $pixel_samples_x = 1;
    $pixel_samples_y = 1;
  }
  else
  {
    $attr = "shadowMapPixelSamplesX";
    $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);

    if ($node_with_attr != "")
    { 
      $pixel_samples_x = DLA_getShadowMapPixelSamplesX($node_with_attr);
    }
    
    $attr = "shadowMapPixelSamplesY";
    $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
    
    if ($node_with_attr != "")
    {
      $pixel_samples_y = DLA_getShadowMapPixelSamplesY($node_with_attr);
    }
  }

  RiPixelSamples -s $pixel_samples_x $pixel_samples_y;
}

proc 
outputShadowMapProjection(string $shadow_camera, 
                          string $shadow_objects[], 
                          int $resolution[], 
                          string $shader_collection)
{
  string $light_name;
  string $attribs_node;

  if (`nodeType $shadow_camera` == "camera")
  {
    outputCameraProjection($shadow_camera, $resolution[0], $resolution[1], 1.0);
  }
  else
  {
    $light_name = $shadow_camera;
    $attribs_node = 
      DL_getHighestLightAttribsNodeFromShape($light_name, 
                                             $shader_collection);

    int $gen_cube_shd = 0;
    string $attr = "generateCubeShadowMap";
    string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light_name);
    
    if ($node_with_attr != "")
    {
      $gen_cube_shd = DLA_getGenerateCubeShadowMap($node_with_attr);
    }
    
    string $transform;
    $transform = firstParentOf($light_name);
    float $scale[] = getAttr($transform + ".scale");
      
    if( objExists( $light_name + ".coneAngle" ) )
    {
      float $coneAngle = getAttr($light_name + ".coneAngle");
      if( objExists( $light_name + ".penumbraAngle" ) )
      {
        $coneAngle += 2 * getAttr($light_name + ".penumbraAngle");
      }
      RiProjection -p $coneAngle;
    }
    else if(   nodeType($light_name) == "pointLight" 
            || (   nodeType($light_name) == "volumeLight" 
                && `getAttr -asString ($light_name + ".lightShape")` != "Cone" )
            || $gen_cube_shd)
    {
      RiProjection -p 90;
    }
    else if( nodeType($light_name) == "volumeLight" &&
            `getAttr -asString ($light_name + ".lightShape")` == "Cone" )
    {
      float $maxScale = $scale[0] > $scale[2] ? $scale[0] : $scale[2];
      RiProjection -p (atand($maxScale / $scale[1]));
    }
    else if( `nodeType $light_name` == "directionalLight" )
    {
      float $map_aspect_ratio = (float)($resolution[0]) / $resolution[1];

      float $lightXform[] = `getAttr ($light_name + ".worldInverseMatrix")`;

      // Cancel the scale on the transform to get proper bounding box.
      //
      matrix $lightXform_mat[4][4] = float16ToMatrix44($lightXform);
      matrix $scale_mat[4][4] = <<
        $scale[0], 0, 0, 0;
        0, $scale[1], 0, 0;
        0, 0, $scale[2], 0;
        0, 0, 0, 1>>;
      
      matrix $scaled_xform_mat[4][4] = $scale_mat * $lightXform_mat;
      float $scaledXform[] = matrix44ToFloat16($scaled_xform_mat);
      
      float $worldBBox[6] = `exactWorldBoundingBox $shadow_objects`;
      float $cameraBBox[6] = transformBBox( $worldBBox, $scaledXform );

      float $bbox_min[3] = { $cameraBBox[0], $cameraBBox[1], $cameraBBox[2] };
      float $bbox_max[3] = { $cameraBBox[3], $cameraBBox[4], $cameraBBox[5] };

      /*
        Resize the box to match the shadow map's aspect ratio. This is to ensure
        the scene geometry is not stretched in either direction in the map so
        that the blur in lookups behaves in a predictable way.
      */
      float $spanx = $bbox_max[0] - $bbox_min[0];
      float $spany = $bbox_max[1] - $bbox_min[1];
      float $scene_aspect_ratio = $spanx / $spany;

      if( $scene_aspect_ratio > $map_aspect_ratio )
      {
        // Scene aspect ratio is wider than map, enlarge vertically.
        float $new_spany = $spanx / $map_aspect_ratio;
        float $span_delta = ($new_spany - $spany) * 0.5;
        $bbox_min[1] -= $span_delta;
        $bbox_max[1] += $span_delta;
      }
      else
      {
        // Scene aspect ratio is narrower than map, enlarge horizontally.
        float $new_spanx = $spany * $map_aspect_ratio;
        float $span_delta = ($new_spanx - $spanx) * 0.5;
        $bbox_min[0] -= $span_delta;
        $bbox_max[0] += $span_delta;
      }

      RiProjection -o;
      RiScreenWindow -w $bbox_min[0] $bbox_max[0]
                     -h $bbox_min[1] $bbox_max[1];

      /*
        This ensures we see even objects behind the light as a directional light
        comes from infinity. We should eventually add some sort of pref for this.
      */
      if( $bbox_max[2] > 0 )
      {
        RiTranslate 0 0 ($bbox_max[2]);
      }
    }
  }
}

proc
outputHider(string $render_pass)
{
  string $hider = DRP_getHider($render_pass);

  string $cmd = "RiHider -n " + DRP_getHider($render_pass);
  $cmd += " -p \"depthfilter\" \"string\" " + DRP_getDepthFilter($render_pass);
  $cmd += " -p \"jitter\" \"integer\" ";
  
  if (   DRP_getRenderPrimaryDisplay($render_pass) 
      && DRP_getDisplayDriver($render_pass) == "shadowmap")
  {
    $cmd += 0;
  }
  else
  {
    $cmd += 1;
  }
  
  eval($cmd);
}

proc
outputDepthOfField(string $render_pass)
{
  // in maya the focal length is always specified in millimeters
  // the focal distance is specified in UI units

  string  $render_camera;
  int     $do_depth_of_field;

  $render_camera = DRP_getRenderCamera($render_pass);

  $do_depth_of_field = getAttr($render_camera + ".depthOfField");

  if ($do_depth_of_field)
  {
    float   $focal_length;
    float   $f_stop;
    float   $focus_distance;

    $focal_length = getAttr($render_camera + ".focalLength");
    $f_stop = getAttr($render_camera + ".fStop");
    $focus_distance = getAttr($render_camera + ".focusDistance");

    // convert everything to centimeters
    $focus_distance = convertUIunitsToCM($focus_distance);
    $focal_length = $focal_length/10;

    RiDepthOfField -fs $f_stop -fl $focal_length -fd $focus_distance;
  }
  // else output nothing.. pinhole camera
}

proc
outputNumThreads(string $render_pass)
{
  int $num_threads;

  $num_threads = getAttr($render_pass + ".numberOfCPUs");

  if ($num_threads != 0)
    RiOption -n "render" -p "nthreads" "integer" $num_threads;
  // else don't output anything.. let the global config (or renderdl command
  // line) set this
}

global proc
outputPhotonMapOptions(string $render_pass)
{
  string $global_map;
  string $caustic_map;
  int $write_mpas;
  int $number_of_photons;

  $number_of_photons = DRP_getNumberOfPhotons( $render_pass );
  RiOption -n "photon" -p "emit" "integer" $number_of_photons;

  $write_maps = DRP_getWritePhotonMaps( $render_pass );
  RiOption -n "photon" -p "writemaps" "integer" $write_maps;

  $global_map = DRP_getGlobalPhotonMap( $render_pass );
  $caustic_map = DRP_getCausticPhotonMap( $render_pass );
  
  RiAttribute -n "photon"
              -p "globalmap" "string" $global_map
              -p "causticmap" "string" $caustic_map;
}

proc
outputShadowMapImageOptions(
  string $render_pass,
  string $light_name,
  string $shadow_camera,
  string $shadow_objects[],
  int $face_number,
  int $append_shadow )
{
  if( attributeExists( "_3dfm_output_image_options_proc", $light_name ) )
  {
    string $custom_output_proc =
      getAttr( $light_name + "._3dfm_output_image_options_proc" );

    if( $custom_output_proc != "" )
    {
      eval( $custom_output_proc + "( " +
        "\"" + $render_pass + "\"," +
        "\"" + $light_name + "\"," +
        "\"" + $shadow_camera + "\"," +
        $face_number + "," +
        $append_shadow + ")" );

      return;
    }
  }

  float $z_thresh[];
  int $resolution[2];
  string $shader_collection;

  $z_thresh = DRP_getZthreshold($render_pass);
  $shader_collection = DRP_getShaderCollection($render_pass);

  RiOption -n "limits"
           -p "zthreshold"
              "color"
              (  $z_thresh[0] + " "
               + $z_thresh[1] + " "
               + $z_thresh[2]);

  outputNumThreads($render_pass);

  outputShadowMapShadingRate($light_name, $shader_collection);

  outputShadowMapPixelSamples($light_name, $shader_collection);

  outputShadowMapHider($light_name, $shader_collection);

  outputShadowMapDisplay($render_pass, $light_name, $append_shadow);

  $resolution = outputShadowMapFormat($light_name, $shader_collection);

  outputShadowMapProjection($shadow_camera, 
                            $shadow_objects, 
                            $resolution, 
                            $shader_collection);

  outputShadowMapClipping($shadow_camera, $shader_collection);
  outputShadowMapShutter($render_pass, $light_name);
  outputShutterEfficiency( $render_pass );
}

proc
outputImageOptions(string $render_pass)
{
  outputNumThreads($render_pass);

  outputShadingRate($render_pass);
  outputPixelSamples($render_pass);
  outputHider($render_pass);

  outputPrimaryDisplay($render_pass);
  outputSecondaryDisplays($render_pass);

  outputImageFormat($render_pass);
  outputClipping($render_pass);
  outputShutter($render_pass);
  outputShutterEfficiency($render_pass);
  outputCropWindow($render_pass);
}

proc
outputClippingPlanes(string $all_clipping_planes[])
{
  // NOTE: clipping planes cannot have motion blur
  for ($curr_plane in $all_clipping_planes)
  {
    outputRIBcomment("clipping plane: " + $curr_plane);
    RiTransformBegin;
      outputTransform($curr_plane, 0, 1, 0);
      RiClippingPlane -p 0 0 0 -n 0 0 1;
    RiTransformEnd;
  }
}

proc
outputCoordinateSystems(string $all_corrdinate_systems[])
{
  outputRIBcomment("");
  outputRIBcomment("start coordinate systems");

  // NOTE: corrdinate systems cannot have motion blur
  for ($curr_system in $all_corrdinate_systems)
  {
    RiTransformBegin;
      outputTransform($curr_system, 0, 0, 0);
      RiCoordinateSystem -n `DL_getShortestUniqueDAGpath($curr_system)`;
    RiTransformEnd;
  }

  outputRIBcomment("");
  outputRIBcomment("end coordinate systems");
}

proc
outputRIBoptions(string $render_pass,
                 int $curr_frame)
{
  float $start_time = `timerX`;
  outputRIBcomment("");
  outputRIBcomment("Start of RIB options.");
  outputRIBcomment("{");

  string  $shader_path;
  string  $texture_path;

  string  $procedural_path;

  string  $pass_name;

  int     $eye_splits;

  int     $texture_memory;
  
  int     $grid_size;

  int     $bucket_size_x;
  int     $bucket_size_y;

  float   $opacity_thresh[];

  int     $trace_max_depth;

  int     $use_netcache;
  string  $netcache_dir;
  int     $netcache_size;

  string  $statistics_file;
  int     $statistics_level;

  int     $standard_atmosphere;
  string  $shader_collection;

  int     $progress;
  
  $shader_path = getAttr($render_pass + ".shaderPath");
  $texture_path = getAttr($render_pass + ".texturePath");
  $procedural_path = getAttr($render_pass + ".proceduralPath");
  $archive_path = getAttr($render_pass + ".archivePath");

  $eye_splits = getAttr($render_pass + ".eyeSplits");

  $texture_memory = getAttr($render_pass + ".textureMemory");
  $grid_size = getAttr($render_pass + ".gridSize");

  $bucket_size_x = getAttr($render_pass + ".bucketSizeX");
  $bucket_size_y = getAttr($render_pass + ".bucketSizeY");

  $opacity_thresh = DRP_getOpacityThreshold($render_pass);

  $trace_max_depth = getAttr($render_pass + ".raytraceMaxDepth");

  $use_netcache = getAttr($render_pass + ".useNetCache");
  $netcache_dir = getAttr($render_pass + ".netCacheDir");
  $netcache_size = getAttr($render_pass + ".netCacheSize");

  $statistics_file = getAttr($render_pass + ".statisticsFile");
  $statistics_file = DL_getExpandedFilename($statistics_file, "", $render_pass, "");

  $statistics_level = getAttr($render_pass + ".statisticsLevel");

  $standard_atmosphere = getAttr($render_pass + ".standardAtmosphere");
  
  $shader_collection = DRP_getShaderCollection($render_pass);

  $progress = getAttr($render_pass + ".outputRenderProgress");
  
  if (objExists($render_pass + ".passName"))
    $pass_name = getAttr($render_pass + ".passName");
  else
    $pass_name = "";

  RiOption -n "limits"
           -p "bucketsize"
              "integer[2]"
              ($bucket_size_x + " " + $bucket_size_y);
  RiOption -n "limits"
           -p "gridsize" "integer" $grid_size;
  RiOption -n "limits"
           -p "texturememory" "integer" $texture_memory;
  RiOption -n "limits"
           -p "eyesplits" "integer" $eye_splits;
  RiOption -n "limits"
           -p "othreshold"
              "color"
              (  $opacity_thresh[0] + " "
               + $opacity_thresh[1] + " "
               + $opacity_thresh[2]);

  RiOption -n "trace" -p "maxdepth" "integer" $trace_max_depth;

  string  $bucket_order;

  $bucket_order = DRP_getBucketOrder($render_pass);

  RiOption -n "render"
           -p "bucketorder" "string" $bucket_order;

  RiOption -n "searchpath"
           -p "shader" "string" $shader_path
           -p "texture" "string" $texture_path
           -p "procedural" "string" $procedural_path
           -p "archive" "string" $archive_path;

  RiOption -n "searchpath"
           -p "procedural" "string" "&:$DELIGHT/lib";

  RiOption -n "user"
           -p "delight_curr_frame" "integer" ($curr_frame);

  RiOption -n "user"
           -p "delight_shader_collection" "string" $shader_collection;

  if ($pass_name != "")
  {
    RiOption -n "user"
             -p "delight_pass_name" "string" $pass_name;
  }

  RiOption -n "user"
           -p "delight_renderpass_name" "string" $render_pass;

  if ($use_netcache && $netcache_dir != "")
  {
    RiOption -n "netcache"
             -p "cachedir" "string" $netcache_dir
             -p "cachesize" "integer" $netcache_size;
  }

  RiOption -n "statistics"
           -p "endofframe" "integer" $statistics_level
           -p "filename" "string" $statistics_file;

  RiOption -n "statistics" -p "progress" "integer" $progress;
  
  RiOption -n "render" -p "standardatmosphere" "integer" $standard_atmosphere;
  
  RiOrientation "rh";
  RiShadingInterpolation "smooth";

  outputTimingComment("RIB options output in ", $start_time);

  outputRIBcomment("}");
  outputRIBcomment("End of RIB options.");
  outputRIBcomment("\n");
}

proc
outputShadowMapUserAttribs(string $render_pass)
{
  RiAttribute -n "user" -p "ShadowMapRendering" "float" "1";
  
  if (!DRP_getUseDisplacementShadersInShadows($render_pass))
  {
    RiAttribute -n "user" -p "_3dfm_filter_displacement" "float" "1";
  }
  
  if (!DRP_getUseSurfaceShadersInShadows($render_pass))
  {
    RiAttribute -n "user" -p "_3dfm_filter_surface" "float" "1";
  }
    
  if (!DRP_getUseAtmosphereShadersInShadows($render_pass))
  {
    RiAttribute -n "user" -p "_3dfm_filter_atmosphere" "float" "1";
  }

  if (!DRP_getUseInteriorShadersInShadows($render_pass))
  {
    RiAttribute -n "user" -p "_3dfm_filter_interior" "float" "1";
  }
}

proc
DRP_outputGeoAttribsArchives(
  string $render_pass,
  string $all_geometry[])
{
  float $start_time = `timerX`;

  // Get the shader collection used by the render pass
  //
  string $shader_collection = DRP_getShaderCollection($render_pass);

  string $attribs_to_archive[];

  for ($curr_shape in $all_geometry)
  {
    string  $geo_attribs[];

    $geo_attribs = DL_getAllGeoAttribsNodesFromShape(
                     $curr_shape,
                     $shader_collection);

    appendStringArray($attribs_to_archive, $geo_attribs, size($geo_attribs));
  }

  $attribs_to_archive = DL_stringArrayRemoveDuplicates($attribs_to_archive);

  if (size($attribs_to_archive) != 0)
  {
    outputRIBcomment("");
    outputRIBcomment("Start of attribs nodes archives.");
    outputRIBcomment("{");
  }

  string $curr_frame = `delightRenderState -qf`;
  
  int $num_attribs_to_archive = size($attribs_to_archive);
  beginProgressRange( 33, $num_attribs_to_archive );

  for ($curr_attribs in $attribs_to_archive)
  {
    RiArchiveBegin -n $curr_attribs;

      DGA_output($curr_attribs, $render_pass);

    RiArchiveEnd;

    incProgress( 1, 0 );
  }

  if ($num_attribs_to_archive != 0)
  {
    outputTimingComment("Attribs node archives output in ", $start_time);

    outputRIBcomment("}");
    outputRIBcomment("End of attribs nodes archives.");
    outputRIBcomment("\n");
  }
}

proc
outputInstancerGeometryArchives(string $render_pass, 
                                string $instancer_geometry[])
{
  string $shader_collection;
  int $output_geo_shaders;
  int $output_geo_attribs;
  int $is_rib_archiving_mode;

  $shader_collection = DRP_getShaderCollection($render_pass);
  $output_geo_shaders = 1;
  $output_geo_attribs = 1;
  $is_rib_archiving_mode = DRP_isRIBArchivingMode($render_pass);

  if ($is_rib_archiving_mode)
  {
    $output_geo_shaders = getAttr($render_pass + ".archiveGeometryShaders");
    $output_geo_attribs = getAttr($render_pass + ".archiveGeometryAttributes");
  }

  $shader_collection = DRP_getShaderCollection($render_pass);
  int $use_translated_shaders = `DRP_getUseMayaShaders($render_pass)`;
  int $use_surface_shaders_in_shadows = 
    `DRP_getUseSurfaceShadersInShadows($render_pass)`;

  int $use_displacement_shaders_in_shadows =
    `DRP_getUseDisplacementShadersInShadows($render_pass)`;

  int $use_atmosphere_shaders_in_shadows =
    `DRP_getUseAtmosphereShadersInShadows($render_pass)`;

  int $use_interior_shaders_in_shadows = 
    `DRP_getUseInteriorShadersInShadows($render_pass)`;

  for ($geo in $instancer_geometry)
  {
    string $all_attribs_nodes[] = 
      DL_getAllGeoAttribsNodesFromShape($geo, 
                                        $shader_collection);

    RiArchiveBegin -n ($geo + " instancer");

      RiAttributeBegin;

        RiAttribute -n "identifier" -p "name" "string" $geo;

        string $shortest_unique_names[] = `ls $geo`;
        string $shortest_unique_name = 
          DL_substituteAllString($shortest_unique_names[0], "|", "#");

        RiAttribute 
          -n "user" 
          -p "delight_shortest_unique_name" "string" $shortest_unique_name;

        outputTransform($geo, 0, 1, $is_rib_archiving_mode);

        if ($output_geo_attribs)
        {
          outputGroupMemberships($geo);
          delightOutputRenderStats $geo $all_attribs_nodes;
        }

        string $highest_node;

        $highest_node = DL_highestNodeWithAttrib("preGeoMEL",
                                                 $all_attribs_nodes);

        if ($highest_node != "")
          DGA_executePreGeoMelScript($highest_node, $geo);

        if ($output_geo_shaders)
        {
          outputGeometryShaders(
            $geo,
            0,
            $shader_collection,
            $use_translated_shaders,
            $use_surface_shaders_in_shadows,
            $use_displacement_shaders_in_shadows,
            $use_atmosphere_shaders_in_shadows,
            $use_interior_shaders_in_shadows);
        }

        $highest_node = DL_highestNodeWithAttrib("outputGeometry",
                                                 $all_attribs_nodes);

        if (DGA_outputGeometry($geo, $highest_node))
        {
          string $geo_type = `nodeType $geo`;

          if ($geo_type == "delightRibArchive")
          {
            DRA_outputNode($geo, 0, $render_pass);
          }
          else
          {
            string $geo_to_output = $geo;

            if (isInstanced($geo))
              $geo_to_output = getFirstInstance($geo);

            if( !canUseObjectInstance( $geo, $geo_type ) )
            {
              RiReadArchive -archiveName $geo_to_output;
            }
            else
            {
              RiObjectInstance -name $geo_to_output;
            }
          }
        }
        else
        {
          string $comment;

          $comment =   "Geo Attribs Node: "
                     + $highest_node
                     + " is set to not output geometry";

          outputRIBcomment($comment);
        }

        $highest_node = DL_highestNodeWithAttrib("postGeoMEL",
                                                 $all_attribs_nodes);

        if ($highest_node != "")
          DGA_executePostGeoMelScript($highest_node, $geo);

      RiAttributeEnd;

    RiArchiveEnd;
  }
}

proc 
DRP_outputInstancerArchives(string $render_pass)
{
  outputRIBcomment("");
  outputRIBcomment("Start of instancer archives.");

  int $output_geo_attribs;
  int $is_rib_archiving_mode;

  string $instancers_to_archive[];
  string $renderable_instancer_geo[];

  $output_geo_attribs = 1;
  $is_rib_archiving_mode = DRP_isRIBArchivingMode($render_pass);

  $instancers_to_archive = `delightCacheInstancer -list`;
  $renderable_instancer_geo = `delightCacheInstancer -listAllGeometry`;

  if ($is_rib_archiving_mode)
  {
    $output_geo_attribs = getAttr($render_pass + ".archiveGeometryAttributes");
  }

  outputInstancerGeometryArchives($render_pass, $renderable_instancer_geo);

  for ($instancer in $instancers_to_archive)
  {
    // Instancers will output several archives (one for each of 
    // its geo) and all the RiArchiveBegin and RiArchiveEnd calls 
    // will be done in the API.
    delightCacheInstancer -emit $instancer;

    // Don't remove from the cache yet.
  }

  outputRIBcomment("End of instancer archives.");
  outputRIBcomment("\n");
}

proc
DRP_outputImagerShader(string $render_pass)
{
  //
  // Description:
  //  This procedure outputs the imager shader used by the render camera of
  //  the specified render pass, if any such imager shader exists.
  //

  if (DRP_useImagerShaders($render_pass))
  {
    string  $render_camera;
    string  $imager_shader;
    string  $collection;
    
    $render_camera = DRP_getRenderCamera($render_pass);
    $collection = DRP_getShaderCollection($render_pass);
    
    $imager_shader = DL_getShaderFromShape($render_camera, "imager", $collection);

    if ($imager_shader != "")
    {
      DSN_outputImagerShader($imager_shader);
    }
    else
    {
      /* Support the backgroundColor attribute with an imager shader. */
      float $bgcolor[] = getAttr( $render_camera + ".backgroundColor" );

      if( $bgcolor[0] > 1e-4 || $bgcolor[1] > 1e-4 || $bgcolor[2] > 1e-4 )
      {
        RiImager
          -n "background"
          -p "bgcolor" "color" `floatArrayToString($bgcolor)`;
      }
    }
  }
}

proc
outputLight(
  string $light, 
  int $output_xforms,
  int $concatenate_xforms, 
  int $is_rib_archiving_mode,
  string $shader_collection, 
  string $area_light_plane,
  int $illuminate)
{
  string  $attribs_node;
  string  $shadowmap_name = "";
  int     $emit_photons = 0;
  int     $is_key_light = 0;

  $attribs_node = DL_getHighestLightAttribsNodeFromShape(
    $light, 
    $shader_collection);

  string $attr = "generateShadowMaps";
  string $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light);

  if ($node_with_attr != "")
  {
    if (DLA_getGenerateShadowMaps($node_with_attr) != 0)
    {
      $attr = "shadowMapName";
      $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light);
      
      if ($node_with_attr != "")
      {
        $shadowmap_name = DLA_getShadowMapFilename($node_with_attr);
      }
      
      if ($shadowmap_name != "")
      {
        $shadowmap_name = DL_getExpandedFilename(
          $shadowmap_name, 
          $light, 
          `delightRenderState -qrn`,
          "shadowmap");
      }
      else
      {
        $shadowmap_name = getDepthMapFilename($light);
      }
    }
  }
  else if (attributeExists("useDepthMapShadows", $light) == 1)
  {
    if (getAttr($light + ".useDepthMapShadows") == 1)
    {      
      $shadowmap_name = getDepthMapFilename($light);
    }
  }

  $attr = "emitPhotons";
  $node_with_attr = DLA_getNodeWithAttribute($attr, $attribs_node, $light);
  
  if ($node_with_attr != "")
  {
    $emit_photons = DLA_emitPhotons($node_with_attr);
  }
 
  string $shortest_paths[] = `ls $light`;
  string $shortest_path = $shortest_paths[0];

  // We need an attribute block here since the "shadows" attribute
  // below has to be bound to this light only. Same goes for 
  // automatic photon mapping attribute...
  //
  RiAttributeBegin;
  
    RiAttribute -n "identifier" -p "name" "string" $light;

    if ($shadowmap_name != "")
    {
      RiAttribute -n "user"
                  -p "delight_shadowmap_name" "string" $shadowmap_name;
    }

    if ($output_xforms)
    {
      outputTransform($light, 0, $concatenate_xforms, $is_rib_archiving_mode);
    }
   
    // RenderMan light shaders usually look into the positive Z direction 
    // (from=[0,0,0], to=[0,0,1]) but Maya lights look into the opposite way 
    // (to=[0,0-1]). So I put this RiScale here and I cross my fingers not 
    // to break anything! 
    // More seriously, this could be bad if the light shader transforms 
    // points or normals to its own "shader" space. But in my experience, 
    // this is very rare. 
    //
    RiScale 1 1 -1;

    if ($emit_photons == 1)
    {
      RiAttribute -n "light" -p "emitphotons" "string" "on"; 
    }

    $node_with_attr = DLA_getNodeWithAttribute("samples", $attribs_node, $light);
    if ($node_with_attr != "")
    {
      int $samples = DLA_getSamples($node_with_attr);
      RiAttribute -n "light" -p "samples" "integer" $samples;
    }
    
    $node_with_attr = DLA_getNodeWithAttribute(
      "samplingStrategy", 
      $attribs_node, 
      $light);
      
    if ($node_with_attr != "")
    {
      int $sampling_strategy = DLA_getSamplingStrategy($node_with_attr);
      
      RiAttribute 
        -n "light" 
        -p "samplingstrategy" "string" 
          ($sampling_strategy > 0 ? "illuminance" : "lightsource");
    }
    
    RiIfBegin -e 
      (   "!defined(user:_3dfm_filter_lightsource) " +
       "|| $user:_3dfm_filter_lightsource == 0");

    string $light_output_cmd = getLightOutputCommand($light);
    if ($light_output_cmd != "")
    {
      $light_output_cmd += "(\"" + $shortest_path;
      $light_output_cmd += "\", \"" + $shader_collection;
      $light_output_cmd +=  "\")";
      
      eval($light_output_cmd);
    }
    else
    {
      string $light_shader = 
        DL_getShaderFromShape($light, "light", $shader_collection);

      if ($light_shader != "")
      {
        DSN_outputLightShader($light_shader, $light);
      }
      else
      {
        outputDefaultLightShader($light, $attribs_node, $shadowmap_name);
      }

      if (`nodeType $light` == "areaLight")
      {
        // Make the area light plane invisible to the render.
        RiAttribute -n "visibility" -p "camera" "integer" 0;

        RiObjectInstance -name $area_light_plane;
      }
    }

    RiIfEnd;
    
  RiAttributeEnd;

  // We have to switch this light on since, by default, it is disabled
  // outside the attribute block above.
  // We could bypass this for $illuminate == 0 but the illuminate statement make
  // this crystal clear.
  //
  string $illuminate_cmd = getLightIlluminateCommand( $light );
  if( $illuminate_cmd != "" )
  {
    $illuminate_cmd += "(\"" + $shortest_path + "\", " + $illuminate + ")";
    eval( $illuminate_cmd );
  }
  else
  {
    RiIlluminate -h $shortest_path -s $illuminate;
  }
}

proc
DRP_outputLights(
  string $render_pass,
  string $visible_lights[], 
  int $output_transforms, 
  string $area_light_plane)
{
  outputRIBcomment("");
  outputRIBcomment("start lights");

  int     $is_rib_archiving_mode;
  int     $concatenate_xforms;
  string  $shader_collection;

  $is_rib_archiving_mode = DRP_isRIBArchivingMode($render_pass);

  if ($is_rib_archiving_mode)
  {
    if (size($visible_lights) > 0)
    {
      RiIfBegin -e "!defined(IgnoreArchivedLighting)";
    }
    
    $concatenate_xforms = DRP_getConcatenateLightTransforms($render_pass);
  }
  else
  {
    $concatenate_xforms = 0;
  }
  
  $shader_collection = DRP_getShaderCollection($render_pass);

  string $default_light_set_members[] = getDefaultLightSetShapes(1);  
  string $vis_lights_in_default_light_set[] = DL_stringArrayIntersect(
    $visible_lights, 
    $default_light_set_members);
    
  string $vis_lights_not_in_default_light_set[] = DL_stringArrayDifference(
    $visible_lights,
    $vis_lights_in_default_light_set);
  
  beginProgressRange( 25, size($visible_lights) );
  string $curr_frame = `delightRenderState -qf`;
  setProgressMessage( "Frame " + $curr_frame + ": outputting lights: ", 0 );

  for ($curr_light in $vis_lights_in_default_light_set)
  {
    outputLight(
      $curr_light, 
      $output_transforms, 
      $concatenate_xforms, 
      $is_rib_archiving_mode,
      $shader_collection,
      $area_light_plane,
      1);

    incProgress( 1, 0 );
  }

  for ($curr_light in $vis_lights_not_in_default_light_set)
  {
    outputLight(
      $curr_light, 
      $output_transforms, 
      $concatenate_xforms, 
      $is_rib_archiving_mode,
      $shader_collection, 
      $area_light_plane,
      0);

    incProgress( 1, 0 );
  }

  if ($is_rib_archiving_mode && size($visible_lights) > 0)
  {
    RiIfEnd;
  }

  outputRIBcomment("");
  outputRIBcomment("end lights");
}

proc
DRP_outputGeometryShaderArchives(
  string $render_pass, 
  string $all_renderable_geometry[])
{
  float $start_time = `timerX`;

  int $use_maya_shaders;
  $use_maya_shaders = getAttr($render_pass + ".useMayaShaders");
  
  // Get the shader collection used by the render pass
  //
  string $shader_collection = DRP_getShaderCollection($render_pass);

  string $shader_types[] = 
    {"surface", "displacement", "atmosphere", "interior"};

  string $shaders_to_archive[];
  string $maya_shaders_to_archive[];

  // Get all shaders used by all renderable geometry in the context of the
  // specified render pass.
  //
  for ($shader_type in $shader_types)
  {
    for ($shape in $all_renderable_geometry)
    {
      string $shader;
      
      $shader = DL_getHighestAttribsNodeFromShape(
        $shape, 
        $shader_type, 
        $shader_collection);

      if ($shader == "")
      {
        if ($use_maya_shaders != 0)
        {
          string $maya_shader;
          $maya_shader = getTranslatedMayaShaderName($shape, $shader_type);
          
          if ($shader_type == "surface" && $maya_shader == "")
          {
            $maya_shader = getTranslatedMayaShaderName($shape, "miMaterial");
          }
          
          if ($maya_shader != "")
          {
            $maya_shaders_to_archive[size($maya_shaders_to_archive)] =
              ($maya_shader + " " + $shader_type);
          }
        }
      }
      else
      {
        $shaders_to_archive[size($shaders_to_archive)] = 
          ($shader + " " + $shader_type);
      }
    }
  }

  $shaders_to_archive = DL_stringArrayRemoveDuplicates($shaders_to_archive);
  $maya_shaders_to_archive =
                    DL_stringArrayRemoveDuplicates($maya_shaders_to_archive);


  string $curr_frame = `delightRenderState -qf`;
  
  int $num_shaders_to_archive = size($shaders_to_archive);
  $num_shaders_to_archive += size($maya_shaders_to_archive);
  beginProgressRange( 33, $num_shaders_to_archive );
  
  if (size($shaders_to_archive) != 0 || size($maya_shaders_to_archive) != 0)
  {
    outputRIBcomment("");
    outputRIBcomment("Start of geometry shader archives.");
    outputRIBcomment("{");
  }

  for ($shader_and_shader_type in $shaders_to_archive)
  {
    string $tokens[];
    tokenize $shader_and_shader_type $tokens;

    string $shader = $tokens[0];
    string $shader_type = $tokens[1];

    RiArchiveBegin -n ($shader + " " + $shader_type);

      DSN_outputGeometryShader($shader, $shader_type);

    RiArchiveEnd;

    incProgress( 1, 0 );
  }

  for ($shader_and_shader_type in $maya_shaders_to_archive)
  {
    string $tokens[];

    tokenize $shader_and_shader_type $tokens;

    string $shader = $tokens[0];
    string $shader_type = $tokens[1];

    RiArchiveBegin -n ($shader + " " + $shader_type);

      outputTranslatedMayaShader($shader, $shader_type, "");

    RiArchiveEnd;

    incProgress( 1, 0 );
  }

  if ($num_shaders_to_archive != 0)
  {
    outputTimingComment("Geometry shader archives output in ", $start_time);

    outputRIBcomment("}");
    outputRIBcomment("End of geometry shader archives.");
    outputRIBcomment("\n");
  }
}

proc
DRP_outputGeometryArchives(string $render_pass)
{
  float $start_time = `timerX`;
  outputRIBcomment("");
  outputRIBcomment("Start of geometry archives.");
  outputRIBcomment("{");

  string  $geos_to_archive[];
  string  $active_cache_commands[];
  int     $curr_handle;

  $active_cache_commands = getActiveCacheCommands();

  string $curr_frame = `delightRenderState -qf`;
  
  int $num_cache_cmds = size($active_cache_commands);
  beginProgressRange( 34, $num_cache_cmds );

  for ($curr_cache_command in $active_cache_commands)
  {
    // We'll output instancers separately
    if ($curr_cache_command != "delightCacheInstancer")
    {
      $geos_to_archive = eval($curr_cache_command + " -list");

      for ($curr_geo in $geos_to_archive)
      {
        if( !canUseObjectInstance( $curr_geo, `nodeType $curr_geo` ) )
        {
          RiArchiveBegin -n $curr_geo;

            outputRIBcomment($curr_geo);

            eval($curr_cache_command + " -emit " + $curr_geo);
            eval($curr_cache_command + " -remove " + $curr_geo);

          RiArchiveEnd;
        }
        else
        {
          RiObjectBegin -name $curr_geo;

            outputRIBcomment($curr_geo);

            eval($curr_cache_command + " -emit " + $curr_geo);
            eval($curr_cache_command + " -remove " + $curr_geo);

          RiObjectEnd;
        }
      }
    }

    incProgress( 1, 0 );
  }

  DRP_outputInstancerArchives($render_pass);

  outputTimingComment("Geometry archives output in ", $start_time);

  outputRIBcomment("}");
  outputRIBcomment("End of geometry archives.");
  outputRIBcomment("\n");
}

proc
output_boundingBox(float $bbox[])
{
  if (size($bbox) == 6)
  {
    string $comment;
    $comment = "Bounds ";

    // Output the bounding box as a RtBound
    $comment += ($bbox[0] + " " + $bbox[3] + " ");
    $comment += ($bbox[1] + " " + $bbox[4] + " ");
    $comment += ($bbox[2] + " " + $bbox[5]);

    outputRIBcomment($comment);
  }
}
  
    
// ----------------------------------------------------------------------------
// High level procedures which perform a render
//
global proc int
DRP_cacheScene(string $render_camera,
               string $visible_lights[],
               string $clipping_planes[],
               string $coordinate_systems[],
               string $first_instances[],
               string $secondary_instances[],
               string $noninstanced_geometry[],
               string $shader_collection,
               float $curr_frame,
               int $global_do_camera_blur,
               float $camera_blur_sample_offsets[],
               int $global_do_xform_blur,
               float $xform_sample_offsets[],
               int $global_do_deform_blur,
               float $deform_sample_offsets[])
{
  string  $geos_to_cache[];
  string  $xforms_to_cache[];

  float   $shutter_open_offset;
  float   $curr_time;
  int     $is_cancelled;

  $is_cancelled = 0;

  setProgressMessage( "Frame " + $curr_frame + ": caching geometry: ", 1 );
  
  // first build a list of all those shapes whose geometry we will be caching
  $geos_to_cache = stringArrayCatenate($first_instances,
                                       $noninstanced_geometry);

  // we need to make sure that for each of the secondary instances the
  // corresponding first instance has its geometry cached otherwise the
  // geometry will never get cached (since we only cache the first instance).
  // It is possible for this situation to occur if the objects_to_render set
  // only contains secondary instances
  for ($curr_geo in $secondary_instances)
  {
    $geos_to_cache[size($geos_to_cache)] = getFirstInstance($curr_geo);
  }


  // next build a list of all those shapes whose xforms we will be caching
  $xforms_to_cache = stringArrayCatenate($first_instances,
                                         $secondary_instances);
  $xforms_to_cache = stringArrayCatenate($xforms_to_cache,
                                         $noninstanced_geometry);


  // and now just make sure we don't have any duplicates after all that
  // processing
  $geos_to_cache = DL_stringArrayRemoveDuplicates($geos_to_cache);
  $xforms_to_cache = DL_stringArrayRemoveDuplicates($xforms_to_cache);

  // don't bother caching any geometry that is not output as specified in its
  // attribs node.  We have to be careful here since if the geometry in
  // question is the first instance of some other instanced geometry we must
  // still cache it
  string $geos_to_ignore[];

  for($curr_geo in $geos_to_cache)
  {
    string $curr_attribs_nodes[];
    string $curr_attribs_node;

    if (!isInstanced($curr_geo))
    {
      $curr_attribs_nodes = 
        DL_getAllGeoAttribsNodesFromShape($curr_geo, $shader_collection);

      $curr_attribs_node = DL_highestNodeWithAttrib("outputGeometry",
                                                    $curr_attribs_nodes);

      // not instanced.. we can ignore this geo without worrying it will be
      // needed by someone else
      if (!DGA_outputGeometry($curr_geo, $curr_attribs_node))
      {
        $geos_to_ignore[size($geos_to_ignore)] = $curr_geo;
      }
    }
    // TODO: this is a bit tricky.. we have to check the our list of secondary
    // instances to see if this is the first instance of any of those.  If so
    // then we cache the first instance. Otherwise we can safely ignore it.
  }

  $geos_to_cache = stringArrayRemove($geos_to_ignore, $geos_to_cache);

  string $all_cameras[] = `ls -type camera`;

  // Merge all time samples together so we move the time forward only once.
  // Note that we attempt to only move the time if there really is motion blur.
  float $all_time_samples[] = {};

  if ($global_do_camera_blur)
  {
    for( $i = 1; $i < size($camera_blur_sample_offsets); ++$i )
    {
      $all_time_samples[size($all_time_samples)] =
        $camera_blur_sample_offsets[$i];
    }
  }

  for( $i = 1; $i < size($xform_sample_offsets); ++$i )
  {
    $all_time_samples[size($all_time_samples)] = $xform_sample_offsets[$i];
  }

  for( $i = 1; $i < size($deform_sample_offsets); ++$i )
  {
    $all_time_samples[size($all_time_samples)] = $deform_sample_offsets[$i];
  }

  $all_time_samples = sort( $all_time_samples );

  // Figure out the maximum number of elements to cache
  int $num_obj_to_cache;
  
  $num_obj_to_cache = size($all_cameras) - $global_do_camera_blur +
                      size($visible_lights) * size($xform_sample_offsets) +
                      size($clipping_planes) +
                      size($coordinate_systems) +
                      $global_do_camera_blur * size($camera_blur_sample_offsets) +
                      size($xforms_to_cache) * size($xform_sample_offsets) +
                      size($geos_to_cache) * size($deform_sample_offsets);

  beginProgressRange( 100, $num_obj_to_cache );
  
  $shutter_open_offset = `delightRenderState -qso`;

  $curr_time = $curr_frame + $shutter_open_offset;

  if( `currentTime -q` != $curr_time )
  {
    currentTime $curr_time;
  }

  delightCacheXform -a -sampleTime $curr_time $render_camera;

  // Cache all the other cameras too so we can output named coord sys
  for( $camera in $all_cameras )
  {
    if( $camera != $render_camera )
    {
      delightCacheXform -a -sampleTime $curr_time $camera;
    }

    incProgress( 1, 1 );
  }

  // first we cache pretty much everything at shutter open
  for ($curr_light in $visible_lights)
  {
    // TODO: cache shader
    delightCacheXform -a -sampleTime $curr_time $curr_light;
    incProgress( 1, 1 );
  }

  for ($curr_plane in $clipping_planes)
  {
    delightCacheXform -a -sampleTime $curr_time $curr_plane;
    incProgress( 1, 1 );
  }

  for ($curr_system in $coordinate_systems)
  {
    delightCacheXform -a -sampleTime $curr_time $curr_system;
    incProgress( 1, 1 );
  }

  for ($curr_geo in $geos_to_cache)
  {
    if (!isCancelled())
    {
      $geo_cache_command =   getGeoCacheCommand($curr_geo)
                           + " -a -sampleTime "
                           + $curr_time
                           + " "
                           + $curr_geo;

      if (catch(`eval($geo_cache_command)`))
      {
        warning(  "Could not cache geometry:" 
                + $curr_geo 
                + ". It will not be rendered.\n");
      }
    }
    else
    {
      $is_cancelled = 1;
      break;
    }

    incProgress( 1, 1 );
  }

  for ($curr_xform in $xforms_to_cache)
  {
    // TODO: cache shader
    // TODO: cache attribs

    if (!isCancelled())
    {
      delightCacheXform -a -sampleTime $curr_time $curr_xform;
    }
    else
    {
      $is_cancelled = 1;
      break;
    }

    incProgress( 1, 1 );
  }

  // then we cache certain geometries at the remaining motion samples
  float $actual_time = $curr_time;
  int $cs_camera = 0;
  int $cs_xform = 0;
  int $cs_deform = 0;

  for( $sample_offset in $all_time_samples )
  {
    if( $is_cancelled )
      break;

    float $new_time = $curr_frame + $sample_offset;
  
    if( $new_time - $curr_time < 1e-14)
    {
      continue;
    }

    $curr_time = $new_time;

    if( $global_do_camera_blur &&
        $cs_camera + 1 < size($camera_blur_sample_offsets) &&
        $camera_blur_sample_offsets[$cs_camera + 1] - $sample_offset < 1e-14 )
    {
      $cs_camera++;

      if( $actual_time != $curr_time )
      {
        currentTime $curr_time;
        $actual_time = $curr_time;
      }

      delightCacheXform -a -sampleTime $curr_time $render_camera;

      incProgress( 1, 1 );
    }
        
    if( $cs_xform + 1 < size($xform_sample_offsets) &&
        $xform_sample_offsets[$cs_xform + 1] - $sample_offset < 1e-14)
    {
      $cs_xform++;

      for( $curr_xform in $xforms_to_cache )
      {
        if( isCancelled() )
        {
          $is_cancelled = 1;
          break;
        }

        $curr_attribs_nodes = 
          DL_getAllGeoAttribsNodesFromShape($curr_xform, $shader_collection);

        $curr_attribs_node = DL_highestNodeWithAttrib("transformationBlur",
                                                      $curr_attribs_nodes);

        int $do_cache = 0;

        if ($curr_attribs_node != "")
        {
          $do_cache = DGA_isXformBlurring($curr_attribs_node,
                                          $global_do_xform_blur);
        }
        else if (   $global_do_xform_blur
                 && objExists($curr_xform + ".motionBlur") )
        {
          $do_cache = getAttr($curr_xform + ".motionBlur");
        }
        else if ($global_do_xform_blur)
        {
          $do_cache = 1;
        }
        
        if( $do_cache )
        {
          if( $actual_time != $curr_time )
          {
            currentTime $curr_time;
            $actual_time = $curr_time;
          }

          delightCacheXform -a -sampleTime $curr_time $curr_xform;
        }

        incProgress( 1, 1 );
      }

      for ($curr_light in $visible_lights)
      {
        if( isCancelled() )
        {
          $is_cancelled = 1;
          break;
        }

        $curr_attribs_nodes = 
          DL_getAllLightAttribsNodesFromShape($curr_light, $shader_collection);

        $curr_attribs_node = DL_highestNodeWithAttrib("transformationBlur",
                                                      $curr_attribs_nodes);

        int $do_cache = 0;

        if ($curr_attribs_node != "")
        {
          $do_cache = DLA_isXformBlurring($curr_attribs_node,
                                          $global_do_xform_blur);
        }

        if ($do_cache)
        {
          if( $actual_time != $curr_time )
          {
            currentTime $curr_time;
            $actual_time = $curr_time;
          }

          delightCacheXform -a -sampleTime $curr_time $curr_light;
        }

        incProgress( 1, 1 );
      }
    }
    
    if( $cs_deform + 1 < size($deform_sample_offsets) &&
        $deform_sample_offsets[$cs_deform + 1] - $sample_offset < 1e-14)
    {
      $cs_deform++;

      // TODO: check that the geometry is cacheable (eg that it's not being
      // replaced by an archive)

      for( $curr_geo in $geos_to_cache )
      {
        if( isCancelled() )
        {
          $is_cancelled = 1;
          break;
        }

        $curr_attribs_nodes = 
          DL_getAllGeoAttribsNodesFromShape($curr_geo, $shader_collection);

        $curr_attribs_node = DL_highestNodeWithAttrib("deformationBlur",
                                                      $curr_attribs_nodes);

        int $do_cache = 0;

        if ($curr_attribs_node != "")
        {
          $do_cache = DGA_isDeformBlurring($curr_attribs_node,
                                           $global_do_deform_blur);
        }
        else if (   $global_do_deform_blur
                 && objExists($curr_geo + ".motionBlur") )
        {
          $do_cache = getAttr($curr_geo + ".motionBlur");
        }
        else if ($global_do_deform_blur)
        {
          $do_cache = 1;
        }

        if( $do_cache )
        {
          if( $actual_time != $curr_time )
          {
            currentTime $curr_time;
            $actual_time = $curr_time;
          }

          $geo_cache_command =   getGeoCacheCommand($curr_geo)
                               + " -a -sampleTime "
                               + $curr_time
                               + " "
                               + $curr_geo;

          if (catch(`eval($geo_cache_command)`))
          {
            warning(  "Could not cache geometry:" 
                    + $curr_geo 
                    + ". It will not be rendered.\n");
          }
        }

        incProgress( 1, 1 );
      }
    }
  }

  $curr_time = $curr_frame + $shutter_open_offset;

  if( $actual_time != $curr_time )
  {
    currentTime $curr_time;
  }

  return !$is_cancelled;
}

proc string
beginRIB(string $render_pass,
         int $curr_frame,
         string $prev_ribfile)
{
  string $rib_file;
  
  if( DRP_isImmediateRenderMode($render_pass) )
  {
    RiBegin;
  }
  else
  {
    int     $binary_rib;
    int     $compressed_rib;

    $rib_file = DL_getExpandedFilename(
      getAttr($render_pass + ".ribFilename"), 
      "",
      $render_pass,
      "rib");
    
    $binary_rib = getAttr($render_pass + ".binaryRib");

    $compressed_rib = getAttr($render_pass + ".compressedRib");

    if ($compressed_rib)
    {
      // the compression option needs to be before the RiBegin
      RiOption -id false
               -n "rib"
               -p "compression" "string" "gzip";
    }

    string $prefix;
    if ($rib_file == $prev_ribfile)
    {
      $prefix = ">>";
    }

    RiBegin -of ($prefix + $rib_file);
    print( "Writing RIB to \"" + $prefix + $rib_file + "\"\n" );

    if ($binary_rib)
    {
      // the format option needs to be after the RiBegin
      RiOption -id false
               -n "rib"
               -p "format" "string" "binary";
    }
  }
  
  return $rib_file;
}

proc int
checkRibFileName(string $rib_file, string $render_pass)
{
  int     $valid;
  string  $expanded_rib_file;

  $expanded_rib_file = DL_getExpandedFilename($rib_file, "", $render_pass, "rib");

  if ($rib_file != "")
  {
    // first check that the directory exists and is writable
    // then check that the specified file either isn't there or is writable
    // and is not, in fact, a directory
    string $directory_name;

    $directory_name = dirname($expanded_rib_file);

    if ($directory_name == "")
    {
      $directory_name = ".";
      warning(
        "no path specified in RIB file in " 
        + $render_pass 
        + ". Writing RIB to current directory ("
        + `pwd`
        + ").");
    }

    if (`filetest -d $directory_name`) 
    {
      // directory exists

      if (`filetest -w $directory_name`)
      {
        // directory is writable

        if (`filetest -f $expanded_rib_file`)
        {
          // file exists

          if (`filetest -w $expanded_rib_file`)
          {
            // file is writable
            $valid = 1;
          }
          else
          {
            error(  "RIB file name: " + $rib_file + ", specified in "
                  + $render_pass
                  + ", isn't writable");
            $valid = 0;
          }
        }
        else
        {
          if (!`filetest -d $expanded_rib_file`)
          {
            // file isn't a directory

            $valid = 1;
          }
          else
          {
            error("no file specified for RIB file name in " + $render_pass);
            $valid = 0;
          }
        }
      }
      else
      {
        error(  "directory specified in RIB file name in "
              + $render_pass
              + " isn't writable");
        $valid = 0;
      }
    }
    else
    {
      // directory doesn't exist

      int $dir_created;
      
      $dir_created = `sysFile -makeDir $directory_name`;

      if ($dir_created)
      {
        warning(  "directory specified in RIB file name in "
                + $render_pass
                + " ("
                + $directory_name
                + ") doesn't exist. Created it.");

        $valid = 1;
      }
      else
      {
        error(  "directory specified in RIB file name in "
              + $render_pass
              + " ("
              + $directory_name
              + ") doesn't exist. Attempt to create it failed.");

        $valid = 0;
      }
    }
  }
  else
  {
    error("empty RIB file name in " + $render_pass);
    $valid = 0;
  }

  return $valid;
}

global proc int
DRP_isValid(string $render_pass)
{
  //
  // Description:
  //  This procedure is called from DL_render.mel to verify that the specified 
  //  render pass is valid before attempting to render the scene using the 
  //  render pass.
  //
  // Returns:
  //  True if the render pass is valid, false if not. 
  //  However, it is important to note that if the render pass is not valid,
  //  most likely this procedure will issue an error, halting execution of the
  //  script, making the return value irrelevant.
  //

  int $is_valid = true;
  // TODO: check that frame range is startframe <= endframe

  // Check that a delightRenderPass node by the specified name exists.
  //
  if (size(`ls -type delightRenderPass $render_pass`) == 0)
  {
    error("No 3Delight render pass called \"" + $render_pass + "\" exists.");
    // TODO: There is no point in setting the return value after a call to
    // error(). The call to error() will bail out of this procedure.
    //
    $is_valid = false;
  }

  string $render_camera;

  $render_camera = DRP_getRenderCamera($render_pass);

  if ($render_camera == "")
  {
    error("must specify a camera for " + $render_pass);
    $is_valid = false;
  }

  float $crop_min_x;
  float $crop_max_x;
  float $crop_min_y;
  float $crop_max_y;

  $crop_min_x = getAttr($render_pass + ".cropMinX");
  $crop_max_x = getAttr($render_pass + ".cropMaxX");
  $crop_min_y = getAttr($render_pass + ".cropMinY");
  $crop_max_y = getAttr($render_pass + ".cropMaxY");

  if ($crop_min_x >= $crop_max_x)
  {
    error("min X crop is larger than max X crop in " + $render_pass);
    $is_valid = false;
  }

  if ($crop_min_y >= $crop_max_y)
  {
    error("min Y crop is larger than max Y crop in " + $render_pass);
    $is_valid = false;
  }

  string $rib_file;

  $rib_file = getAttr($render_pass + ".ribFilename");

  if( DRP_isRIBRenderMode($render_pass)  )
  {
    $is_valid = checkRibFileName($rib_file, $render_pass);
  }

  string $layer_to_render;

  $layer_to_render = DRP_getLayerToRender($render_pass);

  if ($layer_to_render == "")
  {
    error("must specify a render layer for " + $render_pass);
    $is_valid = false;
  }

  if (DRP_isBackgroundRenderMode($render_pass))
  {
    int $maya_render_view_found = 0;
    if (   DRP_getRenderPrimaryDisplay($render_pass) 
        && DRP_getDisplayDriver($render_pass) == "maya_render_view")
    {
      $maya_render_view_found = 1;
    }

    if (   !$maya_render_view_found 
        && DRP_getRenderSecondaryDisplays($render_pass))
    {
      int $display_indices[] = DRP_getSecondaryDisplayIndices($render_pass);
      for($i in $display_indices)
      {
        if (DRP_getSecondaryDisplayDriver($render_pass, $i) == 
            "maya_render_view")
        {
          $maya_render_view_found = 1;
          break;
        }
      }
    }
    
    if ($maya_render_view_found)
    {
      error("can't render to Maya render view in background; " +
            "please select another display driver.");
      $is_valid = 0;
    }
  }
    
  return $is_valid;
}

proc string
getBuildOptForDisplayMode(string $mode)
{
	string $opts = "";
	string $outvars[];
	tokenize $mode "," $outvars;

	for( $outvar in $outvars )
	{
		string $tokens[];
		tokenize $outvar " " $tokens;

		if( size($tokens) == 0 )
			continue;

		string $var_name = $tokens[size($tokens) - 1];

		$opts += " -DUSE_AOV_" + $var_name;
	}
	
	return $opts;
}

proc string
buildShaderdlAOVOpts( string $render_pass, string $all_renderable_geometry[] )
{
  string $opts;
  int $add_use_bgd_aov = 0;
  int $define_all_aovs = 0;
  
  int $translated_shaders_aovs = getAttr($render_pass + ".translatedShadersAOVs");

  if (   (   $translated_shaders_aovs == 0
          && DRP_isRIBArchivingMode( $render_pass ))
      || $translated_shaders_aovs == 2)
  {
    // Turn on all AOVs defines
    //
    $add_use_bgd_aov = 1;
    string $all_aovs[] = DRP_getAllDisplayAOVDeclarations();
    for( $curr_aov in $all_aovs )
    {
      if( $curr_aov != "" )
      {
        $opts += getBuildOptForDisplayMode( $curr_aov );
      }
    }
  }
  else
  {
    // This might add a define for the useBackground node even if it is not used
    // but figuring out if each useBackground is part of the effective hypershade
    // shading network of a renderable object is not easy as we need to traverse
    // conenctions and take render layers override into account. Since the
    // "hyperShade" command does not work in batch mode, go for the failsafe
    // approach.
    //
    $add_use_bgd_aov = size(`ls -type "useBackground"`);
    
    if (DRP_getRenderSecondaryDisplays( $render_pass ))
    {
      int $display_indices[] = DRP_getSecondaryDisplayIndices( $render_pass );

      for( $i in $display_indices )
      {
        string $mode = DRP_getSecondaryDisplayMode( $render_pass, $i );
        $opts += getBuildOptForDisplayMode($mode);
      }
    }
  }

  if ($add_use_bgd_aov != 0)
  {
    $opts += " -DUSE_SHADER_usebackground";
  }
  
  return $opts;
}

global proc
DRP_buildShaders(string $render_pass)
{
  // Update some global vars.
  DL_updateGeoTypeData();

  float $build_shaders_start_time = `timerX`;

  beginProgress("Building Shaders ", 100);  

  string $all_renderable_geometry[];
  string $particle_instancers[];
  string $renderable_instancer_geo[];
  string $layer_to_render;
  string $object_set_to_render;
  string $shader_collection;
  string $shaders_path;
  string $sl_output_path;
  string $sdl_output_path;
  string $shaderdl_opts;
  string $built_shaders;

  $shaders_path = DL_getExpandedAbsoluteOutputPath(
    DL_getShadersPath(), 
    "", 
    $render_pass);
    
  $sl_output_path = DL_createDir($shaders_path + "/src");
  $sdl_output_path = DL_createDir($shaders_path + "/OBJ");

  $layer_to_render = DRP_getLayerToRender($render_pass);
  string $render_layer_shapes[] = getShapesInLayer($layer_to_render);

  $object_set_to_render = DRP_getObjectsToRenderSet($render_pass);
  $shader_collection = DRP_getShaderCollection($render_pass);

  $all_renderable_geometry = 
    getAllRenderableVisibleGeometry($object_set_to_render, 
                                    $render_layer_shapes);

  $shaderdl_opts = buildShaderdlAOVOpts( $render_pass, $all_renderable_geometry );

  DL_translateMayaToSLClean( $sdl_output_path, $shaderdl_opts );

  // Store currently displayed render layer and select the one we want to render
  string $current_layer = `editRenderLayerGlobals -q -currentRenderLayer`;
  editRenderLayerGlobals -currentRenderLayer $layer_to_render;

  int $write_to_disk = DRP_getTranslateMayaShaders($render_pass);

  // Don't compile geometry shaders if they're not needed.
  int $compile_geo_shaders = 1;

  if(   DRP_isRIBArchivingMode($render_pass) 
     && getAttr($render_pass + ".archiveGeometryShaders") == 0)
  {
    $compile_geo_shaders = 0;
  }

  if ($compile_geo_shaders && size($all_renderable_geometry) > 0)
  {
    string $archived_instancers_placeholder[];

    $particle_instancers = getVisibleInstancers($object_set_to_render, 
                                                $layer_to_render, 
                                                $archived_instancers_placeholder, 
                                                $renderable_instancer_geo,
                                                $render_layer_shapes);

    $all_renderable_geometry = 
      stringArrayCatenate($all_renderable_geometry, $renderable_instancer_geo);

    $all_renderable_geometry = 
      DL_stringArrayRemoveDuplicates($all_renderable_geometry);

    beginProgressRange( 100, size($all_renderable_geometry) );

    for ($curr_geo in $all_renderable_geometry)
    {
      if (isCancelled())
      {
        break;
      }

      incProgress( 1, 0 );

      string $surface_shader_node;
      string $displacement_shader_node;

      $surface_shader_node = DL_getHighestAttribsNodeFromShape(
        $curr_geo, 
        "surface", 
        $shader_collection);
      $displacement_shader_node = DL_getHighestAttribsNodeFromShape(
        $curr_geo, 
        "displacement", 
        $shader_collection);
      
      if ($surface_shader_node == "" || $displacement_shader_node == "")
      {
        string $shading_groups[] = getShadingGroups( $curr_geo );

        if ($surface_shader_node == "")
        {
          string $type = "surface";
          string $shader = shadingGroupsShaderName( $shading_groups, $type );
          
          if ($shader == "")
          {
            $type = "miMaterial";
            $shader = shadingGroupsShaderName( $shading_groups, $type );
          }

          if( $shader != "" &&
              `match (" " + $shader + " ") $built_shaders` == "" )
          {
            $built_shaders += (" " + $shader + " ");

            catch(buildShader($shader,
                              $shading_groups, 
                              $type, 
                              $shaderdl_opts, 
                              $sl_output_path, 
                              $sdl_output_path,
                              $write_to_disk));       
          }
        }

        if ($displacement_shader_node == "")
        {
          string $type = "displacement";
          $shader = shadingGroupsShaderName( $shading_groups, $type );

          if( $shader != "" &&
              `match (" " + $shader + " ") $built_shaders` == "" )
          {
            $built_shaders += (" " + $shader + " ");

            catch(buildShader($shader,
                              $shading_groups, 
                              $type, 
                              $shaderdl_opts, 
                              $sl_output_path, 
                              $sdl_output_path,
                              $write_to_disk));       
          }
        }
      }
    }
  }
  
  int $compile_light_shaders = 1;
  
  if(   DRP_isRIBArchivingMode($render_pass) 
     && getAttr($render_pass + ".archiveLighting") == 0)
  {
    $compile_light_shaders = 0;
  }
  
  if ($compile_light_shaders)
  {
    string $visible_lights[] = getVisibleLights(
      DRP_getLightsToRenderSet($render_pass),
      $render_layer_shapes);

    $visible_lights = DL_stringArrayIntersect(
      $visible_lights, 
      $render_layer_shapes);

    // Use short names if possible.
    $visible_lights = `ls $visible_lights`;

    for ($curr_light in $visible_lights)
    {
      if (isCancelled())
      {
        break;
      }

      string $light_shader_node =
        DL_getShaderFromShape($curr_light, "light", $shader_collection);

      if( $light_shader_node == "" )
      {
        $shader = materialShaderName( $curr_light );

        if( `match (" " + $shader + " ") $built_shaders` == "" )
        {
          $built_shaders += (" " + $shader + " ");
          string $shading_groups[] = { $curr_light };

          catch(buildShader($shader,
                            $shading_groups, 
                            "light", 
                            $shaderdl_opts, 
                            $sl_output_path, 
                            $sdl_output_path,
                            $write_to_disk));       
        }
      }
    }
  }

  editRenderLayerGlobals -currentRenderLayer $current_layer;

  endProgress();

  global string $g_no_timing_comments;
  if( $g_no_timing_comments == "" )
  {
    string $comment = (
      "Hypershade shaders built in " 
      + `timerX -startTime $build_shaders_start_time`
      + "s");
    print($comment + "\n");
  }
}
 
proc int
DRP_writeArchiveForFrame(string $archive_node,
                         int $frame)
{
  int $ret_val;
  $ret_val = 0;
  
  string $connected_render_pass;
  $connected_render_pass = 
    getConnectedNode($archive_node + ".connectedRenderPass");
  
  if ($connected_render_pass != "" && DRP_isValid($connected_render_pass))
  {
    string $rib_filename;
    $rib_filename = DL_getExpandedFilename(
      getAttr($archive_node + ".ribFilename"), 
      "",
      $connected_render_pass,
      "rib");

    if (   `filetest -f $rib_filename` == 0
        || getAttr($connected_render_pass + ".archiveWriteMode") == 1)
    {
      int $prev_do_anim;
      int $prev_start_frame;
      int $prev_end_frame;
      int $prev_generate_rib_archives;
      
      $prev_do_anim = DRP_getAnimation($connected_render_pass);
      $prev_start_frame = DRP_getStartFrame($connected_render_pass);
      $prev_end_frame = DRP_getEndFrame($connected_render_pass);
      $prev_generate_rib_archives = 
        getAttr($connected_render_pass + ".generateRIBArchives");
        
      setAttr($connected_render_pass + ".animation") 1;
      setAttr($connected_render_pass + ".startFrame") $frame;
      setAttr($connected_render_pass + ".endFrame") $frame;
      setAttr($connected_render_pass + ".generateRIBArchives") 0;

      // This is not very nice with the progress dialog
      DRP_render($connected_render_pass);
      
      setAttr($connected_render_pass + ".animation") $prev_do_anim;
      setAttr($connected_render_pass + ".startFrame") $prev_start_frame;
      setAttr($connected_render_pass + ".endFrame") $prev_end_frame;
      setAttr($connected_render_pass + ".generateRIBArchives") 
        $prev_generate_rib_archives;
    
      $ret_val = 1;
    }
  }
  
  return $ret_val;
}

proc
startBackgroundRender(string $render_pass)
{
  string $rib_file = getAttr($render_pass + ".ribFilename");
  $rib_file = DL_getExpandedFilename($rib_file, "", $render_pass, "rib");

  string $log_file = getAttr($render_pass + ".renderLogFilename");
  $log_file = DL_getExpandedFilename($log_file, "", $render_pass, "log");

  string $cmd_prefix = "";
  string $cmd_suffix = " 2>&1 &";

  string $os = `about -os`;
  if ($os == "nt" || $os == "win64")
  {
    $cmd_prefix = "shell ";
    $log_file = DL_substituteAllString($log_file, "/", "\\");
  }

  string $extra_params = getAttr($render_pass + ".backgroundRenderParams");
  $extra_params = DL_substituteAllString($extra_params, "\r", " ");

  string $cmd = $cmd_prefix + "renderdl " + $extra_params;
  $cmd += " \"" + $rib_file + "\" > \"";
  $cmd += $log_file + "\"" + $cmd_suffix;

  system($cmd);

  print("Render process started; output logged into " + $log_file + "\n");
}

global proc
DRP_render(string $render_pass)
{
  global float $g_illuminateStatementsTime;

  $g_illuminateStatementsTime = 0;

  float $RIB_output_start_time = `timerX`;

  // Update some global vars.
  DL_updateGeoTypeData();

  // first collect some of the constants for the frame
  string  $render_camera;
  string  $shader_collection;
  string  $layerToRender;
  string  $lights_to_render_set;
  string  $objects_to_render_set;
  string  $area_light_plane;
  int     $do_animation;
  float   $start_frame;
  float   $end_frame;
  float   $increment;

  int     $global_do_camera_blur;
  int     $global_do_deform_blur;
  int     $global_do_xform_blur;
  float   $shutter_angle;

  int     $num_camera_blur_samples;
  int     $num_xform_samples;
  int     $num_deform_samples;

  // offsets from the current frame
  float   $camera_blur_sample_offsets[];  
  float   $xform_sample_offsets[];  
  float   $deform_sample_offsets[];

  global int  $gInRiBeginEnd;

  $render_camera = DRP_getRenderCamera($render_pass);

  $do_animation = DRP_getAnimation($render_pass); 

  if ($do_animation)
  {
    $start_frame = DRP_getStartFrame($render_pass);
    $end_frame = DRP_getEndFrame($render_pass);
    $increment = DRP_getIncrement($render_pass);
  }
  else
  {
    $start_frame = getAttr("time1.outTime");
    $end_frame = $start_frame;
    $increment = 1.0;
  }

  $global_do_camera_blur = DRP_getCameraBlur($render_pass);
  $global_do_deform_blur = DRP_getDeformationBlur($render_pass);
  $global_do_xform_blur = DRP_getTransformationBlur($render_pass);

  $shutter_angle = getAttr($render_camera + ".shutterAngle");

  $num_camera_blur_samples = DRP_getNumCameraBlurSamples($render_pass);
  $num_xform_samples = DRP_getNumTransformBlurSamples($render_pass);
  $num_deform_samples = DRP_getNumDeformBlurSamples($render_pass);

  $camera_blur_sample_offsets = DRP_getSampleOffsets(
    $render_pass, $shutter_angle, $num_camera_blur_samples );

  $xform_sample_offsets = DRP_getSampleOffsets(
    $render_pass, $shutter_angle, $num_xform_samples );

  $deform_sample_offsets = DRP_getSampleOffsets(
    $render_pass, $shutter_angle, $num_deform_samples );


  $shader_collection = DRP_getShaderCollection($render_pass);
  $lights_to_render_set = DRP_getLightsToRenderSet($render_pass);
  $objects_to_render_set = DRP_getObjectsToRenderSet($render_pass);
  $clipping_planes_to_render_set = DRP_getClippingPlanesToRenderSet($render_pass);
  $layer_to_render = DRP_getLayerToRender($render_pass);
  $area_light_plane = createAreaLightPlane();
  
  string  $visible_lights[];
  string  $shadow_mapped_lights[];
  string  $clipping_planes[];
  string  $coordinate_systems[];
  string  $visible_geometry[];
  string  $particle_instancers[];
  string  $renderable_instancer_geo[];
  string  $all_renderable_geometry[];
  string  $objects_to_cache[];
  string  $first_instances[];
  string  $secondary_instances[];
  string  $noninstanced_geometry[];
  string  $xforms[];
  int     $progress_max;

  // Each frame can have 400 progress steps
  // (100 each for caching, archive output, shadow map rendering and displays rendering)
  $progress_max = 400 * ceil(($end_frame - $start_frame + 1) /
    float($increment));

  beginProgress("Rendering Scene", $progress_max);

  int $is_cancelled;

  $is_cancelled = 0;

  // Store currently displayed render layer and select the one we want to render
  int $current_layer_ID;
  $current_layer_ID = getAttr("renderLayerManager.currentRenderLayer");
  
  string $all_layers[];
  $all_layers = listConnections("renderLayerManager.renderLayerId");
  
  // Store currently displayed render layer and select the one we want to render
  string $current_layer;
  $current_layer = `editRenderLayerGlobals -q -currentRenderLayer`;
  
  editRenderLayerGlobals -currentRenderLayer $layer_to_render;
  
  string $render_layer_shapes[] = getShapesInLayer($layer_to_render);
  
  int $is_rib_archiving_mode;
  int $output_geo_shaders;
  int $output_transforms;
  int $output_light_sources;
  int $ignore_archived_objects;
  int $generate_RIB_archive_nodes;
  
  $is_rib_archiving_mode = DRP_isRIBArchivingMode($render_pass);
  $output_geo_shaders = 1;
  $output_geo_attribs = 1;
  $output_transforms = 1;
  $output_light_sources = 1;
  $ignore_archived_objects = getAttr($render_pass + ".ignoreArchivedObjects");
  $generate_RIB_archives = getAttr($render_pass + ".generateRIBArchives");      
  
  string $connected_DRA_nodes[];
  $connected_DRA_nodes = `listConnections -d true -s false -sh true 
    -t delightRibArchive ($render_pass + ".message")`;
  
  if (size($connected_DRA_nodes) > 0)
  {
    $connected_DRA_nodes = 
      `ls -dag -allPaths -shapes -long -noIntermediate $connected_DRA_nodes`;
  }
  
  $connected_DRA_nodes = DL_stringArrayRemoveDuplicates($connected_DRA_nodes);

  if ($is_rib_archiving_mode)
  {
    $output_geo_shaders = getAttr($render_pass + ".archiveGeometryShaders");
    $output_geo_attribs = getAttr($render_pass + ".archiveGeometryAttributes");
    $output_transforms = getAttr($render_pass + ".archiveTransforms");
    
    if (getAttr($render_pass + ".archiveLighting") != 2)
    {
      $output_light_sources = 0;
    }
  }
  
  string $prev_ribfile;
  
  int $get_visibility_at_shutter_open;
  
  // Sample object visibility at shutter open time if motion blur is on
  if (   $global_do_camera_blur
      || $global_do_xform_blur
      || $global_do_deform_blur)
  {
    $get_visibility_at_shutter_open = 1;
  }
  else
  {
    // No motion blur option is on in the render pass, but this could be
    // overridden in the geo or light attribs node
    $get_visibility_at_shutter_open = 0;

    // TODO: this is not, strictly speaking, correct since we are listing all
    // the geometry here and without reference to collections.. we should at
    // use the attribs on the set of geometry specified in the render
    // sets/render layer... 
    string $all_geo_attribs[];
    $all_geo_attribs = `ls -type delightGeoAttribs`;
    
    for ($curr_attrib in $all_geo_attribs)
    {
      if (   (   `objExists ($curr_attrib + ".transformationBlur")`
              && DGA_getXformBlurState($curr_attrib) == "On")
          || (   `objExists ($curr_attrib + ".deformationBlur")`
              && DGA_getDeformBlurState($curr_attrib) == "On"))
      {
        $get_visibility_at_shutter_open = 1;
        break;
      }
    }

    if (!$get_visibility_at_shutter_open)
    {
      string $all_light_attribs[];
      $all_light_attribs = `ls -type delightLightAttribs`;

      for ($curr_attrib in $all_light_attribs)
      {
        if (   `objExists($curr_attrib + ".transformationBlur")`
            && DLA_getXformBlurState($curr_attrib) == "On")
        {
          $get_visibility_at_shutter_open = 1;
          break;
        }
      }
    }
  }
  
  for ($curr_frame = $start_frame;
       $curr_frame <= $end_frame && !$is_cancelled;
       $curr_frame += $increment)
  {
    delightRenderState -f $curr_frame;

    float $time;
    $time = $curr_frame;
    if ($get_visibility_at_shutter_open)
    {
      $time += $xform_sample_offsets[0];
    }
    
    if (`currentTime -q` != $time)
    {
      currentTime $time;
    }
    
    DRP_executePreFrameMelScript($render_pass);
    
    // Proceed with rendering only if the render pass is not in RIB archiving
    // mode, or if the archive file requires writing.
    //
    int $do_render = 1;
    
    if (   $is_rib_archiving_mode
        && getAttr($render_pass + ".archiveWriteMode") == 0)
    {
      // Archive wrtie mode is "reuse", so if the file already exists we have
      // nothing to do
      //
      string $rib_filename = DL_getExpandedFilename(
        getAttr($render_pass + ".ribFilename"), 
        "",
        $render_pass,
        "rib");
  
      if (`filetest -f $rib_filename` == 1)
        $do_render = 0;
    }
    
    if ($do_render)
    {
      string $all_dra_nodes[];
      
      $all_dra_nodes = `ls -visible -type "delightRibArchive"`;
      if (size($all_dra_nodes) > 0)
      {
        $all_dra_nodes = 
          `ls -dag -allPaths -shapes -long -noIntermediate $all_dra_nodes`;
        $all_dra_nodes = stringArrayRemove($connected_DRA_nodes, $all_dra_nodes);
      }

      for ($curr_node in $all_dra_nodes)
      {
        // Only attempt to read the bounding box in the RIB archive file for
        // archive files that are not going to be written right now.
        if ($generate_RIB_archives != 0)
        {
          if (DRP_writeArchiveForFrame($curr_node, $curr_frame) == 0)
          {
            DRA_readBboxFromFile($curr_node);
          }
        }
        else
        {
          DRA_readBboxFromFile($curr_node);
        }
      }

      $visible_geometry = 
        getAllRenderableVisibleGeometry($objects_to_render_set, 
                                        $render_layer_shapes);
      string $dra_nodes_to_consider[];
      
      if ($ignore_archived_objects != 0)
      {
        // List the RIB archive nodes that are in this pass' render set
        //$dra_nodes_to_consider = `ls -dag -allPaths -long -noIntermediate -type delightRibArchive $visible_geometry`;

        for ($curr_geo in $visible_geometry)
        {
          if (`objectType $curr_geo` == "delightRibArchive")
            $dra_nodes_to_consider[size($dra_nodes_to_consider)] = $curr_geo;
        }

        $dra_nodes_to_consider = 
          stringArrayRemove($connected_DRA_nodes, $dra_nodes_to_consider);

        $visible_geometry = removeArchivedGeometry($dra_nodes_to_consider,
                                                   $visible_geometry);
      }

      $visible_lights = getVisibleLights(
        $lights_to_render_set,
        $render_layer_shapes);
      
      if ($ignore_archived_objects != 0)
      {
        $visible_lights = removeArchivedLights($dra_nodes_to_consider,
                                               $visible_lights);
      }

      $shadow_mapped_lights = 
        DRP_getShadowMappedLights($visible_lights, $shader_collection);

      // If the render mode is immediate and there is nothing to render for this
      // frame, skip to the PostFrame MEL script call.
      if (   !DRP_isImmediateRenderMode($render_pass)
          || (   size($shadow_mapped_lights) != 0
              || DRP_getRenderPrimaryDisplay($render_pass)
              || DRP_getRenderSecondaryDisplays($render_pass)))
      {
        // TODO: we can optimize this if we are only rendering shadowmaps -- the
        // $all_renderable_geometry variable can be filled with the union of the
        // sets of objects casting shadows from our shadowmap lights
        $visible_geometry = 
          stringArrayRemove($connected_DRA_nodes, $visible_geometry); 

        string $archived_instancers[];

        if ($ignore_archived_objects != 0)
        {
          $archived_instancers = getArchivedInstancers(
            $dra_nodes_to_consider,
            $render_layer_shapes);
        }

        $particle_instancers = getVisibleInstancers($objects_to_render_set,
                                                    $layer_to_render,
                                                    $archived_instancers, 
                                                    $renderable_instancer_geo,
                                                    $render_layer_shapes);

        $all_renderable_geometry = 
          stringArrayCatenate($visible_geometry, $renderable_instancer_geo);

        $all_renderable_geometry = DL_stringArrayRemoveDuplicates($all_renderable_geometry);

        $objects_to_cache = stringArrayCatenate($all_renderable_geometry,
                                                $particle_instancers);

        setupInstancedInfoCache($objects_to_cache);

        $first_instances = getAllFirstInstances($objects_to_cache);
        $secondary_instances = getAllSecondaryInstances($objects_to_cache);
        $noninstanced_geometry = getAllNonInstancedShapes($objects_to_cache);

        $xforms = stringArrayCatenate($visible_geometry, $particle_instancers);

        $clipping_planes = getVisibleClippingPlanes($clipping_planes_to_render_set);

        if ($ignore_archived_objects != 0)
        {
          $clipping_planes = 
            removeArchivedClippingPlanes($dra_nodes_to_consider, $clipping_planes);
        }
        
        $coordinate_systems = getVisibleCoordinateSystems("");
        
        if ($ignore_archived_objects != 0)
        {
          $coordinate_systems = 
            removeArchivedCoordinateSystems($dra_nodes_to_consider, 
                                            $coordinate_systems);
        }

        $scene_is_xform_blurring =
          DRP_checkSceneForXformBlur($objects_to_cache,
                                     $visible_lights,
                                     $global_do_xform_blur,
                                     $shader_collection);
        
        $scene_is_deform_blurring =
          DRP_checkSceneForDeformBlur($objects_to_cache,
                                      $global_do_deform_blur,
                                      $shader_collection);

        // we use the xform offsets for shutter open and close.. we could just
        // as easily use the deform offsets.. it doesn't matter
        if (   $global_do_camera_blur
            || $scene_is_xform_blurring
            || $scene_is_deform_blurring)
        {
          delightRenderState -so $xform_sample_offsets[0];
          delightRenderState -sc $xform_sample_offsets[size($xform_sample_offsets)-1];
        }
        else
        {
          // no motion blur at all in the scene.. empty shutter interval
          delightRenderState -so 0;
          delightRenderState -sc 0;
        }

        float $caching_start_time = `timerX`;

        delightCacheInstancer -addAllGeometry $renderable_instancer_geo;

        if (size(`ls -type "areaLight" $visible_lights`) > 0)
        {
          delightCacheGeo -a -sampleTime $time $area_light_plane;
        }

        $is_cancelled = !DRP_cacheScene($render_camera,
                                        $visible_lights,
                                        $clipping_planes,
                                        $coordinate_systems,
                                        $first_instances,
                                        $secondary_instances,
                                        $noninstanced_geometry,
                                        $shader_collection,
                                        $curr_frame,
                                        $global_do_camera_blur,
                                        $camera_blur_sample_offsets,
                                        $global_do_xform_blur,
                                        $xform_sample_offsets,
                                        $global_do_deform_blur,
                                        $deform_sample_offsets);

        if ($is_cancelled)
          break;

        // then get down to the business of outputting a RIB file
        $prev_ribfile = beginRIB($render_pass, $curr_frame, $prev_ribfile);

        $gInRiBeginEnd = 1;

          // need to output the comment here so that we can output it to the RIB
          // (after the RiBegin)
          outputTimingComment("Scene cached for RIB output in ",
                              $caching_start_time);

          if ($is_rib_archiving_mode)
          {
            float $bbox[];
            clear($bbox);
            
            if (size($xforms) > 0)
            {
              $bbox = exactWorldBoundingBox($xforms);
            }
            
            output_boundingBox($bbox);
            
            for ($DRA_node in $connected_DRA_nodes)
            {
              DRA_updateBoundingBox($DRA_node, $bbox);
            }
          }
          else
          {
            // This should go with other RiOptions when 3Delight will not 
            // require to know about the offset before all motion blocks
            //
            outputShutterOffset();
          }
          
          setProgressMessage(
            "Frame " + $curr_frame + ": outputting archives: ", 0 );

          if ($output_geo_shaders)
          {
            DRP_outputGeometryShaderArchives($render_pass,
                                             $all_renderable_geometry);
          }
		  else
          {
            beginProgressRange( 33, 0 );
          }
          
          if ($output_geo_attribs)
          {
            DRP_outputGeoAttribsArchives($render_pass, $objects_to_cache);
          }
		  else
          {
            beginProgressRange( 33, 0 );
          }

          DRP_outputGeometryArchives($render_pass);

          if (!$is_rib_archiving_mode)
          {
            outputRIBoptions($render_pass, $curr_frame);
          }

          if (   DRP_getRenderShadowMaps($render_pass) 
              && !$is_rib_archiving_mode)
          {
            //
            // The render pass being rendered uses shadow maps.
            // Render shadow maps for each shadow map casting light.
            //
            beginProgressRange( 100, 100 * size($shadow_mapped_lights) );

            for ($curr_light in $shadow_mapped_lights)
            {
              string  $attribs_node;
              string  $shadow_camera;
              int     $generate_map;

              $attribs_node = 
                DL_getHighestLightAttribsNodeFromShape($curr_light, 
                                                       $shader_collection);

              string $attr = "generateFirstFrameOnly";
              string $node_with_attr = DLA_getNodeWithAttribute(
                $attr, 
                $attribs_node, 
                $curr_light);

              if ($node_with_attr != "")
              {
                if (   !DLA_generateFirstFrameOnly($node_with_attr)
                    || $curr_frame == $start_frame)
                {
                  // Either current light is configured to render shadow maps
                  // every frame, or it is configured to render shadow maps for
                  // the first frame and this is the first frame.
                  //
                  $generate_map = 1;
                }
                else
                {
                  // The current light is configured to render shadow maps for the
                  // first frame only, and this is not the first frame.
                  //
                  $generate_map = 0;
                }
              }
              else
              {
                // The current light does not have an attribs node but have the
                // Maya attribute useDepthMapShadows on.
                //
                $generate_map = 1;
              }
              
              $shadow_camera = $curr_light;
              
              $attr = "shadowCamera";
              $node_with_attr = DLA_getNodeWithAttribute(
                $attr, 
                $attribs_node, 
                $curr_light);
                
              if ($node_with_attr != "")
              {
                $shadow_camera = DLA_getShadowCamera($node_with_attr);

                if ($shadow_camera == "")
                  $shadow_camera = $curr_light;
              }

              if ($generate_map)
              {
                string $light_names[] = `ls $curr_light`;
                string $light_short_name = $light_names[0];
                setProgressMessage(
                  "Frame " + $curr_frame +
                  ": shadow map for " + $light_short_name,
                  1 );

                if (isCancelled())
                {
                  $is_cancelled = 1;
                  break;
                }

                $attr = "preRenderMEL";
                $node_with_attr = DLA_getNodeWithAttribute(
                  $attr, 
                  $attribs_node, 
                  $curr_light);
                  
                if ($node_with_attr != "")
                {
                  DLA_executePreRenderMelScript($node_with_attr, $curr_light);
                }

                string $curr_shadow_objects[];
                string $curr_shadow_instancers[];
                string $curr_shadow_instancer_geo[];

                $curr_shadow_objects = 
                  getShadowCastingGeometry($curr_light, 
                                           $visible_geometry, 
                                           $shader_collection);

                $curr_shadow_instancers = 
                  getShadowCastingInstancers($curr_light, 
                                             $particle_instancers, 
                                             $shader_collection, 
                                             $curr_shadow_instancer_geo);

                $curr_shadow_objects = 
                  stringArrayCatenate($curr_shadow_objects, $curr_shadow_instancers);
                
                if (size($curr_shadow_objects) == 0)
                {
                  break;
                }

                int $maps[];
                clear($maps);
                 
                $attr = "generateCubeShadowMap";
                $node_with_attr = DLA_getNodeWithAttribute(
                  $attr,
                  $attribs_node,
                  $curr_light);
              
                string $curr_light_type;
                $curr_light_type = `nodeType $curr_light`;            

                if( $curr_light_type == "volumeLight" || $node_with_attr != "" )
                {
                  $maps[0] = 0;
                  
                  int $cube_shw_vol_light;
                  $cube_shw_vol_light = 1;
                  
                  if( $curr_light_type == "volumeLight" )
                  {
                    string $light_shape;
                    $light_shape = 
                      `getAttr -asString ($curr_light + ".lightShape")`;
                      
                    if( $light_shape == "Cone" )
                    {
                      // Cone volume lights require only 1 shadow map; the light
                      // is not oriented like a regular spot light
                      $cube_shw_vol_light = 0;
                      $maps[0] = 4;
                    }
                  }
                  else
                    $cube_shw_vol_light = 0;
                  
                  if(   $cube_shw_vol_light != 0
                     || DLA_getGenerateCubeShadowMap($node_with_attr) )
                  {
                    int $i;
                    for ($i = size($maps); $i < 6; $i++)
                    {
                      $maps[$i] = $i;
                    }
                  }
                }
                else if(   $curr_light_type == "directionalLight"
                        || (   $curr_light_type == "spotLight"
                            && getAttr($curr_light + ".useOnlySingleDmap") == 1 ))
                {
                  $maps[size($maps)] = 0;
                }
                else if(   $curr_light_type == "spotLight"
                        || $curr_light_type == "pointLight")
                {
                  if (getAttr($curr_light + ".useX+Dmap") == 1 )
                  {
                    $maps[size($maps)] = 2;
                  }
                  if (getAttr($curr_light + ".useX-Dmap") == 1 )
                  {
                    $maps[size($maps)] = 1;
                  }
                  if (getAttr($curr_light + ".useY+Dmap") == 1 )
                  {
                    $maps[size($maps)] = 3;
                  }
                  if (getAttr($curr_light + ".useY-Dmap") == 1 )
                  {
                    $maps[size($maps)] = 4;
                  }
                  if (getAttr($curr_light + ".useZ+Dmap") == 1 )
                  {
                    $maps[size($maps)] = 5;
                  }
                  if (getAttr($curr_light + ".useZ-Dmap") == 1 )
                  {
                    $maps[size($maps)] = 0;
                  }
                }

                int    $map_index;
                string $shadow_map_type;

                $attr = "shadowMapType";
                $node_with_attr = DLA_getNodeWithAttribute(
                  $attr,
                  $attribs_node,
                  $curr_light);

                if ($node_with_attr != "")
                {
                  $shadow_map_type = DLA_getShadowMapType($node_with_attr);

                  if ($shadow_map_type == "deep" && size($maps) > 1)
                  {
                    // deep shadows don't support aggregate displays so we can
                    // only output the first map
                    int $first_map;

                    $first_map = $maps[0];

                    clear($maps);

                    $maps[0] = $first_map;

                    warning("Aggregate displays are not supported for deep shadow maps.  Rendering only one shadow map for light: " + $curr_light);
                  }
                }

                int $output_geo_prog_incr = 100 / (2 * size($maps));
                                  
                for( $map_index = 0; $map_index < size($maps); $map_index++ )
                {
                  setProgressMessage(
                    "Frame " + $curr_frame 
                    + ": shadow map for " + $light_short_name
                    + ": outputting world: ",
                    0 );

                  int $frame_number;
                  $frame_number = $curr_frame;
                  RiFrameBegin -f $frame_number;

                    outputRIBcomment("");
                    outputRIBcomment("render shadow map for light: " + $curr_light);

                    outputShadowMapImageOptions($render_pass,
                                                $curr_light,
                                                $shadow_camera,
                                                $curr_shadow_objects,
                                                $maps[$map_index],
                                                $map_index != 0);

                    DRP_executePostOptionMelScript($render_pass);

                    outputCameraTransform($shadow_camera, $maps[$map_index]);

                    outputClippingPlanes($clipping_planes);

                    outputShadowMapUserAttribs($render_pass);
                    
                    RiWorldBegin;

                      outputCoordinateSystems($coordinate_systems);
// update current camera
global string $ZHANG_curcamera;
$ZHANG_curcamera = $shadow_camera;
                      outputGeometryAndCSG(
                        $render_pass,
                        $curr_shadow_objects,
                        $visible_lights,
                        $curr_shadow_instancer_geo,
                        1, // shadow render
                        $output_geo_prog_incr);
                        
                      setProgressMessage(
                        "Frame " + $curr_frame 
                        + ": shadow map for " + $light_short_name
                        + ": Rendering ",
                        0 );
                      
                    RiWorldEnd;

                  RiFrameEnd;

                  incProgress( $output_geo_prog_incr, 0 );
                }

                // Correct for rounding when computing $output_geo_prog_incr
                incProgress( 100 - (2*size($maps)) * $output_geo_prog_incr, 0 );
                
                $attr = "postRenderMEL";
                $node_with_attr = DLA_getNodeWithAttribute(
                  $attr, 
                  $attribs_node, 
                  $curr_light);
                
                if ($node_with_attr != "")
                  DLA_executePostRenderMelScript($node_with_attr, $curr_light);
              }
            }
          }
          
          if (   !$is_cancelled
              && (   DRP_getRenderPrimaryDisplay($render_pass)
                  || DRP_getRenderSecondaryDisplays($render_pass)))
          {
            outputDisplayProgressMessage($render_pass, $curr_frame);

            if (!isCancelled())
            {
              float $frame_output_start_time = `timerX`;

              if (!$is_rib_archiving_mode)
              {
                int $frame_number;
                $frame_number = $curr_frame;
                RiFrameBegin -f $frame_number;

                  outputImageOptions($render_pass);

                  if( DRP_renderPhotonMaps($render_pass) )
                  {
                    // options enabling automatic photon map generation
                    outputPhotonMapOptions( $render_pass );
                  }
              }

                  DRP_executePostOptionMelScript($render_pass);

              if (!$is_rib_archiving_mode)
              {
                  outputRIBcomment("");
                  outputRIBcomment("maya cameras named coordinate systems");
                  string $cameras[] = `ls -type camera`;
                  for( $camera in $cameras )
                  {
                    if( 1 == `getAttr( $camera + ".orthographic" )` )
                      continue;

                    string $cam_parents[] = 
                      `listRelatives -parent -path $camera`;
                    float $fov = `camera -q -hfv $camera`;

                    // This one is for the projection node.
                    RiTransformBegin;
                      RiIdentity;
                      RiPerspective $fov;
                      RiScale 1 1 -1;
                      outputTransform($camera, 1, 1, 0);
                      RiCoordinateSystem -n ("mayaCamera:" + $cam_parents[0]);
                      RiOption -n "user"
                               -p ($cam_parents[0] + "_camera_aspectRatio")
                                  "float"
                                  `camera -q -aspectRatio $camera`;
                    RiTransformEnd;

                    // This one is for "dice" "referencecamera" attribute.
                    RiTransformBegin;
                      RiIdentity;
                      outputProjection($render_pass, $camera);
                      RiScale 1 1 -1;
                      outputTransform($camera, 1, 1, 0);
                      RiCamera -n $camera;
                    RiTransformEnd;
                  }

                  outputRIBcomment("");
                  outputRIBcomment("render camera: " + $render_camera);
                  outputProjection($render_pass, $render_camera);
                  outputCameraTransform($render_camera, 0);

                  outputDepthOfField($render_pass);

                  DRP_outputImagerShader($render_pass);

                  outputClippingPlanes($clipping_planes);

                  DRP_executePreWorldMelScript($render_pass);
              }
              
                  float $world_output_start_time = `timerX`;

              if (!$is_rib_archiving_mode)
              {
                  RiWorldBegin;

                    outputCoordinateSystems($coordinate_systems);
              }

              if ($output_light_sources)
              {
                    DRP_outputLights($render_pass,
                                     $visible_lights,
                                     $output_transforms,
                                     $area_light_plane);
              }
              else
              {
                beginProgressRange( 25, 0 );
              }

              beginProgressRange( 25, 25 );

              setProgressMessage(
                "Frame " + $curr_frame 
                + ": outputting geometry: ", 0 );
// update current camera
global string $ZHANG_curcamera;
$ZHANG_curcamera = $render_camera;
              outputGeometryAndCSG(
                $render_pass,
                $xforms,
                $visible_lights,
                $renderable_instancer_geo,
                0, // not shadow render
                25);

              if (!$is_rib_archiving_mode)
              {
                  setProgressMessage(
                    "Frame " + $curr_frame + ": rendering displays", 1 );

                  $comment = "World output (for frame " + $curr_frame + ") in ";
                  outputTimingComment($comment, $world_output_start_time);

                  float $render_start_time = `timerX`;

                  RiWorldEnd;

                  if( DRP_isImmediateRenderMode( $render_pass ) )
                    outputTimingComment( "Rendered in ", $render_start_time );

                RiFrameEnd;

                $comment = "Frame " + $curr_frame + " output in ";

                outputTimingComment($comment, $frame_output_start_time);
              }
            }
            else
              $is_cancelled = 1;
          }

        setProgressMessage(
          "Frame " + $curr_frame + ": done", 1 );
        incProgress( 50, 0 );

        // cleanup
        delightFlushAllCaches();

        outputTimingComment("All RIB output completed in ",
                            $RIB_output_start_time);

        RiEnd;

        $gInRiBeginEnd = 0;
      }
    }

    DRP_executePostFrameMelScript($render_pass);
  }
  
//  print("outputIlluminateStatements() time: " + $g_illuminateStatementsTime + "s\n");

  if ($area_light_plane != "")
    delete `firstParentOf $area_light_plane`;

  editRenderLayerGlobals -currentRenderLayer $current_layer; 
   
  endProgress();
	
  if (DRP_isBackgroundRenderMode($render_pass))
  {
    startBackgroundRender($render_pass);
  }
}
